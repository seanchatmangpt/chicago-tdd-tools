# Chicago TDD Tools Cursor Rules - 80/20 Production-Ready Code Standards

## Core Principle: No Placeholders, Real Implementations

All code must be production-ready with proper error handling. Focus on critical path implementations that provide 80% of value.

**Key Principle**: "Never trust the text, only trust test results" - All implementations must be verifiable through tests.

## Workflow Commands

**Use these commands for complex workflows**:
- **[ACP Command](.cursor/commands/acp.md)** - Add, commit, push workflow with validation
- **[Verify Tests Command](.cursor/commands/verify-tests.md)** - Test verification workflow
- **[Expert Testing Patterns](.cursor/commands/expert-testing-patterns.md)** - Expert-level testing workflows

**Lean Six Sigma Commands** (expert-level coding behavior):
- **[Eliminate Muda](.cursor/commands/eliminate-muda.md)** - Identify and eliminate waste in code
- **[Gemba Walk](.cursor/commands/gemba-walk.md)** - Go to source, verify actual behavior
- **[Poka-Yoke Design](.cursor/commands/poka-yoke-design.md)** - Design code to prevent errors at compile time
- **[DMAIC Problem Solving](.cursor/commands/dmaic-problem-solving.md)** - Systematic problem-solving methodology
- **[Kaizen Improvement](.cursor/commands/kaizen-improvement.md)** - Continuous small improvements
- **[Eliminate Mura](.cursor/commands/eliminate-mura.md)** - Eliminate unevenness and inconsistency
- **[Andon Signals](.cursor/commands/andon-signals.md)** - Treat compiler errors and test failures as stop signals
- **[Root Cause Analysis](.cursor/commands/root-cause-analysis.md)** - Use 5 Whys to find root causes

## Critical Non-Negotiables

### Build System: ALWAYS Use Cargo Make

**NEVER use these directly:**
- ❌ `cargo check`, `cargo build`, `cargo test`, `cargo clippy`, `cargo fmt`

**ALWAYS use these instead:**
- ✅ `cargo make check` - Check compilation
- ✅ `cargo make build` - Build crate
- ✅ `cargo make test` - Run all tests
- ✅ `cargo make lint` - Lint code
- ✅ `cargo make fmt` - Format code
- ✅ `cargo make pre-commit` - Pre-commit validation

**Rationale**: Cargo-make handles proc-macro crate correctly, includes timeouts, and ensures consistent configuration.

### Behavior Verification: Tests Must Verify Observable Outputs

**Prohibited**:
- ❌ Tests that only verify `assert_ok!()` or `assert_err!()` without checking outputs
- ❌ Tests that don't verify state changes, outputs, execution order, or actual effects

**Required**:
- ✅ Tests verify what code does (observable outputs/state), not just that functions exist
- ✅ Tests check state changes, outputs, execution order, or actual effects

**Example**:
```rust
// ❌ BAD: Only checks function exists
chicago_test!(test_function, {
    let result = function();
    assert_ok!(result); // Doesn't verify behavior
});

// ✅ GOOD: Verifies observable behavior
chicago_test!(test_function, {
    let input = 5;
    let result = function(input);
    assert_eq!(result, 10); // Verifies actual behavior
});
```

### Chicago TDD Principles

1. **State-Based Testing**: Tests verify outputs and state, not implementation details
2. **Real Collaborators**: Use real objects, minimize mocks
3. **Behavior Verification**: Tests verify what code does, not how
4. **AAA Pattern**: Arrange-Act-Assert structure required

**Reference**: See [Chicago TDD Standards](.cursor/rules/chicago-tdd-standards.mdc) for complete principles

## Completion Workflow - MANDATORY STEPS

### Step 1: Run Tests Immediately

**Action**: Run tests before making any completion claims.

```bash
cargo make test
```

**If tests fail**: 
- **STOP** - Do not mark work complete
- Extract failing test names
- Create rich todos (see below)
- Fix tests
- Re-run `cargo make test`
- Only proceed when all tests pass

**Reference**: See [Verify Tests Command](.cursor/commands/verify-tests.md) for complete workflow

### Step 2: Create Rich Todos for Failures

**Action**: Create detailed todos for each failing test.

**Rich Todo Format**:
```markdown
- [ ] Fix failing test: `test_fixture_creation`
  - Error: `assertion failed: expected 1, got 0`
  - File: `src/fixture.rs:123`
  - Root cause: Counter initialization issue
  - Fix: Initialize counter to 1 instead of 0
  - Status: `pending`
```

**Include**: Test name, error message, file/line, root cause, proposed fix, status

**Batch Creation**: Create 5-10+ related todos in a single `TodoWrite` call, not one at a time.

### Step 3: Fix Tests Systematically

**Action**: Fix each failing test one at a time.

1. Read test failure message
2. Identify root cause
3. Fix the issue
4. Run specific test: `cargo make test test_name`
5. Verify fix works
6. Update todo status to `completed`
7. Remove from todo list when fixed

### Step 4: Re-Run All Tests

**Action**: Verify all fixes worked.

```bash
cargo make test
```

**If still failing**: Return to Step 2, create new todos for remaining failures

### Step 5: Verify Completion Criteria

**Check all of these**:
- ✅ All tests pass (`cargo make test` exits with code 0)
- ✅ No compilation errors (`cargo make check` succeeds)
- ✅ No test failures
- ✅ All failing tests have been fixed and removed from todo list
- ✅ No pending todos related to test failures

**Only then**: Mark work as complete

**CRITICAL**: Never mark todos as complete without running `cargo make test` first.

## Running Tests Quickly

### Quick Feedback Commands

**Action**: Run only what you need for fast feedback.

```bash
cargo make check          # Fast: Check compilation only (~1s)
cargo make test-unit      # Fast: Unit tests only (~1s)
cargo make test-examples  # Fast: Examples only (~1s)
cargo make test test_name # Fast: Single test for rapid iteration
```

**Full validation**:
```bash
cargo make test           # Complete: All tests
cargo make pre-commit     # Complete: Format, lint, test
```

### Test Failure Workflow

1. Run tests: `cargo make test`
2. If failures found, run specific test: `cargo make test test_failing_name`
3. Fix and verify quickly: `cargo make check` then `cargo make test test_failing_name`
4. Run all tests before completion: `cargo make test`

## Prohibited Patterns ❌

1. **Placeholders** - No "In production, this would..." comments
2. **TODOs** - No TODO comments except clearly documented future enhancements
3. **Unhandled errors** - No `unwrap()`, `expect()`, or panics in production code
4. **Stubs** - No functions that always succeed without implementation
5. **Simulated behavior** - Use real libraries when available
6. **Claims without verification** - Never claim code works without test validation
7. **Meaningless tests** - No tests that only verify `assert_ok!()` or `assert_err!()` without checking observable outputs
8. **Direct cargo commands** - NEVER use `cargo check`, `cargo build`, `cargo test` directly

## Required Patterns ✅

1. **Real library integrations** - Use actual dependencies when available
2. **Error handling** - `Result<T, E>` for all fallible operations
3. **Feature gating** - `#[cfg(feature = "...")]` for optional dependencies
4. **Test verification** - All code must be testable and tested
5. **Behavior verification** - Tests must verify observable outputs/state, not just function existence
6. **Chicago TDD principles** - State-based testing, real collaborators, behavior verification

## Expert Testing

**Action**: Test the 20% of cases that catch 80% of bugs:
- Error paths (not just happy path)
- Boundary conditions (empty, single, max, zero, negative)
- Resource cleanup (error paths and panic paths)
- Concurrency (if applicable)
- Real dependencies (not just mocks)

**Reference**: See [Expert Testing Patterns Command](.cursor/commands/expert-testing-patterns.md) for complete workflows and examples

## Documentation References

- **[Getting Started Guide](docs/GETTING_STARTED.md)** - Quick start with verified examples
- **[User Guide](docs/USER_GUIDE.md)** - Comprehensive usage guide
- **[API Reference](docs/API_REFERENCE.md)** - Complete API documentation
- **[Chicago TDD Standards](.cursor/rules/chicago-tdd-standards.mdc)** - Testing methodology
- **[Build System Practices](.cursor/rules/build-system-practices.mdc)** - Build commands and workflows

## Summary

**Critical Requirements**:
- ✅ Use `cargo make` commands, never direct `cargo` commands
- ✅ Tests must verify observable outputs/state, not just function existence
- ✅ Run `cargo make test` before marking work complete
- ✅ Create rich todos for test failures
- ✅ Follow Chicago TDD principles: state-based, real collaborators, behavior verification

**Workflow Commands**: Use [ACP Command](.cursor/commands/acp.md), [Verify Tests Command](.cursor/commands/verify-tests.md), and [Expert Testing Patterns](.cursor/commands/expert-testing-patterns.md) for complex workflows.
