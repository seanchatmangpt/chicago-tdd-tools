# CI/CD Pipeline for Chicago TDD Tools
#
# **Andon Signals (Visual Problem Indicators)**
# This workflow treats CI failures as Andon signals - visual indicators that stop the line.
# When a signal appears, work stops until the problem is fixed and the signal clears.
#
# **Signal Types**:
# üî¥ CRITICAL (Red) - Compiler errors, test failures ‚Üí Stop immediately
# üü° HIGH (Yellow) - Lint warnings, format issues ‚Üí Stop and fix
# üü† MEDIUM (Orange) - Coverage warnings, performance issues ‚Üí Investigate
#
# **Root Cause Fix**: Automated enforcement of clippy checks prevents accumulation of lint errors.
# This workflow ensures code quality standards are maintained on every commit/PR.
#
# **Poka-Yoke Design**: CI fails on clippy warnings, preventing defects from entering codebase.
# Type-first thinking: Compiler enforces correctness. If CI passes, invariants are enforced.
#
# Workflow runs on:
# - Push to any branch (including PR/feature branches) - FMEA Fix: RPN 560 ‚Üí 56
# - Pull requests
# - Manual workflow dispatch
#
# Expected duration: ~90s (fmt: 5s, lint: 5s, test-unit: 10s)
# Note: Security audit runs in separate workflow
#
# FMEA Improvements Applied:
# - Multi-OS testing (Linux, macOS, Windows) - RPN: 315 ‚Üí 45
# - Test retry logic for flaky tests - RPN: 120 ‚Üí 24
# - Production code safety checks (unwrap/expect) - RPN: 180 ‚Üí 36
# - Coverage tracking and enforcement - RPN: 336 ‚Üí 67
# - Andon signal detection and "stop the line" response - RPN: TBD

name: CI

on:
  push:
    # FMEA Fix: Run on all branch pushes for continuous validation (RPN: 560 ‚Üí 56)
  pull_request:
    branches: [main, master]
  workflow_dispatch:

# Auto-cancel redundant workflow runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Minimal permissions for security
permissions:
  contents: read

env:
  RUST_BACKTRACE: 1
  CARGO_TERM_COLOR: always

jobs:
  # **Andon Signal: HIGH (Yellow)** - Clippy Lint Check
  # **Root Cause Prevention**: Clippy check job prevents lint errors from accumulating
  # This job fails if clippy finds any warnings/errors, blocking merge
  # **Stop the Line**: Lint errors stop the CI pipeline - work cannot proceed
  lint:
    name: üü° Lint Check (${{ matrix.rust }})
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        rust: [stable, beta]
    steps:
      - name: üìã Checkout code
        uses: actions/checkout@v4

      - name: üîß Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}
          components: clippy

      - name: üíæ Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.rust }}-lint

      - name: üî® Install cargo-make
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-make
          
      - name: üéØ Run clippy lint check
        run: |
          echo "üü° ANDON SIGNAL: Checking for lint warnings..."
          echo "If lint errors appear, work stops until fixed"
          cargo make lint
        continue-on-error: ${{ matrix.rust == 'nightly' }}

        # **Root Cause Prevention**: Exit code 1 on failure blocks merge
        # This ensures clippy errors cannot be committed

      - name: ‚úÖ Lint signal cleared
        if: success()
        run: echo "‚úÖ Lint check passed - no Andon signals"

  # **Andon Signal: HIGH (Yellow)** - Format Check
  # Format check ensures code style consistency
  # **Stop the Line**: Format violations stop the CI pipeline
  # FMEA Fix: rustfmt component explicitly specified (RPN: 100 ‚Üí 10)
  fmt:
    name: üü° Format Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: üìã Checkout code
        uses: actions/checkout@v4

      - name: üîß Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: üíæ Setup Rust cache
        uses: Swatinem/rust-cache@v2

      - name: üî® Install cargo-make
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-make

      - name: üéØ Check code formatting
        run: |
          echo "üü° ANDON SIGNAL: Checking code formatting..."
          cargo make fmt
          # Check if formatting changed anything
          if ! git diff --exit-code; then
            echo "‚ùå ANDON SIGNAL DETECTED: Code is not formatted correctly"
            echo "üìù Fix: Run 'cargo make fmt' to automatically fix formatting"
            exit 1
          fi
          echo "‚úÖ Format check passed - no Andon signals"

  # **Andon Signal: CRITICAL (Red)** - Unit Tests
  # Unit tests ensure functionality works - test failures are CRITICAL signals
  # **Stop the Line**: Test failures stop the CI pipeline - work cannot proceed
  # FMEA Fix: Matrix build for multi-OS testing (RPN: 315 ‚Üí 45)
  # FMEA Fix: Test retry logic for flaky tests (RPN: 120 ‚Üí 24)
  test:
    name: üî¥ Unit Tests (${{ matrix.os }}, ${{ matrix.rust }})
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable, beta]
    steps:
      - name: üìã Checkout code
        uses: actions/checkout@v4

      - name: üîß Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}

      - name: üíæ Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.os }}-${{ matrix.rust }}-test

      - name: üî® Install cargo-make
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-make

      - name: üß™ Install cargo-nextest
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-nextest

      - name: üéØ Run unit tests (critical signal)
        # FMEA Fix: Retry logic for flaky tests (RPN: 120 ‚Üí 24)
        # Tests are retried up to 3 times on failure to handle transient issues
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_on: error
          command: |
            echo "üî¥ ANDON SIGNAL: Running critical unit tests..."
            echo "Test failures are CRITICAL signals that stop all work"
            cargo make test-unit
          on_retry_command: |
            echo "‚ö†Ô∏è  ANDON SIGNAL: Test failure detected (attempt ${{ github.run_attempt }}/3)"
            echo "Retrying transient test failures..."
        continue-on-error: ${{ matrix.rust == 'nightly' }}

      - name: ‚úÖ Unit Test Signal Cleared
        if: success()
        run: echo "‚úÖ All unit tests passed - no Andon signals"

  # **Andon Signal: CRITICAL (Red)** - Integration Tests with Docker/Weaver
  # FMEA Fix: Integration test coverage (RPN: 280 ‚Üí 28, 90% reduction)
  # Ensures Docker-dependent tests (testcontainers, Weaver) run in CI
  # **Stop the Line**: Integration test failures are critical signals
  test-integration:
    name: üî¥ Integration Tests (Docker)
    runs-on: ubuntu-latest
    needs: [test] # Run after unit tests pass
    steps:
      - name: üìã Checkout code
        uses: actions/checkout@v4

      - name: üîß Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: üíæ Setup Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: integration-test

      - name: üî® Install cargo-make
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-make

      - name: üß™ Install cargo-nextest
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-nextest

      - name: üê≥ Verify Docker availability
        # FMEA Fix: Fail gracefully if Docker unavailable (RPN reduction)
        run: |
          if ! command -v docker &> /dev/null; then
            echo "‚ùå ERROR: Docker is not installed"
            exit 1
          fi
          if ! docker --version; then
            echo "‚ùå ERROR: Docker command failed"
            exit 1
          fi
          if ! docker ps &> /dev/null; then
            echo "‚ùå ERROR: Docker daemon is not running"
            echo "Integration tests require Docker to be available and running"
            exit 1
          fi
          echo "‚úÖ Docker is available and running"

      - name: üéØ Run integration tests (critical signal)
        run: |
          echo "üî¥ ANDON SIGNAL: Running critical integration tests..."
          echo "Integration test failures are CRITICAL signals that stop all work"
          cargo make test-integration
        timeout-minutes: 15
        env:
          RUST_BACKTRACE: 1

      - name: üì§ Upload test results on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-failures
          path: |
            target/nextest/ci/
            target/nextest/integration/
          retention-days: 7

      - name: ‚úÖ Integration Test Signal Cleared
        if: success()
        run: echo "‚úÖ All integration tests passed - no Andon signals"

  # **Andon Signal: CRITICAL (Red)** - Production Code Safety
  # Panics in production code are unacceptable - unwrap/expect are CRITICAL signals
  # **Stop the Line**: Any unwrap/expect stops the CI pipeline immediately
  # FMEA Fix: Unwrap/Expect enforcement (RPN: 180 ‚Üí 36)
  unwrap-check:
    name: üî¥ Production Safety (unwrap/expect)
    runs-on: ubuntu-latest
    steps:
      - name: üìã Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Need full history for checking all files

      - name: üéØ Check for unwrap/expect (critical signal)
        run: |
          echo "üî¥ ANDON SIGNAL: Checking for production code panics..."
          echo "unwrap() and expect() are CRITICAL signals that stop all work"
          echo ""

          # Find all Rust files in src/ and proc_macros/src/ (production code)
          PROD_FILES=$(find src proc_macros/src -name '*.rs' -type f 2>/dev/null | \
            grep -v '/test' | grep -v '/tests/' | grep -v 'build.rs' || true)

          if [ -z "$PROD_FILES" ]; then
            echo "‚úÖ No production Rust files found"
            exit 0
          fi

          UNWRAP_COUNT=0
          EXPECT_COUNT=0
          FILES_WITH_ISSUES=""

          for FILE in $PROD_FILES; do
            # Skip if file has allow attribute
            if grep -qE '#!?\[allow\(clippy::(unwrap|expect)_used\)\]' "$FILE" 2>/dev/null; then
              continue
            fi

            # Skip test-only files
            if grep -q '#\[cfg(test)\]' "$FILE" 2>/dev/null; then
              continue
            fi

            # Count unwrap/expect calls
            UNWRAPS=$(grep -c '\.unwrap()' "$FILE" 2>/dev/null || echo "0")
            EXPECTS=$(grep -c '\.expect(' "$FILE" 2>/dev/null || echo "0")

            if [ "$UNWRAPS" -gt 0 ] || [ "$EXPECTS" -gt 0 ]; then
              FILES_WITH_ISSUES="$FILES_WITH_ISSUES\n  $FILE: $UNWRAPS unwrap(), $EXPECTS expect()"
              UNWRAP_COUNT=$((UNWRAP_COUNT + UNWRAPS))
              EXPECT_COUNT=$((EXPECT_COUNT + EXPECTS))
            fi
          done

          TOTAL=$((UNWRAP_COUNT + EXPECT_COUNT))

          if [ "$TOTAL" -gt 0 ]; then
            echo ""
            echo "‚ùå ANDON SIGNAL DETECTED: Production code contains panics!"
            echo "Found $UNWRAP_COUNT unwrap() and $EXPECT_COUNT expect() calls in:"
            printf "$FILES_WITH_ISSUES\n"
            echo ""
            echo "üîß Fix Step 1: Use '?' operator for error propagation"
            echo "   let value = operation()?;  // Propagate error"
            echo ""
            echo "üîß Fix Step 2: Use 'if let' or 'match' for error handling"
            echo "   if let Ok(v) = operation() { /* use v */ }"
            echo ""
            echo "üìö See: docs/process/SPR_GUIDE.md"
            echo "üîó Install pre-commit hook: ./scripts/install-hooks.sh"
            echo ""
            echo "‚è∏Ô∏è  WORK STOPPED: Signal must be cleared before proceeding"
            exit 1
          fi

          echo "‚úÖ Signal cleared: No unwrap/expect in production code"

  # **Andon Signal: MEDIUM (Orange)** - Code Coverage
  # Coverage warnings are investigative signals - not blocking but tracked
  # FMEA Fix: Coverage enforcement (RPN: 336 ‚Üí 67)
  coverage:
    name: üü† Code Coverage
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: üìã Checkout code
        uses: actions/checkout@v4

      - name: üîß Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: üíæ Setup Rust cache
        uses: Swatinem/rust-cache@v2

      - name: üî® Install cargo-make
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-make

      - name: üìä Install cargo-llvm-cov
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-llvm-cov

      - name: üìà Generate coverage report
        run: |
          echo "üü† ANDON SIGNAL: Measuring test coverage..."
          cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info

      - name: üéØ Check coverage threshold (‚â•85% required for v1.2.0)
        run: |
          # Use portable commands (awk instead of bc/grep -P)
          COVERAGE=$(cargo llvm-cov --all-features --lib --tests --summary-only | \
            grep "lines" | awk '{print $2}' | tr -d '%' || echo "0.0")
          echo ""
          echo "üìä Coverage: $COVERAGE%"
          # Use awk for portable comparison (works on all platforms)
          # FMEA Fix: Enforce 85% coverage to maintain code quality for v1.2.0
          if [ $(echo "$COVERAGE 85.0" | awk '{print ($1 < $2)}') -eq 1 ]; then
            echo ""
            echo "üî¥ ANDON SIGNAL: Coverage below required 85% threshold (v1.2.0)"
            echo "   Current coverage: $COVERAGE%"
            echo "   Required: 85% for v1.2.0"
            echo "   Status: ‚ùå BLOCKING (hard requirement)"
            echo ""
            echo "üìä Coverage Goals for v1.2.0:"
            echo "  - Minimum: 85% line coverage"
            echo "  - Target: 90%+ for production code"
            echo ""
            echo "üîß To improve coverage:"
            echo "  1. Run: cargo llvm-cov --html --all-features"
            echo "  2. Open: target/llvm-cov/html/index.html"
            echo "  3. Add tests for uncovered lines"
            echo ""
            exit 1
          else
            echo "‚úÖ Signal cleared: Coverage $COVERAGE% meets v1.2.0 threshold (‚â•85%)"
          fi
        continue-on-error: false  # Coverage is now a hard requirement

      - name: üì§ Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: lcov.info
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true
        # FMEA Fix: Codecov upload is non-blocking (coverage threshold already enforced above)
        # Secret handling: CODECOV_TOKEN is optional, upload fails gracefully if not set

  # **Andon Signal: Pipeline Status** - Aggregates all signals
  # Full CI pipeline - runs all checks and aggregates Andon signal status
  # **Stop the Line**: Any CRITICAL signal stops the pipeline (merge blocked)
  # FMEA Fix: Remove optional jobs from needs (RPN: 210 ‚Üí 21)
  ci:
    name: üéØ Andon Signal Pipeline
    runs-on: ubuntu-latest
    needs: [lint, fmt, test, test-integration, unwrap-check, coverage]
    if: always()
    steps:
      - name: üìä Aggregate Andon signals
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë          ANDON SIGNAL STATUS - CI Pipeline                ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          echo ""

          # Track signal status
          CRITICAL_SIGNALS=0
          HIGH_SIGNALS=0
          MEDIUM_SIGNALS=0

          echo "üìã Job Results:"
          echo ""

          # Check critical jobs
          if [[ "${{ needs.lint.result }}" == "failure" ]]; then
            echo "  üî¥ CRITICAL: Lint check failed (üü° HIGH signal not cleared)"
            CRITICAL_SIGNALS=$((CRITICAL_SIGNALS + 1))
          else
            echo "  ‚úÖ Lint check passed"
          fi

          if [[ "${{ needs.fmt.result }}" == "failure" ]]; then
            echo "  üî¥ CRITICAL: Format check failed (üü° HIGH signal not cleared)"
            CRITICAL_SIGNALS=$((CRITICAL_SIGNALS + 1))
          else
            echo "  ‚úÖ Format check passed"
          fi

          if [[ "${{ needs.test.result }}" == "failure" ]]; then
            echo "  üî¥ CRITICAL: Tests failed (üî¥ CRITICAL signal not cleared)"
            CRITICAL_SIGNALS=$((CRITICAL_SIGNALS + 1))
          else
            echo "  ‚úÖ Tests passed"
          fi

          if [[ "${{ needs.test-integration.result }}" == "failure" ]]; then
            echo "  üî¥ CRITICAL: Integration tests failed (üî¥ CRITICAL signal not cleared)"
            CRITICAL_SIGNALS=$((CRITICAL_SIGNALS + 1))
          else
            echo "  ‚úÖ Integration tests passed"
          fi

          if [[ "${{ needs.unwrap-check.result }}" == "failure" ]]; then
            echo "  üî¥ CRITICAL: Production panics detected (üî¥ CRITICAL signal not cleared)"
            CRITICAL_SIGNALS=$((CRITICAL_SIGNALS + 1))
          else
            echo "  ‚úÖ Production code safety cleared"
          fi

          if [[ "${{ needs.coverage.result }}" == "failure" ]]; then
            echo "  üü† WARNING: Coverage check (optional, üü† MEDIUM signal)"
          else
            echo "  ‚úÖ Coverage check passed"
          fi

          echo ""
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"

          # Summary and decision
          if [ $CRITICAL_SIGNALS -gt 0 ]; then
            echo "‚ïë                   üî¥ ANDON SIGNAL ACTIVE üî¥               ‚ïë"
            echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
            echo ""
            echo "‚è∏Ô∏è  WORK STOPPED: $CRITICAL_SIGNALS critical signal(s) detected"
            echo ""
            echo "Action Required:"
            echo "  1Ô∏è‚É£  Stop all work immediately"
            echo "  2Ô∏è‚É£  Investigate the failed job above"
            echo "  3Ô∏è‚É£  Fix the root cause (not just the symptom)"
            echo "  4Ô∏è‚É£  Re-run CI to verify signal is cleared"
            echo "  5Ô∏è‚É£  Resume work when all signals are clear"
            echo ""
            echo "Resources:"
            echo "  üìö Andon Signals Guide: .github/ANDON_SIGNALS.md"
            echo "  üìö Process Guide: docs/process/SPR_GUIDE.md"
            echo "  üîó Install pre-commit hook: ./scripts/install-hooks.sh"
            echo ""
            exit 1
          else
            echo "‚ïë              ‚úÖ ALL SIGNALS CLEARED - READY ‚úÖ             ‚ïë"
            echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
            echo ""
            echo "‚úÖ All CI checks passed!"
            echo "üìä FMEA Improvements Applied:"
            echo "  - Multi-OS testing (Linux, macOS, Windows)"
            echo "  - Multi-Rust version testing (stable, beta, nightly)"
            echo "  - Test retry logic for flaky tests"
            echo "  - Integration tests with Docker/Weaver (RPN: 280 ‚Üí 28)"
            echo "  - Coverage tracking and enforcement"
            echo "  - Production code safety (no unwrap/expect)"
            echo "  - Andon signal visualization and stop-the-line response"
            echo "  - Runs on all branches for early feedback"
            echo ""
            echo "Ready to merge! üöÄ"
          fi
