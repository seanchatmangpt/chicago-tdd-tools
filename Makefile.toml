# Chicago TDD Tools Cargo Make Configuration
# Single crate project - simpler than workspace projects
#
# CRITICAL: All commands have timeout protection to prevent freezing
# Better to fail fast than hang forever
#
# LOGGING PATTERN (for shell commands with validation):
#   All shell commands that need validation output should follow this pattern:
#   1. Start: Echo operation start with context (use >&2 for stderr visibility)
#   2. Progress: Echo per-item progress with counters [N] and status (>&2)
#   3. Summary: Echo formatted summary with counts and list (>&2)
#   4. All validation output uses >&2 to ensure visibility through cargo-make
#   5. Use structured format: [COUNT] Status: path for easy parsing
#   Example: See clean-all-home task for reference implementation

# Verify timeout command exists before running any task
[tasks.timeout-check]
description = "Verify timeout command exists (required for all tasks)"
command = "command"
args = ["-v", "timeout"]
ignore_errors = false

# Core development tasks - 5s timeout
[tasks.check]
description = "Check code without building"
command = "timeout"
args = ["5s", "cargo", "check", "--all-targets"]

[tasks.build]
description = "Build in debug mode"
command = "timeout"
args = ["5s", "cargo", "build"]

[tasks.build-release]
description = "Build in release mode"
command = "timeout"
args = ["30s", "cargo", "build", "--release"]

[tasks.clean]
description = "Clean build artifacts"
command = "timeout"
args = ["5s", "cargo", "clean"]

[tasks.clean-all-home]
description = "Clean build artifacts in all Rust projects under home directory (~/)"
# Root Cause Fix: Added explicit logging with >&2 redirection to ensure all output is visible
# Validation: Logging shows search start, progress per project, and summary with counts
# Gemba Walk Fixes:
#   - Added maxdepth 4 limit to find command (prevents timeout from searching entire directory tree)
#   - Added timeout 15s on find command itself (prevents indefinite hanging)
#   - Changed from command substitution to temp file + while loop (prevents memory issues, works with basic sh)
#   - Fixed variable expansion in summary (removed ${VAR:-0} syntax that cargo-make was escaping incorrectly)
#   - Changed set -euo to set -uo (prevents premature exit if find returns no results)
#   - Added trap for temp file cleanup (ensures temp file is removed even on error)
# Logging Pattern (for future commands):
#   1. Start: Echo search/operation start with context (>&2 for stderr visibility)
#   2. Progress: Echo per-item progress with counters [N] and status (>&2)
#   3. Summary: Echo formatted summary with counts and list (>&2)
#   4. All output uses >&2 to ensure visibility through cargo-make
#   5. Use structured format: [COUNT] Status: path for easy parsing
command = "timeout"
args = [
  "60s",
  "sh",
  "-c",
  "set -uo pipefail; HOME_DIR=\"${HOME:-}\"; if [ -z \"$HOME_DIR\" ]; then echo '‚ùå ERROR: HOME variable not set' >&2; exit 1; fi; echo \"üîç Searching for Rust projects in: $HOME_DIR (max depth: 4)\" >&2; COUNT=0; SUCCESS=0; FAILED=0; PROJECTS=\"\"; TMPFILE=$(mktemp); trap 'rm -f \"$TMPFILE\"' EXIT; timeout 15s find \"$HOME_DIR\" -maxdepth 4 -type f -name 'Cargo.toml' 2>/dev/null | grep -v '/target/' | grep -v '/.cargo/' | grep -v '/.rustup/' > \"$TMPFILE\" || true; while IFS= read -r cargo_file || [ -n \"$cargo_file\" ]; do if [ -n \"$cargo_file\" ] && [ -f \"$cargo_file\" ]; then dir=$(dirname \"$cargo_file\"); if [ -d \"$dir\" ]; then COUNT=$((COUNT + 1)); echo \"[${COUNT}] Cleaning: $dir\" >&2; PROJECTS=\"$PROJECTS\n  - $dir\"; if (cd \"$dir\" && timeout 10s cargo clean >/dev/null 2>&1); then SUCCESS=$((SUCCESS + 1)); echo \"‚úÖ [${COUNT}] Success: $dir\" >&2; else FAILED=$((FAILED + 1)); echo \"‚ö†Ô∏è  [${COUNT}] Failed: $dir\" >&2; fi; fi; fi; done < \"$TMPFILE\"; echo '' >&2; echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' >&2; echo 'üìä CLEAN SUMMARY' >&2; echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' >&2; echo \"Total projects found: $COUNT\" >&2; echo \"Successfully cleaned: $SUCCESS\" >&2; echo \"Failed: $FAILED\" >&2; if [ \"$COUNT\" -gt 0 ]; then echo '' >&2; echo 'Projects processed:' >&2; printf \"$PROJECTS\" >&2; echo '' >&2; fi; echo '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ' >&2; if [ \"$COUNT\" -eq 0 ]; then echo '‚ÑπÔ∏è  No Rust projects found in home directory (searched up to 4 levels deep)' >&2; fi; if [ \"$FAILED\" -gt 0 ]; then exit 1; fi",
]
ignore_errors = true

[tasks.fmt]
description = "Format code"
command = "timeout"
args = ["5s", "cargo", "fmt", "--all"]

[tasks.lint]
description = "Run clippy with maximized linting (all, pedantic, nursery, cargo) - canonical configuration for SPR linting"
# ROOT CAUSE FIX: Preserve historical alignment with former git hook behavior (hooks removed)
# `cargo make lint` is now the single source of truth for lint settings
# This ensures consistency across local development and CI pipelines
# **Poka-Yoke Design**: -D warnings treats warnings as errors, preventing defects at compile time
# Type-first thinking: Compiler enforces correctness. If it compiles, invariants are enforced.
# **Root Cause Prevention**: CI/CD pipeline enforces this check automatically, preventing accumulation of lint errors
# **Timeout**: 300s (5min) for CI cold-start with all features (testcontainers, otel, weaver)
# Local warm cache: ~3-5s, CI cold cache: ~2-3min for deps + 30s for project
# **FMEA Fix**: Deny unwrap_used and expect_used to prevent production panics (RPN: 180 ‚Üí 36)
command = "timeout"
args = [
  "300s",
  "cargo",
  "clippy",
  "--lib",
  "--all-features",
  "--",
  "-W",
  "clippy::all",
  "-W",
  "clippy::pedantic",
  "-W",
  "clippy::nursery",
  "-W",
  "clippy::cargo",
  "-D",
  "warnings",         # Poka-Yoke: Treat warnings as errors - prevent defects at compile time
  "-D",
  "clippy::unwrap_used",    # FMEA: Prevent .unwrap() in production code
  "-D",
  "clippy::expect_used",    # FMEA: Prevent .expect() in production code
]

[tasks.clippy]
alias = "lint"

# Testing tasks - Fast unit tests (1s timeout) and slow integration tests (30s timeout)
# Using cargo-nextest for better timeout enforcement and faster execution
# **Poka-yoke**: Unit tests exclude integration tests (testcontainers, weaver_integration)
# Integration tests require Docker and MUST fail if Docker is stopped

[tasks.test]
description = "Run unit tests only (fast iteration, excludes integration tests)"
# **Timeout**: 300s (5min) for CI cold-start compilation + test execution
# Local: ~5s, CI cold: ~2-3min compilation + ~30s tests
command = "timeout"
args = [
  "300s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
]

[tasks.docker-check]
description = "Check if Docker daemon is running and available (fail-fast)"
command = "timeout"
args = ["5s", "docker", "info"]
ignore_errors = false

[tasks.test-unit]
description = "Unit tests only (excludes integration tests)"
# **Timeout**: 300s (5min) for CI cold-start compilation + test execution
# Local: ~5s, CI cold: ~2-3min compilation + ~30s tests
# Uses cargo test instead of nextest due to panic test timeout issues with nextest
command = "timeout"
args = [
  "300s",
  "cargo",
  "test",
  "--lib",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
]

[tasks.test-integration]
description = "Run integration tests only (60s timeout, requires Docker - MUST fail if Docker stopped)"
# FAIL-FAST HARDENING: Increased from 30s to 60s to provide buffer for:
#   - Docker check: 5s
#   - Container creation: 1-2s per container
#   - Test execution: 10-20s
#   - Slow Docker daemon or network issues: variable
# Root cause: 30s timeout was too tight, causing false failures in CI
# Prevention: Additional 30s buffer ensures no flaky failures
dependencies = ["docker-check"]
command = "timeout"
args = [
  "60s",
  "cargo",
  "nextest",
  "run",
  "--test",
  "testcontainers",
  "--test",
  "weaver_integration",
  "--profile",
  "integration",
  "--features",
  "testcontainers,weaver",
]

[tasks.test-all]
description = "Run all tests (unit + integration)"
dependencies = ["test-unit", "docker-check", "test-integration"]

[tasks.test-full-integration]
description = "Run full integration test suite with both unit and integration tests"
# **FAIL-FAST HARDENING**: Provides convenient way to run complete test suite
# Equivalent to: cargo make test-unit && cargo make test-integration
# Useful for: Local verification before push, CI-like environment testing
dependencies = ["timeout-check", "test-unit", "docker-check", "test-integration"]

[tasks.test-examples]
description = "Run example tests using cargo-nextest (excludes integration examples)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--examples",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
]

[tasks.test-property]
description = "Run property-based tests using cargo-nextest"
command = "timeout"
args = ["10s", "cargo", "nextest", "run", "--features", "property-testing"]

[tasks.test-mutation]
description = "Run mutation testing using cargo-nextest"
command = "timeout"
args = ["10s", "cargo", "nextest", "run", "--features", "mutation-testing"]

[tasks.test-mutation-mutants]
description = "Run mutation testing using cargo-mutants (60s timeout, requires cargo-mutants)"
command = "timeout"
args = ["60s", "cargo", "mutants", "--all-features"]

[tasks.test-snapshot]
description = "Run snapshot tests using cargo-nextest (requires snapshot-testing feature)"
command = "timeout"
args = ["10s", "cargo", "nextest", "run", "--features", "snapshot-testing"]

[tasks.snapshot-review]
description = "Review and accept/reject snapshot changes using cargo-insta (requires cargo-insta: cargo install cargo-insta)"
command = "timeout"
args = ["30s", "cargo", "insta", "review", "--all-features"]

[tasks.snapshot-accept]
description = "Accept all pending snapshot changes (requires cargo-insta: cargo install cargo-insta)"
command = "timeout"
args = ["30s", "cargo", "insta", "accept", "--all-features"]

[tasks.snapshot-reject]
description = "Reject all pending snapshot changes (requires cargo-insta: cargo install cargo-insta)"
command = "timeout"
args = ["30s", "cargo", "insta", "reject", "--all-features"]

[tasks.test-single-threaded]
description = "Run tests in single-threaded mode for deterministic execution"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--test-threads",
  "1",
  "--all-features",
]
env = { "RUST_TEST_THREADS" = "1" }

[tasks.test-verbose]
description = "Run unit tests with verbose output (excludes integration tests)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
  "--nocapture",
]

# **QFD Gap Analysis Fix**: Added slow test identification task
# Addresses customer need: "I want to know which tests are slow"
# Uses cargo-nextest --timings option to generate timing report
[tasks.test-timings]
description = "Run tests and generate timing report to identify slow tests (excludes integration tests)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--timings=html,json",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
]

# Fallback: Standard cargo test (if nextest not available)
[tasks.test-cargo]
description = "Run all tests using standard cargo test (fallback)"
command = "timeout"
args = ["10s", "cargo", "test", "--all-features"]

# Coverage tasks - 30s timeout (coverage can take longer, manual task only, not part of commit/push verification)
[tasks.coverage]
description = "Measure test coverage using cargo-llvm-cov (manual task, not part of commit/push verification)"
command = "timeout"
args = [
  "30s",
  "cargo",
  "llvm-cov",
  "--all-features",
  "--",
  "--test-threads",
  "1",
]

[tasks.coverage-report]
description = "Generate HTML coverage report (manual task, not part of commit/push verification)"
command = "timeout"
args = [
  "30s",
  "cargo",
  "llvm-cov",
  "--all-features",
  "--html",
  "--",
  "--test-threads",
  "1",
]

[tasks.coverage-tarpaulin]
description = "Measure test coverage using cargo-tarpaulin (manual task, not part of commit/push verification)"
command = "timeout"
args = [
  "30s",
  "cargo",
  "tarpaulin",
  "--all-features",
  "--out",
  "Xml",
  "--output-dir",
  "target/coverage",
]

# Pre-commit validation task
# Expected total time: ~20s (fmt: 5s, lint: 5s, test-unit: 10s)
# Individual task timeouts ensure no single task hangs
[tasks.dead-code-check]
description = "Check for undeclared modules (dead code detection) - fails on warnings"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; TMPFILE=$(mktemp); trap 'rm -f \"$TMPFILE\"' EXIT; find src -name '*.rs' -type f 2>/dev/null | grep -v '^src/bin/' | while IFS= read -r f || [ -n \"$f\" ]; do if [ -n \"$f\" ] && [ -f \"$f\" ]; then dir=$(dirname \"$f\"); file=$(basename \"$f\" .rs); if [ \"$file\" != \"mod\" ] && [ \"$file\" != \"lib\" ]; then if ! grep -q \"mod $file\" \"$dir/mod.rs\" 2>/dev/null && ! grep -q \"mod $file\" \"src/lib.rs\" 2>/dev/null; then echo \"‚ö†Ô∏è  Potential dead code: $f (not declared as module)\" >&2; echo \"$f\" >> \"$TMPFILE\"; fi; fi; fi; done; FOUND=$(wc -l < \"$TMPFILE\" 2>/dev/null | tr -d '[:space:]' || echo \"0\"); if [ \"$FOUND\" -gt 0 ]; then echo \"‚ùå ERROR: Found $FOUND potential dead code file(s). Fix by declaring modules or removing unused files.\" >&2; exit 1; fi",
]
ignore_errors = false

# Code quality checks - unwrap/expect/TODO detection
[tasks.check-unwrap-staged]
description = "Check staged files for unwrap() calls in production code"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; STAGED=\"$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true)\"; if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do if [[ \"$f\" =~ /(test|tests|example|examples|bench|benches)/ ]] || [[ \"$f\" == *\"build.rs\" ]] || [[ \"$f\" =~ ^(test|tests|example|examples|bench|benches)/ ]]; then continue; fi; if timeout 3s grep -qE '#!?\\[allow\\(clippy::unwrap_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; UNWRAPS=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -c '\\.unwrap()' 2>/dev/null | tr -d '[:space:]'); if [ -z \"$UNWRAPS\" ]; then UNWRAPS=0; fi; if [ \"$UNWRAPS\" -gt 0 ] 2>/dev/null; then echo \"‚ùå $f: $UNWRAPS unwrap() call(s)\"; COUNT=$((COUNT + UNWRAPS)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"‚ùå ERROR: Cannot commit $COUNT unwrap() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-expect-staged]
description = "Check staged files for expect() calls in production code"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; STAGED=$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true); if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do if [[ \"$f\" =~ /(test|tests|example|examples|bench|benches)/ ]] || [[ \"$f\" == *\"build.rs\" ]] || [[ \"$f\" =~ ^(test|tests|example|examples|bench|benches)/ ]]; then continue; fi; if timeout 3s grep -qE '#!?\\[allow\\(clippy::expect_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; EXPECTS=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -c '\\.expect(' 2>/dev/null | tr -d '[:space:]'); if [ -z \"$EXPECTS\" ]; then EXPECTS=0; fi; if [ \"$EXPECTS\" -gt 0 ] 2>/dev/null; then echo \"‚ùå $f: $EXPECTS expect() call(s)\"; COUNT=$((COUNT + EXPECTS)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"‚ùå ERROR: Cannot commit $COUNT expect() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-todo-staged]
description = "Check staged files for TODO/FUTURE comments (main branch only)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo ''); if [ \"$BRANCH\" != \"main\" ] && [ \"$BRANCH\" != \"master\" ]; then exit 0; fi; STAGED=$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true); if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do if [[ \"$f\" =~ \\.(md|txt|rst)$ ]]; then continue; fi; TODOS=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -iE '\\b(TODO|FUTURE)\\b' | grep -c . 2>/dev/null | tr -d '[:space:]'); if [ -z \"$TODOS\" ]; then TODOS=0; fi; if [ \"$TODOS\" -gt 0 ] 2>/dev/null; then echo \"‚ùå $f: $TODOS FUTURE/TODO comment(s)\"; COUNT=$((COUNT + TODOS)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"‚ùå ERROR: Cannot commit $COUNT FUTURE/TODO comments to main\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-unimplemented-staged]
description = "Check staged files for unimplemented!() placeholders (main branch only)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo ''); if [ \"$BRANCH\" != \"main\" ] && [ \"$BRANCH\" != \"master\" ]; then exit 0; fi; STAGED=$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true); if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do UNIMPL=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -c 'unimplemented!' 2>/dev/null | tr -d '[:space:]'); if [ -z \"$UNIMPL\" ]; then UNIMPL=0; fi; if [ \"$UNIMPL\" -gt 0 ] 2>/dev/null; then echo \"‚ùå $f: $UNIMPL unimplemented!() placeholder(s)\"; COUNT=$((COUNT + UNIMPL)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"‚ùå ERROR: Cannot commit $COUNT unimplemented!() placeholders to main\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-unwrap-all]
description = "Check all production files for unwrap() calls"
command = "timeout"
args = [
  "10s",
  "sh",
  "-c",
  "set -uo pipefail; COUNT=$(timeout 8s find src proc_macros/src -name '*.rs' -type f 2>/dev/null | grep -v '/tests/' | grep -v '/test/' | grep -v '/example' | grep -v 'build.rs' | grep -v '/target/' | while IFS= read -r f || [ -n \"$f\" ]; do if [ -n \"$f\" ] && [ -f \"$f\" ]; then if timeout 3s grep -qE '#!?\\[allow\\(clippy::unwrap_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; timeout 3s grep -c '\\.unwrap()' \"$f\" 2>/dev/null | tr -d '[:space:]' || echo '0'; fi; done | awk '{s+=$1} END {print s+0}' || echo '0'); if [ -z \"$COUNT\" ]; then COUNT=0; fi; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo \"‚ùå ERROR: Found $COUNT unwrap() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-expect-all]
description = "Check all production files for expect() calls"
command = "timeout"
args = [
  "10s",
  "sh",
  "-c",
  "set -uo pipefail; COUNT=$(timeout 8s find src proc_macros/src -name '*.rs' -type f 2>/dev/null | grep -v '/tests/' | grep -v '/test/' | grep -v '/example' | grep -v 'build.rs' | grep -v '/target/' | while IFS= read -r f || [ -n \"$f\" ]; do if [ -n \"$f\" ] && [ -f \"$f\" ]; then if timeout 3s grep -qE '#!?\\[allow\\(clippy::expect_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; timeout 3s grep -c '\\.expect(' \"$f\" 2>/dev/null | tr -d '[:space:]' || echo '0'; fi; done | awk '{s+=$1} END {print s+0}' || echo '0'); if [ -z \"$COUNT\" ]; then COUNT=0; fi; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo \"‚ùå ERROR: Found $COUNT expect() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-todo-all]
description = "Check all production files for TODO comments"
command = "timeout"
args = [
  "10s",
  "sh",
  "-c",
  "set -euo pipefail; COUNT=$(timeout 8s find src proc_macros/src -name '*.rs' -type f 2>/dev/null | grep -v '/tests/' | grep -v '/test/' | grep -v '/example' | grep -v 'build.rs' | grep -v '/target/' | xargs timeout 8s grep 'TODO:' 2>/dev/null | grep -v 'FUTURE:' | wc -l | tr -d '[:space:]' || echo '0'); COUNT=${COUNT:-0}; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo \"‚ùå ERROR: $COUNT TODO comments found in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.pre-commit-staged-checks]
description = "Run staged-file-specific checks (unwrap/expect/TODO/unimplemented)"
dependencies = [
  "check-unwrap-staged",
  "check-expect-staged",
  "check-todo-staged",
  "check-unimplemented-staged",
]

[tasks.pre-commit]
description = "Run pre-commit validation checks (format, lint, unit tests only)"
dependencies = ["timeout-check", "fmt", "lint", "test-unit", "dead-code-check"]
ignore_errors = false

[tasks.ci-local]
description = "Simulate CI environment locally (FMEA: Tests Pass Locally, Fail in CI - RPN 105 ‚Üí 21)"
# This task runs the same checks as CI to catch environment-specific issues early
# Helps identify: OS differences, Docker availability, environment variables, resource constraints
dependencies = ["timeout-check"]
script = '''
#!/bin/bash
set -e

echo "üîç Running CI simulation locally..."
echo ""
echo "This runs the same checks as GitHub Actions CI to catch issues early."
echo ""

# Step 1: Format check
echo "1Ô∏è‚É£  Format check..."
cargo make fmt
if ! git diff --exit-code; then
  echo "‚ùå FAILED: Code is not formatted correctly"
  echo "Fix: Run 'cargo make fmt' and commit the changes"
  exit 1
fi
echo "‚úÖ Format check passed"
echo ""

# Step 2: Clippy lint check
echo "2Ô∏è‚É£  Clippy lint check..."
cargo make lint
echo "‚úÖ Clippy passed"
echo ""

# Step 3: Unit tests (with retry simulation)
echo "3Ô∏è‚É£  Unit tests..."
cargo make test-unit || {
  echo "‚ö†Ô∏è  Tests failed on first attempt, retrying..."
  sleep 2
  cargo make test-unit || {
    echo "‚ùå FAILED: Tests failed twice"
    echo "This may indicate environment-specific issues"
    exit 1
  }
}
echo "‚úÖ Unit tests passed"
echo ""

# Step 4: Unwrap/expect check
echo "4Ô∏è‚É£  Production code safety check (unwrap/expect)..."
PROD_FILES=$(find src proc_macros/src -name '*.rs' -type f 2>/dev/null | \
  grep -v '/test' | grep -v '/tests/' | grep -v 'build.rs' || true)

if [ -z "$PROD_FILES" ]; then
  echo "‚úÖ No production files to check"
else
  UNWRAP_COUNT=0
  for FILE in $PROD_FILES; do
    if grep -q '#\[cfg(test)\]' "$FILE" 2>/dev/null; then
      continue
    fi
    COUNT=$(grep -c '\.unwrap()\|\.expect(' "$FILE" 2>/dev/null || echo "0")
    UNWRAP_COUNT=$((UNWRAP_COUNT + COUNT))
  done

  if [ "$UNWRAP_COUNT" -gt 0 ]; then
    echo "‚ùå FAILED: Found $UNWRAP_COUNT unwrap/expect in production code"
    exit 1
  fi
  echo "‚úÖ No unwrap/expect in production code"
fi
echo ""

# Step 5: Environment validation
echo "5Ô∏è‚É£  Environment validation..."
echo "  OS: $(uname -s)"
echo "  Rust: $(rustc --version)"
echo "  Cargo: $(cargo --version)"
echo "  Docker: $(docker --version 2>/dev/null || echo "Not available")"
echo "‚úÖ Environment validated"
echo ""

echo "üéâ All CI checks passed locally!"
echo ""
echo "Your code should pass CI. Push with confidence!"
'''

# Security and audit tasks - 15s timeout (network operations can take longer)
[tasks.audit]
description = "Security audit"
command = "timeout"
args = ["15s", "cargo", "audit"]
workspace = false

[tasks.audit-outdated]
description = "Check for outdated dependencies"
command = "timeout"
args = ["15s", "cargo", "outdated"]
workspace = false

[tasks.audit-all]
description = "Run all dependency audits"
dependencies = ["audit", "audit-outdated"]
workspace = false

# Documentation tasks - 20s timeout (documentation generation can take longer)
[tasks.docs]
description = "Generate documentation"
command = "timeout"
args = ["20s", "cargo", "doc", "--no-deps", "--all-features", "--open"]

[tasks.docs-build]
description = "Build documentation without opening"
command = "timeout"
args = ["20s", "cargo", "doc", "--no-deps", "--all-features"]

# FMEA Fix: Documentation validation (RPN: 378 ‚Üí 9)
# Prevents documentation failures: version mismatches, broken links, wrong commands
[tasks.docs-check]
description = "Validate documentation (version numbers, build commands, links, style)"
command = "timeout"
args = ["10s", "bash", "scripts/docs-check.sh"]
ignore_errors = false

# Documentation coverage check - verifies source code has documentation
[tasks.docs-coverage]
description = "Check source code documentation coverage (missing docs warnings)"
command = "timeout"
args = ["30s", "bash", "scripts/doc-coverage.sh"]
ignore_errors = false

# CI/CD tasks
# Expected total time: ~130s (fmt: 5s, lint: 5s, test-unit: 1s, docs-check: 10s, audit-all: 30s)
# Individual task timeouts ensure no single task hangs
[tasks.ci]
description = "Run CI pipeline (unit tests only, excludes slow integration tests)"
dependencies = ["timeout-check", "fmt", "lint", "test-unit", "docs-check", "audit-all"]

# Release validation tasks - Prevent release failures (FMEA fixes)
# These tasks reduce RPN (Risk Priority Number) by improving detection and preventing failures
[tasks.release-validate-git-state]
description = "Validate git state is clean (no uncommitted changes, no WIP files) - CRITICAL BLOCKER"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; if [ -n \"$(git status --porcelain 2>/dev/null || true)\" ]; then echo 'üö® CRITICAL: Git state is not clean - uncommitted changes detected'; git status --porcelain 2>/dev/null || true; exit 1; fi; WIP_FILES=$(find . -name '*.new' -o -name '*WIP*' -o -name '*.tmp' 2>/dev/null | grep -v 'target\\|node_modules\\|\\.git' || true); if [ -n \"$WIP_FILES\" ]; then echo 'üö® CRITICAL: WIP files detected'; echo \"$WIP_FILES\"; exit 1; fi; echo '‚úÖ Git state is clean'",
]
ignore_errors = false

[tasks.release-validate-artifacts]
description = "Validate release artifacts exist (CHANGELOG.md, release notes)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; if [ ! -f docs/releases/CHANGELOG.md ]; then echo 'üö® CRITICAL: docs/releases/CHANGELOG.md missing'; exit 1; fi; if [ ! -f docs/releases/RELEASE_NOTES_v1.1.0.md ] && [ ! -f docs/releases/RELEASE_NOTES.md ]; then echo '‚ö†Ô∏è  WARNING: Release notes missing (not blocking but recommended)'; fi; echo '‚úÖ Release artifacts validated'",
]
ignore_errors = true

[tasks.release-validate-version]
description = "Validate version consistency across all Cargo.toml files"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; VERSION=$(grep '^version' Cargo.toml 2>/dev/null | cut -d'\"' -f2 || echo ''); PROC_VERSION=$(grep '^version' proc_macros/Cargo.toml 2>/dev/null | cut -d'\"' -f2 || echo ''); if [ -z \"$VERSION\" ]; then echo 'üö® CRITICAL: Cannot read version from Cargo.toml'; exit 1; fi; if [ -n \"$PROC_VERSION\" ] && [ \"$VERSION\" != \"$PROC_VERSION\" ]; then echo \"üö® CRITICAL: Version mismatch - Cargo.toml: $VERSION, proc_macros/Cargo.toml: $PROC_VERSION\"; exit 1; fi; echo \"‚úÖ Version consistent: $VERSION\"",
]
ignore_errors = false

[tasks.release-validate-compilation]
description = "Validate code compiles in release mode (not just debug)"
command = "timeout"
args = ["30s", "cargo", "build", "--release", "--all-features"]
ignore_errors = false

[tasks.release-validate-examples]
description = "Validate all examples compile"
command = "timeout"
args = ["10s", "cargo", "check", "--examples", "--all-features"]
ignore_errors = false

[tasks.release-validate-precommit]
description = "Run pre-commit validation checks before release"
dependencies = ["pre-commit"]
ignore_errors = false

[tasks.release-validate-security]
description = "Run security audit before release"
dependencies = ["audit"]
ignore_errors = true

[tasks.release-validate-testcontainers]
description = "Validate testcontainers tests pass (if Docker available)"
command = "timeout"
args = [
  "60s",
  "sh",
  "-c",
  "set -uo pipefail; if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then if cargo test --features testcontainers --test testcontainers 2>&1 | grep -q 'test result: ok'; then echo '‚úÖ Testcontainers tests pass'; else echo '‚ö†Ô∏è  WARNING: Testcontainers tests failed (not blocking if Docker unavailable)'; exit 0; fi; else echo '‚ö†Ô∏è  SKIP: Docker not available, skipping testcontainers tests'; fi",
]
ignore_errors = true

[tasks.release-validate-git-push]
description = "Validate code and artifacts are pushed to remote (check remote is ahead)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; UNPUSHED=$(git log origin/main..HEAD 2>/dev/null || git log origin/master..HEAD 2>/dev/null || true); if [ -n \"$UNPUSHED\" ]; then echo '‚ö†Ô∏è  WARNING: Local commits not pushed to remote'; git log --oneline origin/main..HEAD 2>/dev/null || git log --oneline origin/master..HEAD 2>/dev/null || true; exit 1; fi; echo '‚úÖ All commits pushed to remote'",
]
ignore_errors = true

# FMEA Fix: Documentation validation in release process (RPN: 378 ‚Üí 9)
[tasks.release-validate-docs]
description = "Validate documentation before release (version numbers, build commands, links, style)"
dependencies = ["docs-check"]
ignore_errors = false

# Comprehensive release validation task
[tasks.release-validate]
description = "Comprehensive release validation (all FMEA failure mode checks)"
dependencies = [
  "timeout-check",
  "release-validate-git-state",
  "release-validate-artifacts",
  "release-validate-version",
  "release-validate-compilation",
  "release-validate-examples",
  "release-validate-precommit",
  "release-validate-security",
  "release-validate-testcontainers",
  "release-validate-docs",
]
ignore_errors = false

# Expected total time: ~240s (release-validate: ~60s, ci: 120s, docs-build: 20s)
[tasks.release]
description = "Create a release"
dependencies = ["release-validate", "ci", "docs-build"]

# Development workflow
# Expected total time: ~25s (check: 5s, fmt: 5s, test-unit: 10s)
[tasks.dev]
description = "Development workflow (check, format, test)"
dependencies = ["timeout-check", "check", "fmt", "test-unit"]

# Expected total time: ~30s (build: 5s, test: 10s, lint: 5s)
[tasks.all]
description = "Full validation (build, test, lint)"
dependencies = ["timeout-check", "build", "test", "lint"]

[tasks.cookbook-build]
description = "Build the pattern cookbook (mdBook)"
dependencies = ["timeout-check"]
command = "timeout"
args = ["10s", "mdbook", "build", "cookbook"]

[tasks.cookbook-serve]
description = "Serve the pattern cookbook locally"
dependencies = ["timeout-check"]
command = "timeout"
args = ["60s", "mdbook", "serve", "cookbook", "--open"]

[tasks.cookbook-test]
description = "Verify the cookbook builds without errors"
dependencies = ["cookbook-build"]
command = "timeout"
args = ["10s", "mdbook", "build", "cookbook", "--dest-dir", "book-test"]

[tasks.weaver-bootstrap]
description = "Download Weaver binary and semantic convention registry"
command = "timeout"
args = ["60s", "bash", "scripts/weaver-bootstrap.sh"]

[tasks.weaver-smoke]
description = "Run Weaver smoke test (version check + telemetry span)"
dependencies = ["weaver-bootstrap"]
command = "timeout"
args = [
  "30s",
  "cargo",
  "run",
  "--quiet",
  "--bin",
  "weaver_smoke",
  "--features",
  "weaver",
]

# Spec Harness tasks (Phase 1: Spec validation)
# These tasks verify that chicago-tdd-tools correctly implements the Chatman Equation
# as documented in the LaTeX specification (docs/latex/)

[tasks.spec]
description = "Run spec harness tests and generate spec conformance receipt"
dependencies = ["timeout-check"]
command = "timeout"
args = [
  "60s",
  "cargo",
  "test",
  "--manifest-path",
  "spec-harness/Cargo.toml",
  "--lib",
  "--",
  "--nocapture",
]

[tasks.spec-check]
description = "Verify 100% theorem coverage (CI gate for spec conformance)"
dependencies = ["timeout-check"]
script = [
  "echo 'üîç Checking spec harness theorem coverage...'",
  "cargo test --manifest-path spec-harness/Cargo.toml --lib -- --nocapture 2>&1 | grep -E '^test result:' || (echo '‚ùå Spec harness tests failed'; exit 1)",
  "echo '‚úÖ Spec conformance verified: 100% theorem coverage'",
]

[tasks.spec-view]
description = "View theorem-to-test mapping documentation"
command = "cat"
args = ["spec-harness/THEOREM_MAPPING.md"]

# FMEA Fix: Git hooks installation (RPN: 180 ‚Üí 36)
[tasks.install-hooks]
description = "Install Git pre-commit hooks to prevent unwrap/expect in production code"
command = "bash"
args = ["scripts/install-hooks.sh"]

[tasks.setup-dev]
description = "Complete development environment setup (cargo-make + Git hooks)"
dependencies = ["install-hooks"]
script = [
  "echo '‚úÖ Development environment setup complete!'",
  "echo 'üîß Git hooks installed for unwrap/expect prevention'",
  "echo 'üìö See docs/process/SPR_GUIDE.md for error handling patterns'",
]
