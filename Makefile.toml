# Chicago TDD Tools Cargo Make Configuration
# Single crate project - simpler than workspace projects
#
# CRITICAL: All commands have timeout protection to prevent freezing
# Better to fail fast than hang forever

# Verify timeout command exists before running any task
[tasks.timeout-check]
description = "Verify timeout command exists (required for all tasks)"
command = "command"
args = ["-v", "timeout"]
ignore_errors = false

# Core development tasks - 5s timeout
[tasks.check]
description = "Check code without building"
command = "timeout"
args = ["5s", "cargo", "check", "--all-targets"]

[tasks.build]
description = "Build in debug mode"
command = "timeout"
args = ["5s", "cargo", "build"]

[tasks.build-release]
description = "Build in release mode"
command = "timeout"
args = ["30s", "cargo", "build", "--release"]

[tasks.clean]
description = "Clean build artifacts"
command = "timeout"
args = ["5s", "cargo", "clean"]

[tasks.clean-all-home]
description = "Clean build artifacts in all Rust projects under home directory (~/)"
# Root Cause Fix: Added explicit logging with >&2 redirection to ensure all output is visible
# Validation: Logging shows search start, progress per project, and summary with counts
command = "timeout"
args = [
  "60s",
  "sh",
  "-c",
  "set -euo pipefail; HOME_DIR=\"${HOME:-}\"; if [ -z \"$HOME_DIR\" ]; then echo 'âŒ ERROR: HOME variable not set' >&2; exit 1; fi; echo \"ðŸ” Searching for Rust projects in: $HOME_DIR\" >&2; COUNT=0; SUCCESS=0; FAILED=0; PROJECTS=\"\"; for cargo_file in $(find \"$HOME_DIR\" -type f -name 'Cargo.toml' 2>/dev/null | grep -v '/target/' | grep -v '/.cargo/' | grep -v '/.rustup/' || true); do if [ -f \"$cargo_file\" ]; then dir=$(dirname \"$cargo_file\"); if [ -d \"$dir\" ]; then COUNT=$((COUNT + 1)); echo \"[${COUNT}] Cleaning: $dir\" >&2; PROJECTS=\"$PROJECTS\n  - $dir\"; if (cd \"$dir\" && timeout 10s cargo clean >/dev/null 2>&1); then SUCCESS=$((SUCCESS + 1)); echo \"âœ… [${COUNT}] Success: $dir\" >&2; else FAILED=$((FAILED + 1)); echo \"âš ï¸  [${COUNT}] Failed: $dir\" >&2; fi; fi; fi; done; echo '' >&2; echo 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”' >&2; echo 'ðŸ“Š CLEAN SUMMARY' >&2; echo 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”' >&2; echo \"Total projects found: ${COUNT:-0}\" >&2; echo \"Successfully cleaned: ${SUCCESS:-0}\" >&2; echo \"Failed: ${FAILED:-0}\" >&2; if [ \"${COUNT:-0}\" -gt 0 ]; then echo '' >&2; echo 'Projects processed:' >&2; echo \"$PROJECTS\" >&2; fi; echo 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”' >&2; if [ \"${COUNT:-0}\" -eq 0 ]; then echo 'â„¹ï¸  No Rust projects found in home directory' >&2; fi; if [ \"${FAILED:-0}\" -gt 0 ]; then exit 1; fi",
]
ignore_errors = true

[tasks.fmt]
description = "Format code"
command = "timeout"
args = ["5s", "cargo", "fmt", "--all"]

[tasks.lint]
description = "Run clippy with maximized linting (all, pedantic, nursery, cargo) - canonical configuration for SPR linting"
# ROOT CAUSE FIX: Preserve historical alignment with former git hook behavior (hooks removed)
# `cargo make lint` is now the single source of truth for lint settings
# This ensures consistency across local development and CI pipelines
# **Poka-Yoke Design**: -D warnings treats warnings as errors, preventing defects at compile time
# Type-first thinking: Compiler enforces correctness. If it compiles, invariants are enforced.
# **Root Cause Prevention**: CI/CD pipeline enforces this check automatically, preventing accumulation of lint errors
command = "timeout"
args = [
  "5s",
  "cargo",
  "clippy",
  "--lib",
  "--all-features",
  "--",
  "-W",
  "clippy::all",
  "-W",
  "clippy::pedantic",
  "-W",
  "clippy::nursery",
  "-W",
  "clippy::cargo",
  "-D",
  "warnings",         # Poka-Yoke: Treat warnings as errors - prevent defects at compile time
]

[tasks.clippy]
alias = "lint"

# Testing tasks - Fast unit tests (1s timeout) and slow integration tests (30s timeout)
# Using cargo-nextest for better timeout enforcement and faster execution
# **Poka-yoke**: Unit tests exclude integration tests (testcontainers, weaver_integration)
# Integration tests require Docker and MUST fail if Docker is stopped

[tasks.test]
description = "Run unit tests only (fast iteration, excludes integration tests)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
]

[tasks.docker-check]
description = "Check if Docker daemon is running and available (fail-fast)"
command = "timeout"
args = ["5s", "docker", "info"]
ignore_errors = false

[tasks.test-unit]
description = "Unit tests only using cargo-nextest (excludes integration tests)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
]

[tasks.test-integration]
description = "Run integration tests only (30s timeout, requires Docker - MUST fail if Docker stopped)"
dependencies = ["docker-check"]
command = "timeout"
args = [
  "30s",
  "cargo",
  "nextest",
  "run",
  "--test",
  "testcontainers",
  "--test",
  "weaver_integration",
  "--profile",
  "integration",
  "--features",
  "testcontainers,weaver",
]

[tasks.test-all]
description = "Run all tests (unit + integration)"
dependencies = ["test-unit", "docker-check", "test-integration"]

[tasks.test-examples]
description = "Run example tests using cargo-nextest (excludes integration examples)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--examples",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
]

[tasks.test-property]
description = "Run property-based tests using cargo-nextest"
command = "timeout"
args = ["10s", "cargo", "nextest", "run", "--features", "property-testing"]

[tasks.test-mutation]
description = "Run mutation testing using cargo-nextest"
command = "timeout"
args = ["10s", "cargo", "nextest", "run", "--features", "mutation-testing"]

[tasks.test-mutation-mutants]
description = "Run mutation testing using cargo-mutants (60s timeout, requires cargo-mutants)"
command = "timeout"
args = ["60s", "cargo", "mutants", "--all-features"]

[tasks.test-snapshot]
description = "Run snapshot tests using cargo-nextest (requires snapshot-testing feature)"
command = "timeout"
args = ["10s", "cargo", "nextest", "run", "--features", "snapshot-testing"]

[tasks.snapshot-review]
description = "Review and accept/reject snapshot changes using cargo-insta (requires cargo-insta: cargo install cargo-insta)"
command = "timeout"
args = ["30s", "cargo", "insta", "review", "--all-features"]

[tasks.snapshot-accept]
description = "Accept all pending snapshot changes (requires cargo-insta: cargo install cargo-insta)"
command = "timeout"
args = ["30s", "cargo", "insta", "accept", "--all-features"]

[tasks.snapshot-reject]
description = "Reject all pending snapshot changes (requires cargo-insta: cargo install cargo-insta)"
command = "timeout"
args = ["30s", "cargo", "insta", "reject", "--all-features"]

[tasks.test-single-threaded]
description = "Run tests in single-threaded mode for deterministic execution"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--test-threads",
  "1",
  "--all-features",
]
env = { "RUST_TEST_THREADS" = "1" }

[tasks.test-verbose]
description = "Run unit tests with verbose output (excludes integration tests)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
  "--nocapture",
]

# **QFD Gap Analysis Fix**: Added slow test identification task
# Addresses customer need: "I want to know which tests are slow"
# Uses cargo-nextest --timings option to generate timing report
[tasks.test-timings]
description = "Run tests and generate timing report to identify slow tests (excludes integration tests)"
command = "timeout"
args = [
  "10s",
  "cargo",
  "nextest",
  "run",
  "--lib",
  "--all-features",
  "--timings=html,json",
  "--",
  "--skip",
  "testcontainers",
  "--skip",
  "weaver_integration",
]

# Fallback: Standard cargo test (if nextest not available)
[tasks.test-cargo]
description = "Run all tests using standard cargo test (fallback)"
command = "timeout"
args = ["10s", "cargo", "test", "--all-features"]

# Coverage tasks - 30s timeout (coverage can take longer, manual task only, not part of commit/push verification)
[tasks.coverage]
description = "Measure test coverage using cargo-llvm-cov (manual task, not part of commit/push verification)"
command = "timeout"
args = [
  "30s",
  "cargo",
  "llvm-cov",
  "--all-features",
  "--",
  "--test-threads",
  "1",
]

[tasks.coverage-report]
description = "Generate HTML coverage report (manual task, not part of commit/push verification)"
command = "timeout"
args = [
  "30s",
  "cargo",
  "llvm-cov",
  "--all-features",
  "--html",
  "--",
  "--test-threads",
  "1",
]

[tasks.coverage-tarpaulin]
description = "Measure test coverage using cargo-tarpaulin (manual task, not part of commit/push verification)"
command = "timeout"
args = [
  "30s",
  "cargo",
  "tarpaulin",
  "--all-features",
  "--out",
  "Xml",
  "--output-dir",
  "target/coverage",
]

# Pre-commit validation task
# Expected total time: ~20s (fmt: 5s, lint: 5s, test-unit: 10s)
# Individual task timeouts ensure no single task hangs
[tasks.dead-code-check]
description = "Check for undeclared modules (dead code detection)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; find src -name '*.rs' -type f 2>/dev/null | while IFS= read -r f || [ -n \"$f\" ]; do if [ -n \"$f\" ] && [ -f \"$f\" ]; then dir=$(dirname \"$f\"); file=$(basename \"$f\" .rs); if [ \"$file\" != \"mod\" ] && [ \"$file\" != \"lib\" ]; then if ! grep -q \"mod $file\" \"$dir/mod.rs\" 2>/dev/null && ! grep -q \"mod $file\" \"src/lib.rs\" 2>/dev/null; then echo \"âš ï¸  Potential dead code: $f (not declared as module)\"; fi; fi; fi; done",
]
ignore_errors = true

# Code quality checks - unwrap/expect/TODO detection
[tasks.check-unwrap-staged]
description = "Check staged files for unwrap() calls in production code"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; STAGED=\"$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true)\"; if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do if [[ \"$f\" =~ /(test|tests|example|examples|bench|benches)/ ]] || [[ \"$f\" == *\"build.rs\" ]] || [[ \"$f\" =~ ^(test|tests|example|examples|bench|benches)/ ]]; then continue; fi; if timeout 3s grep -qE '#!?\\[allow\\(clippy::unwrap_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; UNWRAPS=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -c '\\.unwrap()' 2>/dev/null | tr -d '[:space:]'); if [ -z \"$UNWRAPS\" ]; then UNWRAPS=0; fi; if [ \"$UNWRAPS\" -gt 0 ] 2>/dev/null; then echo \"âŒ $f: $UNWRAPS unwrap() call(s)\"; COUNT=$((COUNT + UNWRAPS)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"âŒ ERROR: Cannot commit $COUNT unwrap() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-expect-staged]
description = "Check staged files for expect() calls in production code"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; STAGED=$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true); if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do if [[ \"$f\" =~ /(test|tests|example|examples|bench|benches)/ ]] || [[ \"$f\" == *\"build.rs\" ]] || [[ \"$f\" =~ ^(test|tests|example|examples|bench|benches)/ ]]; then continue; fi; if timeout 3s grep -qE '#!?\\[allow\\(clippy::expect_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; EXPECTS=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -c '\\.expect(' 2>/dev/null | tr -d '[:space:]'); if [ -z \"$EXPECTS\" ]; then EXPECTS=0; fi; if [ \"$EXPECTS\" -gt 0 ] 2>/dev/null; then echo \"âŒ $f: $EXPECTS expect() call(s)\"; COUNT=$((COUNT + EXPECTS)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"âŒ ERROR: Cannot commit $COUNT expect() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-todo-staged]
description = "Check staged files for TODO/FUTURE comments (main branch only)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo ''); if [ \"$BRANCH\" != \"main\" ] && [ \"$BRANCH\" != \"master\" ]; then exit 0; fi; STAGED=$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true); if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do if [[ \"$f\" =~ \\.(md|txt|rst)$ ]]; then continue; fi; TODOS=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -iE '\\b(TODO|FUTURE)\\b' | grep -c . 2>/dev/null | tr -d '[:space:]'); if [ -z \"$TODOS\" ]; then TODOS=0; fi; if [ \"$TODOS\" -gt 0 ] 2>/dev/null; then echo \"âŒ $f: $TODOS FUTURE/TODO comment(s)\"; COUNT=$((COUNT + TODOS)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"âŒ ERROR: Cannot commit $COUNT FUTURE/TODO comments to main\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-unimplemented-staged]
description = "Check staged files for unimplemented!() placeholders (main branch only)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo ''); if [ \"$BRANCH\" != \"main\" ] && [ \"$BRANCH\" != \"master\" ]; then exit 0; fi; STAGED=$(git diff --cached --name-only --diff-filter=d 2>/dev/null | grep '\\.rs$' || true); if [ -z \"$STAGED\" ]; then exit 0; fi; COUNT=0; for f in $STAGED; do UNIMPL=$(timeout 3s git diff --cached \"$f\" 2>/dev/null | grep -E '^\\+' | grep -c 'unimplemented!' 2>/dev/null | tr -d '[:space:]'); if [ -z \"$UNIMPL\" ]; then UNIMPL=0; fi; if [ \"$UNIMPL\" -gt 0 ] 2>/dev/null; then echo \"âŒ $f: $UNIMPL unimplemented!() placeholder(s)\"; COUNT=$((COUNT + UNIMPL)); fi; done; if [ \"$COUNT\" -gt 0 ]; then echo \"âŒ ERROR: Cannot commit $COUNT unimplemented!() placeholders to main\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-unwrap-all]
description = "Check all production files for unwrap() calls"
command = "timeout"
args = [
  "10s",
  "sh",
  "-c",
  "set -uo pipefail; COUNT=$(timeout 8s find src proc_macros/src -name '*.rs' -type f 2>/dev/null | grep -v '/tests/' | grep -v '/test/' | grep -v '/example' | grep -v 'build.rs' | grep -v '/target/' | while IFS= read -r f || [ -n \"$f\" ]; do if [ -n \"$f\" ] && [ -f \"$f\" ]; then if timeout 3s grep -qE '#!?\\[allow\\(clippy::unwrap_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; timeout 3s grep -c '\\.unwrap()' \"$f\" 2>/dev/null | tr -d '[:space:]' || echo '0'; fi; done | awk '{s+=$1} END {print s+0}' || echo '0'); if [ -z \"$COUNT\" ]; then COUNT=0; fi; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo \"âŒ ERROR: Found $COUNT unwrap() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-expect-all]
description = "Check all production files for expect() calls"
command = "timeout"
args = [
  "10s",
  "sh",
  "-c",
  "set -uo pipefail; COUNT=$(timeout 8s find src proc_macros/src -name '*.rs' -type f 2>/dev/null | grep -v '/tests/' | grep -v '/test/' | grep -v '/example' | grep -v 'build.rs' | grep -v '/target/' | while IFS= read -r f || [ -n \"$f\" ]; do if [ -n \"$f\" ] && [ -f \"$f\" ]; then if timeout 3s grep -qE '#!?\\[allow\\(clippy::expect_used\\)\\]' \"$f\" 2>/dev/null || timeout 3s grep -q '#\\[cfg(test)\\]' \"$f\" 2>/dev/null; then continue; fi; timeout 3s grep -c '\\.expect(' \"$f\" 2>/dev/null | tr -d '[:space:]' || echo '0'; fi; done | awk '{s+=$1} END {print s+0}' || echo '0'); if [ -z \"$COUNT\" ]; then COUNT=0; fi; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo \"âŒ ERROR: Found $COUNT expect() calls in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.check-todo-all]
description = "Check all production files for TODO comments"
command = "timeout"
args = [
  "10s",
  "sh",
  "-c",
  "set -euo pipefail; COUNT=$(timeout 8s find src proc_macros/src -name '*.rs' -type f 2>/dev/null | grep -v '/tests/' | grep -v '/test/' | grep -v '/example' | grep -v 'build.rs' | grep -v '/target/' | xargs timeout 8s grep 'TODO:' 2>/dev/null | grep -v 'FUTURE:' | wc -l | tr -d '[:space:]' || echo '0'); COUNT=${COUNT:-0}; if [ \"$COUNT\" -gt 0 ] 2>/dev/null; then echo \"âŒ ERROR: $COUNT TODO comments found in production code\"; exit 1; fi",
]
ignore_errors = false

[tasks.pre-commit-staged-checks]
description = "Run staged-file-specific checks (unwrap/expect/TODO/unimplemented)"
dependencies = [
  "check-unwrap-staged",
  "check-expect-staged",
  "check-todo-staged",
  "check-unimplemented-staged",
]

[tasks.pre-commit]
description = "Run pre-commit validation checks (format, lint, unit tests only)"
dependencies = ["timeout-check", "fmt", "lint", "test-unit", "dead-code-check"]

# Security and audit tasks - 15s timeout (network operations can take longer)
[tasks.audit]
description = "Security audit"
command = "timeout"
args = ["15s", "cargo", "audit"]
workspace = false

[tasks.audit-outdated]
description = "Check for outdated dependencies"
command = "timeout"
args = ["15s", "cargo", "outdated"]
workspace = false

[tasks.audit-all]
description = "Run all dependency audits"
dependencies = ["audit", "audit-outdated"]
workspace = false

# Documentation tasks - 20s timeout (documentation generation can take longer)
[tasks.docs]
description = "Generate documentation"
command = "timeout"
args = ["20s", "cargo", "doc", "--no-deps", "--all-features", "--open"]

[tasks.docs-build]
description = "Build documentation without opening"
command = "timeout"
args = ["20s", "cargo", "doc", "--no-deps", "--all-features"]

# CI/CD tasks
# Expected total time: ~120s (fmt: 5s, lint: 5s, test-unit: 1s, audit-all: 30s)
# Individual task timeouts ensure no single task hangs
[tasks.ci]
description = "Run CI pipeline (unit tests only, excludes slow integration tests)"
dependencies = ["timeout-check", "fmt", "lint", "test-unit", "audit-all"]

# Release validation tasks - Prevent release failures (FMEA fixes)
# These tasks reduce RPN (Risk Priority Number) by improving detection and preventing failures
[tasks.release-validate-git-state]
description = "Validate git state is clean (no uncommitted changes, no WIP files) - CRITICAL BLOCKER"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; if [ -n \"$(git status --porcelain 2>/dev/null || true)\" ]; then echo 'ðŸš¨ CRITICAL: Git state is not clean - uncommitted changes detected'; git status --porcelain 2>/dev/null || true; exit 1; fi; WIP_FILES=$(find . -name '*.new' -o -name '*WIP*' -o -name '*.tmp' 2>/dev/null | grep -v 'target\\|node_modules\\|\\.git' || true); if [ -n \"$WIP_FILES\" ]; then echo 'ðŸš¨ CRITICAL: WIP files detected'; echo \"$WIP_FILES\"; exit 1; fi; echo 'âœ… Git state is clean'",
]
ignore_errors = false

[tasks.release-validate-artifacts]
description = "Validate release artifacts exist (CHANGELOG.md, release notes)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; if [ ! -f CHANGELOG.md ]; then echo 'ðŸš¨ CRITICAL: CHANGELOG.md missing'; exit 1; fi; if [ ! -f RELEASE_NOTES_v1.1.0.md ] && [ ! -f RELEASE_NOTES.md ]; then echo 'âš ï¸  WARNING: Release notes missing (not blocking but recommended)'; fi; echo 'âœ… Release artifacts validated'",
]
ignore_errors = true

[tasks.release-validate-version]
description = "Validate version consistency across all Cargo.toml files"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; VERSION=$(grep '^version' Cargo.toml 2>/dev/null | cut -d'\"' -f2 || echo ''); PROC_VERSION=$(grep '^version' proc_macros/Cargo.toml 2>/dev/null | cut -d'\"' -f2 || echo ''); if [ -z \"$VERSION\" ]; then echo 'ðŸš¨ CRITICAL: Cannot read version from Cargo.toml'; exit 1; fi; if [ -n \"$PROC_VERSION\" ] && [ \"$VERSION\" != \"$PROC_VERSION\" ]; then echo \"ðŸš¨ CRITICAL: Version mismatch - Cargo.toml: $VERSION, proc_macros/Cargo.toml: $PROC_VERSION\"; exit 1; fi; echo \"âœ… Version consistent: $VERSION\"",
]
ignore_errors = false

[tasks.release-validate-compilation]
description = "Validate code compiles in release mode (not just debug)"
command = "timeout"
args = ["30s", "cargo", "build", "--release", "--all-features"]
ignore_errors = false

[tasks.release-validate-examples]
description = "Validate all examples compile"
command = "timeout"
args = ["10s", "cargo", "check", "--examples", "--all-features"]
ignore_errors = false

[tasks.release-validate-precommit]
description = "Run pre-commit validation checks before release"
dependencies = ["pre-commit"]
ignore_errors = false

[tasks.release-validate-security]
description = "Run security audit before release"
dependencies = ["audit"]
ignore_errors = true

[tasks.release-validate-testcontainers]
description = "Validate testcontainers tests pass (if Docker available)"
command = "timeout"
args = [
  "60s",
  "sh",
  "-c",
  "set -uo pipefail; if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then if cargo test --features testcontainers --test testcontainers 2>&1 | grep -q 'test result: ok'; then echo 'âœ… Testcontainers tests pass'; else echo 'âš ï¸  WARNING: Testcontainers tests failed (not blocking if Docker unavailable)'; exit 0; fi; else echo 'âš ï¸  SKIP: Docker not available, skipping testcontainers tests'; fi",
]
ignore_errors = true

[tasks.release-validate-git-push]
description = "Validate code and artifacts are pushed to remote (check remote is ahead)"
command = "timeout"
args = [
  "5s",
  "sh",
  "-c",
  "set -uo pipefail; UNPUSHED=$(git log origin/main..HEAD 2>/dev/null || git log origin/master..HEAD 2>/dev/null || true); if [ -n \"$UNPUSHED\" ]; then echo 'âš ï¸  WARNING: Local commits not pushed to remote'; git log --oneline origin/main..HEAD 2>/dev/null || git log --oneline origin/master..HEAD 2>/dev/null || true; exit 1; fi; echo 'âœ… All commits pushed to remote'",
]
ignore_errors = true

# Comprehensive release validation task
[tasks.release-validate]
description = "Comprehensive release validation (all FMEA failure mode checks)"
dependencies = [
  "timeout-check",
  "release-validate-git-state",
  "release-validate-artifacts",
  "release-validate-version",
  "release-validate-compilation",
  "release-validate-examples",
  "release-validate-precommit",
  "release-validate-security",
  "release-validate-testcontainers",
]
ignore_errors = false

# Expected total time: ~240s (release-validate: ~60s, ci: 120s, docs-build: 20s)
[tasks.release]
description = "Create a release"
dependencies = ["release-validate", "ci", "docs-build"]

# Development workflow
# Expected total time: ~25s (check: 5s, fmt: 5s, test-unit: 10s)
[tasks.dev]
description = "Development workflow (check, format, test)"
dependencies = ["timeout-check", "check", "fmt", "test-unit"]

# Expected total time: ~30s (build: 5s, test: 10s, lint: 5s)
[tasks.all]
description = "Full validation (build, test, lint)"
dependencies = ["timeout-check", "build", "test", "lint"]

[tasks.cookbook-build]
description = "Build the pattern cookbook (mdBook)"
dependencies = ["timeout-check"]
command = "timeout"
args = ["10s", "mdbook", "build", "cookbook"]

[tasks.cookbook-serve]
description = "Serve the pattern cookbook locally"
dependencies = ["timeout-check"]
command = "timeout"
args = ["60s", "mdbook", "serve", "cookbook", "--open"]

[tasks.cookbook-test]
description = "Verify the cookbook builds without errors"
dependencies = ["cookbook-build"]
command = "timeout"
args = ["10s", "mdbook", "build", "cookbook", "--dest-dir", "book-test"]

[tasks.weaver-bootstrap]
description = "Download Weaver binary and semantic convention registry"
command = "timeout"
args = ["60s", "bash", "scripts/weaver-bootstrap.sh"]

[tasks.weaver-smoke]
description = "Run Weaver smoke test (version check + telemetry span)"
dependencies = ["weaver-bootstrap"]
command = "timeout"
args = [
  "30s",
  "cargo",
  "run",
  "--quiet",
  "--bin",
  "weaver_smoke",
  "--features",
  "weaver",
]
