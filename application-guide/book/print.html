<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chicago TDD Tools - Application Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Practical applications and real-world usage patterns">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chicago TDD Tools - Application Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chicago-tdd-tools---application-guide"><a class="header" href="#chicago-tdd-tools---application-guide">Chicago TDD Tools - Application Guide</a></h1>
<p>Welcome to the practical application guide for Chicago TDD Tools! This guide focuses on <strong>real-world usage patterns</strong> and practical techniques for testing Rust applications.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>This guide covers:</p>
<ul>
<li><strong>Core Patterns</strong>: Fixtures, data builders, assertions, and error path testing</li>
<li><strong>Advanced Techniques</strong>: Property-based testing, mutation testing, snapshot testing, CLI testing, and concurrency testing</li>
<li><strong>Progressive Enhancement</strong>: The "Go the Extra Mile" pattern for designing increasingly valuable solutions</li>
<li><strong>Observability</strong>: OTEL instrumentation and Weaver live-check validation</li>
<li><strong>Real-World Applications</strong>: Complete examples of testing CLI tools, web services, and integration scenarios</li>
<li><strong>Best Practices</strong>: Proven patterns and migration strategies</li>
</ul>
<h2 id="who-this-guide-is-for"><a class="header" href="#who-this-guide-is-for">Who This Guide Is For</a></h2>
<ul>
<li>Developers writing Rust applications and want comprehensive testing</li>
<li>Teams adopting Chicago-style (Classicist) TDD practices</li>
<li>Engineers improving test quality and catching bugs earlier</li>
<li>Anyone learning advanced testing techniques in Rust</li>
</ul>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to Use This Guide</a></h2>
<ol>
<li><strong>Start with the Introduction</strong> to understand Chicago TDD principles</li>
<li><strong>Learn Core Patterns</strong> for everyday testing scenarios</li>
<li><strong>Explore Advanced Techniques</strong> for specific testing challenges</li>
<li><strong>Study Real-World Applications</strong> to see complete examples</li>
<li><strong>Apply Best Practices</strong> to improve your testing approach</li>
</ol>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="../cookbook/README.html">Pattern Cookbook</a> - Alexander-style patterns reference</li>
<li><a href="https://docs.rs/chicago-tdd-tools/">API Reference</a> - Complete API documentation</li>
<li><a href="https://github.com/seanchatmangpt/chicago-tdd-tools">GitHub Repository</a></li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="chicago-style-tdd-classicist"><a class="header" href="#chicago-style-tdd-classicist">Chicago-Style TDD (Classicist)</a></h3>
<p>Chicago TDD emphasizes:</p>
<ul>
<li><strong>Type Safety</strong>: Use Rust's type system to prevent errors at compile time</li>
<li><strong>Real Dependencies</strong>: Test with actual implementations, not mocks</li>
<li><strong>Error Prevention</strong>: Poka-yoke design prevents mistakes before they happen</li>
<li><strong>Quality by Default</strong>: Quality is the default, not an afterthought</li>
</ul>
<h3 id="the-8020-principle"><a class="header" href="#the-8020-principle">The 80/20 Principle</a></h3>
<p>The "second idea" typically provides 80% more value with only 20% more effort. Learn when to:</p>
<ul>
<li>Keep it simple (1st idea)</li>
<li>Apply the sweet spot (2nd idea)</li>
<li>Go all-in (3rd idea)</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="install-chicago-tdd-tools"><a class="header" href="#install-chicago-tdd-tools">Install Chicago TDD Tools</a></h3>
<pre><code class="language-toml">[dev-dependencies]
chicago-tdd-tools = { version = "1.3", features = ["testing-extras"] }
</code></pre>
<h3 id="run-examples"><a class="header" href="#run-examples">Run Examples</a></h3>
<pre><code class="language-bash"># Run basic example
cargo run --example basic_test

# Run property-based testing
cargo run --example property_testing --features property-testing

# Run mutation testing
cargo run --example mutation_testing

# Run all examples
cargo run --example go_extra_mile
</code></pre>
<h3 id="build-this-guide"><a class="header" href="#build-this-guide">Build This Guide</a></h3>
<pre><code class="language-bash"># Install mdbook if you haven't already
cargo install mdbook

# Build and serve the guide
cd application-guide
mdbook serve
</code></pre>
<p>Then visit <code>http://localhost:3000</code> in your browser.</p>
<h2 id="example-basic-test-structure"><a class="header" href="#example-basic-test-structure">Example: Basic Test Structure</a></h2>
<p>All tests follow the <strong>AAA Pattern</strong> (Arrange-Act-Assert):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(my_test, {
    // Arrange: Set up test data
    let input = 5;

    // Act: Execute the code under test
    let result = input * 2;

    // Assert: Verify the result
    assert_eq!(result, 10);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="introduction.html">Introduction</a> - Chicago TDD philosophy and principles</li>
<li><a href="core/README.html">Core Testing Patterns</a> - Everyday testing with fixtures and builders</li>
<li><a href="advanced/README.html">Advanced Techniques</a> - Specialized testing for complex scenarios</li>
<li><a href="guides/extra-mile.html">Go the Extra Mile</a> - Progressive enhancement pattern</li>
<li><a href="guides/observability.html">Observability &amp; Quality</a> - Telemetry and quality assurance</li>
<li><a href="guides/real-world.html">Real-World Applications</a> - Complete practical examples</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Proven patterns and patterns to avoid</li>
</ol>
<h2 id="featured-examples"><a class="header" href="#featured-examples">Featured Examples</a></h2>
<h3 id="from-examples-directory"><a class="header" href="#from-examples-directory">From Examples Directory</a></h3>
<ul>
<li><strong>basic_test.rs</strong> - Getting started with fixtures and data builders</li>
<li><strong>property_testing.rs</strong> - Property-based testing with proptest</li>
<li><strong>mutation_testing.rs</strong> - Validating test quality</li>
<li><strong>go_extra_mile.rs</strong> - Progressive enhancement patterns</li>
<li><strong>cli_testing.rs</strong> - Testing command-line interfaces</li>
<li><strong>snapshot_testing.rs</strong> - Golden file testing</li>
<li><strong>concurrency_testing.rs</strong> - Thread-safe testing with loom</li>
</ul>
<h3 id="from-playground"><a class="header" href="#from-playground">From Playground</a></h3>
<ul>
<li><strong>CLI tool</strong> with comprehensive sub-commands</li>
<li><strong>Integration tests</strong> with Docker containers</li>
<li><strong>Quality validation</strong> with coverage and performance metrics</li>
<li><strong>OTEL/Weaver</strong> observability examples</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>üëâ <strong>Start here</strong>: <a href="introduction.html">Introduction</a></p>
<h2 id="community--support"><a class="header" href="#community--support">Community &amp; Support</a></h2>
<ul>
<li>GitHub Issues: Report bugs or request features</li>
<li>Discussions: Share ideas and patterns with the community</li>
<li>Pattern Cookbook: Contribute Alexander-style patterns</li>
</ul>
<hr />
<p><strong>Chicago TDD Tools</strong> - Testing with confidence, errors prevented at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-chicago-tdd-philosophy"><a class="header" href="#introduction-chicago-tdd-philosophy">Introduction: Chicago TDD Philosophy</a></h1>
<blockquote>
<p>üìñ <strong>EXPLANATION</strong> | Learn the philosophy and principles</p>
</blockquote>
<h2 id="quick-navigation-whats-your-goal"><a class="header" href="#quick-navigation-whats-your-goal">Quick Navigation: What's Your Goal?</a></h2>
<p><strong>Not sure where to start?</strong> See <a href="choosing-your-path.html">Choosing Your Learning Path</a> for a complete navigation guide with decision matrices.</p>
<p>Choose your path based on what you're trying to do:</p>
<div class="table-wrapper"><table><thead><tr><th>Your Goal</th><th>Read This</th><th>Time</th></tr></thead><tbody>
<tr><td><strong>I'm just getting started</strong></td><td><a href="tutorials/getting-started.html">Quick Start Tutorial</a> ‚Üí <a href="tutorials/fixtures-tutorial.html">Fixtures Deep Dive</a></td><td>40 min</td></tr>
<tr><td><strong>I want to build a CLI app</strong></td><td><a href="tutorials/cli-app-tutorial.html">CLI Application Tutorial</a></td><td>45 min</td></tr>
<tr><td><strong>I want to build a web service</strong></td><td><a href="tutorials/web-service-tutorial.html">REST Web Service Tutorial</a></td><td>50 min</td></tr>
<tr><td><strong>I need to find an API</strong></td><td>Go to <a href="reference/fixtures-api.html">API Reference</a></td><td>2-5 min</td></tr>
<tr><td><strong>I want to understand Chicago TDD</strong></td><td>Read this introduction + <a href="guides/extra-mile.html">Go the Extra Mile</a></td><td>45 min</td></tr>
<tr><td><strong>I'm migrating from traditional testing</strong></td><td><a href="guides/best-practices.html">Best Practices &amp; Migration</a></td><td>1 hour</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="what-is-chicago-style-tdd"><a class="header" href="#what-is-chicago-style-tdd">What is Chicago-Style TDD?</a></h2>
<p>Chicago-style TDD (also called "Classicist" TDD) is a testing approach that emphasizes:</p>
<ol>
<li><strong>Type Safety First</strong> - Use Rust's type system to prevent entire categories of errors</li>
<li><strong>Real Dependencies</strong> - Test with actual implementations, not mocks</li>
<li><strong>Error Prevention</strong> - Mistakes are prevented at compile time, not caught at runtime</li>
<li><strong>Quality by Default</strong> - Quality is the default state; prevention beats detection</li>
</ol>
<p>This contrasts with London-style TDD, which uses mocks and message-passing verification.</p>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<h3 id="1-poka-yoke-design"><a class="header" href="#1-poka-yoke-design">1. Poka-Yoke Design</a></h3>
<p>"Poka-yoke" (fool-proofing) means designing systems to prevent mistakes before they happen.</p>
<p><strong>Example</strong>: Instead of writing a test to catch <code>panic!()</code> usage, the compiler enforces that production code never panics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Compiler error (blocked by clippy `unwrap_used` deny)
let value = result.unwrap();

// ‚úÖ Compiler accepts - proper error handling
let value = result?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-type-level-correctness"><a class="header" href="#2-type-level-correctness">2. Type-Level Correctness</a></h3>
<p>Use Rust's type system as the primary design tool. If it compiles, correctness follows.</p>
<p><strong>Example</strong>: A validated number type that proves its value is valid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidatedNumber&lt;T&gt; {
    value: T,  // Can only be constructed via parse()
}

impl&lt;T: FromStr&gt; ValidatedNumber&lt;T&gt; {
    pub fn parse(input: &amp;str) -&gt; Result&lt;Self, String&gt; {
        // Validation logic here
        input.parse().map(|value| Self { value })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-real-collaborators"><a class="header" href="#3-real-collaborators">3. Real Collaborators</a></h3>
<p>Test with actual dependencies, not mocks. This catches integration bugs and makes refactoring safer.</p>
<p><strong>Why?</strong> Mocks can hide bugs at integration boundaries. Real implementations reveal actual behavior.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chicago-style: Use the real implementation
let fixture = TestFixture::new()?;  // Real setup
let result = actual_function(&amp;fixture)?;  // Real code

// London-style: Would use a mock instead
// let fixture = MockFixture::new();
<span class="boring">}</span></code></pre></pre>
<h3 id="4-the-8020-principle"><a class="header" href="#4-the-8020-principle">4. The 80/20 Principle</a></h3>
<p>When designing solutions, consider three ideas:</p>
<ul>
<li><strong>1st Idea</strong>: Solve the immediate problem (narrow scope, simple)</li>
<li><strong>2nd Idea</strong>: 80% more value with 20% more effort (sweet spot, usually best)</li>
<li><strong>3rd Idea</strong>: Maximum value, but evaluate carefully (maximum scope, most complex)</li>
</ul>
<p>Example: Number parsing</p>
<ul>
<li>1st Idea: Parse <code>u32</code> only</li>
<li>2nd Idea: Generic parser works for all number types</li>
<li>3rd Idea: Type-validated parser with OTEL instrumentation and Weaver validation</li>
</ul>
<p>Choose the 2nd idea most of the time. Only go to 3rd idea when type safety is critical.</p>
<h2 id="why-chicago-tdd-for-rust"><a class="header" href="#why-chicago-tdd-for-rust">Why Chicago TDD for Rust?</a></h2>
<p>Rust's type system makes Chicago-style TDD especially powerful:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Compile-time guarantees</strong></td><td>Many bugs prevented before testing</td></tr>
<tr><td><strong>Ownership system</strong></td><td>Resource cleanup guaranteed</td></tr>
<tr><td><strong>Result type</strong></td><td>Explicit error handling (no surprises)</td></tr>
<tr><td><strong>Trait system</strong></td><td>Generic code with real implementations</td></tr>
<tr><td><strong>Macros</strong></td><td>Test framework enforcement at compile time</td></tr>
</tbody></table>
</div>
<h2 id="common-misconceptions"><a class="header" href="#common-misconceptions">Common Misconceptions</a></h2>
<h3 id="mocks-are-required"><a class="header" href="#mocks-are-required">"Mocks are Required"</a></h3>
<p>‚ùå <strong>False</strong> in Chicago TDD. Use real dependencies when possible.</p>
<p>Use mocks only for:</p>
<ul>
<li>External services (APIs, databases)</li>
<li>Expensive operations (file I/O, network)</li>
<li>Non-deterministic behavior (time, random numbers)</li>
</ul>
<h3 id="tests-should-only-test-public-apis"><a class="header" href="#tests-should-only-test-public-apis">"Tests Should Only Test Public APIs"</a></h3>
<p>‚ùå <strong>Partially true</strong>. Chicago TDD tests the behavior, not the interface.</p>
<p>Test internal functions if they:</p>
<ul>
<li>Have complex logic</li>
<li>Are hard to test through public APIs</li>
<li>Need boundary condition verification</li>
</ul>
<h3 id="100-coverage-means-bug-free-code"><a class="header" href="#100-coverage-means-bug-free-code">"100% Coverage Means Bug-Free Code"</a></h3>
<p>‚ùå <strong>False</strong>. Coverage measures code execution, not correctness.</p>
<p>Focus on:</p>
<ul>
<li>Error paths (the real bugs are here)</li>
<li>Boundary conditions</li>
<li>State transitions</li>
</ul>
<p><strong>Example</strong>: 100% coverage of a sorting function doesn't guarantee it handles duplicates correctly.</p>
<h2 id="testing-with-chicago-tdd-tools"><a class="header" href="#testing-with-chicago-tdd-tools">Testing with Chicago TDD Tools</a></h2>
<p>Chicago TDD Tools provides:</p>
<ul>
<li><strong>Type-level AAA enforcement</strong>: Arrange-Act-Assert structure at compile time</li>
<li><strong>Data builders</strong>: Fluent API for complex test data</li>
<li><strong>Fixture management</strong>: Test isolation and cleanup</li>
<li><strong>Assertion helpers</strong>: Clear, readable assertions</li>
<li><strong>Advanced techniques</strong>: Property-based, mutation, snapshot testing</li>
<li><strong>Observability</strong>: OTEL and Weaver integration</li>
</ul>
<p>All with zero-cost abstractions and compile-time error prevention.</p>
<h2 id="the-testing-pyramid"><a class="header" href="#the-testing-pyramid">The Testing Pyramid</a></h2>
<p>Chicago TDD follows a testing pyramid:</p>
<pre><code>        ‚ñ≥ (Few)
       /|\
      / | \    E2E Tests (slow, fragile)
     /  |  \
    /____|____\
    |    |    |    Integration Tests (medium speed)
    |____|____|
    |         |    Unit Tests (fast, many)
    |_________|
    ‚ñΩ (Many)
</code></pre>
<p><strong>Unit Tests</strong> (bottom): Fast, isolated, test one function</p>
<p><strong>Integration Tests</strong> (middle): Medium speed, test multiple components together</p>
<p><strong>E2E Tests</strong> (top): Slow, test the entire system</p>
<p>Chicago TDD emphasizes unit tests and integration tests. E2E tests are less important if unit+integration tests are comprehensive.</p>
<h2 id="aaa-pattern"><a class="header" href="#aaa-pattern">AAA Pattern</a></h2>
<p>Every test follows Arrange-Act-Assert:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_parsing, {
    // Arrange: Set up test data
    let input = "42";

    // Act: Execute the code under test
    let result = input.parse::&lt;u32&gt;();

    // Assert: Verify the result
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});
<span class="boring">}</span></code></pre></pre>
<p>This pattern ensures tests are:</p>
<ul>
<li><strong>Clear</strong>: Anyone can see what's being tested</li>
<li><strong>Complete</strong>: Setup, execution, and verification are separate</li>
<li><strong>Correct</strong>: Focused on one behavior per test</li>
</ul>
<h2 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h2>
<h3 id="parallel-tests"><a class="header" href="#parallel-tests">Parallel Tests</a></h3>
<p>By default, tests run in parallel. Ensure each test is independent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test1, {
    // Use unique data: TestFixture::new()?
    // Don't rely on global state
    // Don't use file/network resources shared with other tests
});
<span class="boring">}</span></code></pre></pre>
<h3 id="fixture-isolation"><a class="header" href="#fixture-isolation">Fixture Isolation</a></h3>
<p>Each fixture is independent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_fixture, {
    let fixture1 = TestFixture::new()?;
    let fixture2 = TestFixture::new()?;
    // fixture1 and fixture2 are completely independent
    // Automatic cleanup when they drop
});
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-topics-preview"><a class="header" href="#advanced-topics-preview">Advanced Topics Preview</a></h2>
<p>Chicago TDD Tools provides techniques for:</p>
<ol>
<li><strong>Property-Based Testing</strong>: Generate random test data and verify properties hold</li>
<li><strong>Mutation Testing</strong>: Validate test quality by introducing mutations</li>
<li><strong>Snapshot Testing</strong>: Golden files to detect unintended changes</li>
<li><strong>CLI Testing</strong>: Test command-line interfaces with trycmd</li>
<li><strong>Concurrency Testing</strong>: Deterministic thread testing with loom</li>
<li><strong>Observability</strong>: OTEL instrumentation and Weaver validation</li>
</ol>
<p>We'll explore all of these in later sections.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The best way to learn is by doing. Here's the recommended learning path:</p>
<ol>
<li><strong><a href="core/README.html">Core Patterns</a></strong> - Master fixtures, data builders, and assertions</li>
<li><strong><a href="core/error-paths.html">Error Path Testing</a></strong> - Learn where bugs hide</li>
<li><strong><a href="advanced/README.html">Advanced Techniques</a></strong> - Pick techniques for your use case</li>
<li><strong><a href="guides/real-world.html">Real-World Applications</a></strong> - See complete examples</li>
<li><strong><a href="guides/best-practices.html">Best Practices</a></strong> - Avoid common pitfalls</li>
</ol>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>‚úÖ Chicago TDD emphasizes <strong>type safety</strong> and <strong>error prevention</strong></p>
<p>‚úÖ Use <strong>real dependencies</strong>, not mocks</p>
<p>‚úÖ Follow the <strong>80/20 principle</strong> when designing solutions</p>
<p>‚úÖ Every test follows <strong>Arrange-Act-Assert</strong></p>
<p>‚úÖ Focus on <strong>error paths</strong> (where bugs hide)</p>
<p>‚ùå Don't rely on 100% coverage (it's not enough)</p>
<p>‚ùå Don't use mocks for everything</p>
<p>‚ùå Don't skip boundary condition testing</p>
<hr />
<p><strong>Next</strong>: <a href="core/README.html">Core Testing Patterns</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-your-learning-path"><a class="header" href="#choosing-your-learning-path">Choosing Your Learning Path</a></h1>
<blockquote>
<p>üó∫Ô∏è <strong>NAVIGATION</strong> | Find the right resources for your goals</p>
</blockquote>
<p>This page helps you navigate the documentation based on what you want to accomplish.</p>
<hr />
<h2 id="quick-navigation-by-goal"><a class="header" href="#quick-navigation-by-goal">Quick Navigation by Goal</a></h2>
<h3 id="im-just-getting-started"><a class="header" href="#im-just-getting-started">"I'm just getting started"</a></h3>
<p><strong>Duration</strong>: 1-2 hours | <strong>Difficulty</strong>: Beginner</p>
<p>Start here and follow in order:</p>
<ol>
<li><strong><a href="introduction.html">Introduction</a></strong> (10 min) - Understand Chicago TDD philosophy</li>
<li><strong><a href="tutorials/getting-started.html">Quick Start Tutorial</a></strong> (25 min) - Write your first test</li>
<li><strong><a href="tutorials/fixtures-tutorial.html">Fixtures Deep Dive</a></strong> (15 min) - Master test isolation</li>
<li><strong><a href="core/README.html">Core Testing Patterns</a></strong> (20 min) - Learn the essentials</li>
<li><strong><a href="core/error-paths.html">Error Path Testing</a></strong> (15 min) - Find where bugs hide</li>
</ol>
<p><strong>Next step</strong>: Pick one real-world tutorial based on what you want to build.</p>
<hr />
<h3 id="i-want-to-build-a-cli-application"><a class="header" href="#i-want-to-build-a-cli-application">"I want to build a CLI application"</a></h3>
<p><strong>Duration</strong>: 1-2 hours | <strong>Difficulty</strong>: Intermediate</p>
<p>Follow this path:</p>
<ol>
<li><strong><a href="tutorials/getting-started.html">Quick Start</a></strong> (25 min) - Review basics</li>
<li><strong><a href="tutorials/cli-app-tutorial.html">CLI Application Tutorial</a></strong> (45 min) - Build complete CLI</li>
<li><strong><a href="advanced/cli-testing.html">CLI Testing</a></strong> (20 min) - Test CLI output with golden files</li>
<li><strong><a href="guides/best-practices.html">Best Practices</a></strong> (30 min) - Production patterns</li>
</ol>
<p><strong>Key files to reference</strong>:</p>
<ul>
<li><a href="reference/fixtures-api.html">TestFixture API</a> - For test isolation</li>
<li><a href="core/error-paths.html">Error Path Testing</a> - Test error cases</li>
</ul>
<hr />
<h3 id="i-want-to-build-a-rest-api--web-service"><a class="header" href="#i-want-to-build-a-rest-api--web-service">"I want to build a REST API / Web Service"</a></h3>
<p><strong>Duration</strong>: 1.5-2.5 hours | <strong>Difficulty</strong>: Intermediate</p>
<p>Follow this path:</p>
<ol>
<li><strong><a href="tutorials/getting-started.html">Quick Start</a></strong> (25 min) - Review basics</li>
<li><strong><a href="tutorials/web-service-tutorial.html">REST Web Service Tutorial</a></strong> (50 min) - Build complete API</li>
<li><strong><a href="guides/integration-docker.html">Integration Testing with Docker</a></strong> (30 min) - Test with real database</li>
<li><strong><a href="guides/observability.html">Observability &amp; Quality</a></strong> (20 min) - Add monitoring</li>
</ol>
<p><strong>Key files to reference</strong>:</p>
<ul>
<li><a href="core/data-builders.html">Data Builders</a> - For building test data</li>
<li><a href="core/error-paths.html">Error Path Testing</a> - Test error responses</li>
</ul>
<hr />
<h3 id="i-need-to-test-complex-logic"><a class="header" href="#i-need-to-test-complex-logic">"I need to test complex logic"</a></h3>
<p><strong>Duration</strong>: 2-3 hours | <strong>Difficulty</strong>: Intermediate-Advanced</p>
<p>Follow this path:</p>
<ol>
<li><strong><a href="core/error-paths.html">Error Path Testing</a></strong> (15 min) - Comprehensive error testing</li>
<li><strong><a href="advanced/property-testing.html">Property-Based Testing</a></strong> (30 min) - Generate test cases</li>
<li><strong><a href="advanced/mutation-testing.html">Mutation Testing</a></strong> (20 min) - Validate test quality</li>
<li><strong><a href="advanced/concurrency-testing.html">Concurrency Testing</a></strong> (20 min) - Test thread safety</li>
</ol>
<p><strong>Key files to reference</strong>:</p>
<ul>
<li><a href="core/README.html">Core Testing Patterns</a> - For building blocks</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Quality assurance patterns</li>
</ul>
<hr />
<h3 id="i-want-to-ensure-high-quality-tests"><a class="header" href="#i-want-to-ensure-high-quality-tests">"I want to ensure high-quality tests"</a></h3>
<p><strong>Duration</strong>: 1-2 hours | <strong>Difficulty</strong>: Intermediate</p>
<p>Follow this path:</p>
<ol>
<li><strong><a href="core/error-paths.html">Error Path Testing</a></strong> (15 min) - Test error cases thoroughly</li>
<li><strong><a href="advanced/mutation-testing.html">Mutation Testing</a></strong> (20 min) - Validate test quality</li>
<li><strong><a href="guides/coverage-performance.html">Coverage &amp; Performance</a></strong> (20 min) - Measure metrics</li>
<li><strong><a href="guides/best-practices.html">Best Practices</a></strong> (30 min) - Industry patterns</li>
</ol>
<p><strong>Tools</strong>:</p>
<ul>
<li>Run <code>cargo make coverage</code> - Generate coverage reports</li>
<li>Run <code>cargo make test-mutation</code> - Validate test quality</li>
<li>Use <code>TestFixture</code> snapshots - Track state changes</li>
</ul>
<hr />
<h3 id="im-migrating-from-another-testing-framework"><a class="header" href="#im-migrating-from-another-testing-framework">"I'm migrating from another testing framework"</a></h3>
<p><strong>Duration</strong>: 1.5-2 hours | <strong>Difficulty</strong>: Beginner-Intermediate</p>
<p>Follow this path:</p>
<ol>
<li><strong><a href="introduction.html">Introduction</a></strong> (10 min) - Understand differences</li>
<li><strong><a href="tutorials/getting-started.html">Quick Start</a></strong> (25 min) - Learn Chicago TDD style</li>
<li><strong><a href="core/README.html">Core Testing Patterns</a></strong> (20 min) - Relearn with new approach</li>
<li><strong><a href="guides/best-practices.html">Best Practices &amp; Migration</a></strong> (30 min) - Strategies for migration</li>
</ol>
<p><strong>Key concepts to learn</strong>:</p>
<ul>
<li>Real dependencies vs mocks</li>
<li>Type-level correctness</li>
<li>AAA pattern enforcement</li>
<li>Poka-yoke design</li>
</ul>
<hr />
<h3 id="i-need-a-specific-feature"><a class="header" href="#i-need-a-specific-feature">"I need a specific feature"</a></h3>
<p>Find your feature in this table:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Where to Find It</th></tr></thead><tbody>
<tr><td>Testing basic functions</td><td><a href="core/README.html">Core Patterns</a></td></tr>
<tr><td>Fixtures &amp; setup</td><td><a href="tutorials/fixtures-tutorial.html">Fixtures Tutorial</a></td></tr>
<tr><td>Building test data</td><td><a href="core/data-builders.html">Data Builders</a></td></tr>
<tr><td>Assertions</td><td><a href="core/assertions.html">Assertions &amp; Verification</a></td></tr>
<tr><td>Error testing</td><td><a href="core/error-paths.html">Error Path Testing</a></td></tr>
<tr><td>Random test data</td><td><a href="advanced/property-testing.html">Property Testing</a></td></tr>
<tr><td>Test output validation</td><td><a href="advanced/snapshot-testing.html">Snapshot Testing</a></td></tr>
<tr><td>Testing CLI apps</td><td><a href="advanced/cli-testing.html">CLI Testing</a></td></tr>
<tr><td>Testing threads</td><td><a href="advanced/concurrency-testing.html">Concurrency Testing</a></td></tr>
<tr><td>Test quality validation</td><td><a href="advanced/mutation-testing.html">Mutation Testing</a></td></tr>
<tr><td>Test metrics</td><td><a href="guides/coverage-performance.html">Coverage &amp; Performance</a></td></tr>
<tr><td>Observability</td><td><a href="guides/otel.html">OTEL Instrumentation</a></td></tr>
<tr><td>Production patterns</td><td><a href="guides/best-practices.html">Best Practices</a></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="learning-path-summary"><a class="header" href="#learning-path-summary">Learning Path Summary</a></h2>
<h3 id="beginner-0-1-day"><a class="header" href="#beginner-0-1-day">Beginner (0-1 day)</a></h3>
<pre><code>Quick Start (25 min)
  ‚Üì
Fixtures Deep Dive (15 min)
  ‚Üì
Core Patterns (20 min)
  ‚Üì
Pick a real-world tutorial (45-50 min)
</code></pre>
<h3 id="intermediate-1-3-days"><a class="header" href="#intermediate-1-3-days">Intermediate (1-3 days)</a></h3>
<pre><code>Complete Beginner path
  ‚Üì
Advanced Techniques (property, mutation, snapshot)
  ‚Üì
Real-world applications (CLI, Web Service, Docker)
  ‚Üì
Best Practices
</code></pre>
<h3 id="advanced-3-days"><a class="header" href="#advanced-3-days">Advanced (3+ days)</a></h3>
<pre><code>Complete Intermediate path
  ‚Üì
Observability &amp; OTEL
  ‚Üì
Performance &amp; Coverage
  ‚Üì
Mutation testing &amp; quality validation
  ‚Üì
Write your own applications
</code></pre>
<hr />
<h2 id="decision-matrix"><a class="header" href="#decision-matrix">Decision Matrix</a></h2>
<p>Choose based on your situation:</p>
<h3 id="if-youre-"><a class="header" href="#if-youre-">If you're ...</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Situation</th><th>Time Available</th><th>Difficulty</th><th>Start Here</th></tr></thead><tbody>
<tr><td>Completely new to testing</td><td>2 hours</td><td>Easy</td><td><a href="tutorials/getting-started.html">Quick Start</a></td></tr>
<tr><td>Have testing experience</td><td>1.5 hours</td><td>Medium</td><td><a href="introduction.html">Introduction</a></td></tr>
<tr><td>Experienced developer</td><td>1 hour</td><td>Medium</td><td><a href="tutorials/cli-app-tutorial.html">CLI</a> or <a href="tutorials/web-service-tutorial.html">Web Service</a></td></tr>
<tr><td>Need specific feature</td><td>Varies</td><td>Varies</td><td><a href="choosing-your-path.html#need-a-specific-feature">Feature table above</a></td></tr>
<tr><td>Want certification-level knowledge</td><td>1 week</td><td>Hard</td><td>Complete all tutorials + real-world projects</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="common-starting-points"><a class="header" href="#common-starting-points">Common Starting Points</a></h2>
<h3 id="show-me-code-examples"><a class="header" href="#show-me-code-examples">"Show me code examples"</a></h3>
<p>‚Üí Jump to <a href="guides/real-world.html">Real-World Applications</a></p>
<h3 id="i-need-to-solve-a-problem-right-now"><a class="header" href="#i-need-to-solve-a-problem-right-now">"I need to solve a problem right now"</a></h3>
<p>‚Üí Search <a href="guides/best-practices.html">Best Practices</a> or use feature table above</p>
<h3 id="i-want-to-understand-the-philosophy"><a class="header" href="#i-want-to-understand-the-philosophy">"I want to understand the philosophy"</a></h3>
<p>‚Üí Read <a href="introduction.html">Introduction</a> and <a href="guides/extra-mile.html">"Go the Extra Mile"</a></p>
<h3 id="im-evaluating-this-for-my-team"><a class="header" href="#im-evaluating-this-for-my-team">"I'm evaluating this for my team"</a></h3>
<p>‚Üí Read <a href="introduction.html">Introduction</a> and skim <a href="guides/best-practices.html">Best Practices</a></p>
<h3 id="i-want-to-learn-everything"><a class="header" href="#i-want-to-learn-everything">"I want to learn everything"</a></h3>
<p>‚Üí Follow the progressive learning paths in "Learning Path Summary" above</p>
<hr />
<h2 id="next-steps-after-learning"><a class="header" href="#next-steps-after-learning">Next Steps After Learning</a></h2>
<h3 id="after-completing-quick-start--fixtures"><a class="header" href="#after-completing-quick-start--fixtures">After completing Quick Start &amp; Fixtures</a></h3>
<p>‚Üí Choose one real-world tutorial to build something real</p>
<h3 id="after-completing-a-real-world-tutorial"><a class="header" href="#after-completing-a-real-world-tutorial">After completing a real-world tutorial</a></h3>
<p>‚Üí Explore Advanced Techniques that match your needs</p>
<h3 id="after-exploring-multiple-areas"><a class="header" href="#after-exploring-multiple-areas">After exploring multiple areas</a></h3>
<p>‚Üí <a href="guides/best-practices.html">Best Practices</a> - See industry patterns</p>
<h3 id="after-mastering-the-basics"><a class="header" href="#after-mastering-the-basics">After mastering the basics</a></h3>
<p>‚Üí Build something with Chicago TDD:</p>
<ul>
<li>Open-source contribution</li>
<li>Side project</li>
<li>Production application</li>
<li>Team migration</li>
</ul>
<hr />
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><strong>Q: What's the best starting point?</strong>
A: <a href="tutorials/getting-started.html">Quick Start</a> if brand new, otherwise <a href="introduction.html">Introduction</a>.</p>
<p><strong>Q: How long does it take to learn?</strong>
A: 2-4 hours for basics, 1-2 weeks to master all techniques.</p>
<p><strong>Q: Should I read everything?</strong>
A: No. Focus on tutorials matching your needs, use reference as needed.</p>
<p><strong>Q: Can I skip sections?</strong>
A: Yes. Each section is independent except tutorials (follow in order).</p>
<p><strong>Q: Where's the API reference?</strong>
A: <a href="reference/fixtures-api.html">API Reference</a> - More coming soon!</p>
<p><strong>Q: Do I need prior testing experience?</strong>
A: No, but experience helps. Chicago TDD teaches a specific approach.</p>
<hr />
<h2 id="document-index"><a class="header" href="#document-index">Document Index</a></h2>
<h3 id="tutorials-learning-oriented"><a class="header" href="#tutorials-learning-oriented">Tutorials (Learning-Oriented)</a></h3>
<ul>
<li><a href="tutorials/getting-started.html">Quick Start</a> - 25 min, beginner</li>
<li><a href="tutorials/fixtures-tutorial.html">Fixtures Deep Dive</a> - 15 min, beginner</li>
<li><a href="tutorials/cli-app-tutorial.html">CLI Application</a> - 45 min, intermediate</li>
<li><a href="tutorials/web-service-tutorial.html">REST Web Service</a> - 50 min, intermediate</li>
</ul>
<h3 id="core-how-to-guides"><a class="header" href="#core-how-to-guides">Core (How-To Guides)</a></h3>
<ul>
<li><a href="core/fixtures.html">Fixtures</a> - How to use fixtures</li>
<li><a href="core/data-builders.html">Data Builders</a> - Build complex test data</li>
<li><a href="core/assertions.html">Assertions</a> - Make clear assertions</li>
<li><a href="core/error-paths.html">Error Paths</a> - Test failure cases</li>
</ul>
<h3 id="advanced-how-to-guides"><a class="header" href="#advanced-how-to-guides">Advanced (How-To Guides)</a></h3>
<ul>
<li><a href="advanced/property-testing.html">Property Testing</a> - Generate test cases</li>
<li><a href="advanced/mutation-testing.html">Mutation Testing</a> - Validate tests</li>
<li><a href="advanced/snapshot-testing.html">Snapshot Testing</a> - Compare golden files</li>
<li><a href="advanced/cli-testing.html">CLI Testing</a> - Test CLI apps</li>
<li><a href="advanced/concurrency-testing.html">Concurrency Testing</a> - Thread safety</li>
</ul>
<h3 id="guides-how-to--explanation"><a class="header" href="#guides-how-to--explanation">Guides (How-To + Explanation)</a></h3>
<ul>
<li><a href="guides/extra-mile.html">The Extra Mile Pattern</a> - Design decisions</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Production patterns</li>
<li><a href="guides/coverage-performance.html">Coverage &amp; Performance</a> - Metrics</li>
<li><a href="guides/observability.html">Observability</a> - Monitoring &amp; telemetry</li>
<li><a href="guides/otel.html">OTEL Instrumentation</a> - Add OpenTelemetry</li>
<li><a href="guides/weaver.html">Weaver Validation</a> - Validate telemetry</li>
<li><a href="guides/real-world.html">Real-World Applications</a> - Example projects</li>
</ul>
<h3 id="reference-lookup-oriented"><a class="header" href="#reference-lookup-oriented">Reference (Lookup-Oriented)</a></h3>
<ul>
<li><a href="reference/fixtures-api.html">TestFixture API</a> - Complete API docs</li>
</ul>
<hr />
<h2 id="quick-links-1"><a class="header" href="#quick-links-1">Quick Links</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Need</th><th>Link</th></tr></thead><tbody>
<tr><td>Quick start</td><td><a href="tutorials/getting-started.html">Getting Started</a></td></tr>
<tr><td>Code examples</td><td><a href="guides/real-world.html">Real-World Applications</a></td></tr>
<tr><td>Specific feature</td><td>Search this page or use feature table</td></tr>
<tr><td>API documentation</td><td><a href="reference/fixtures-api.html">API Reference</a></td></tr>
<tr><td>Best practices</td><td><a href="guides/best-practices.html">Best Practices</a></td></tr>
<tr><td>Understanding concepts</td><td><a href="introduction.html">Introduction</a></td></tr>
</tbody></table>
</div>
<hr />
<p><strong>Tip</strong>: Bookmark this page and return when you need guidance on what to learn next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-25-minute-tutorial"><a class="header" href="#getting-started-25-minute-tutorial">Getting Started: 25-Minute Tutorial</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | Learn the basics of Chicago TDD in 25 minutes</p>
</blockquote>
<p>This tutorial teaches you everything you need to write your first test with Chicago TDD Tools. No prior knowledge required.</p>
<p><strong>Time</strong>: ~25 minutes
<strong>Level</strong>: Beginner
<strong>What you'll learn</strong>: Write a complete test from start to finish</p>
<hr />
<h2 id="part-1-your-first-test-5-minutes"><a class="header" href="#part-1-your-first-test-5-minutes">Part 1: Your First Test (5 minutes)</a></h2>
<h3 id="step-1-create-a-test-function"><a class="header" href="#step-1-create-a-test-function">Step 1: Create a test function</a></h3>
<p>Chicago TDD uses the <code>test!</code> macro for declaring tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(my_first_test, {
    // Test code goes here
});
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-add-test-logic-arrange-act-assert"><a class="header" href="#step-2-add-test-logic-arrange-act-assert">Step 2: Add test logic (Arrange-Act-Assert)</a></h3>
<p>Every test follows three steps:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_number_parsing, {
    // Arrange: Set up test data
    let input = "42";

    // Act: Execute the code being tested
    let result = input.parse::&lt;u32&gt;();

    // Assert: Verify the result
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});
<span class="boring">}</span></code></pre></pre>
<p><strong>That's it!</strong> You've written your first test. Let's break it down:</p>
<ul>
<li><strong>Arrange</strong> (<code>let input = "42"</code>) - Prepare test data</li>
<li><strong>Act</strong> (<code>let result = input.parse()</code>) - Call the code you're testing</li>
<li><strong>Assert</strong> (<code>assert_ok!</code> and <code>assert_eq!</code>) - Verify it worked</li>
</ul>
<hr />
<h2 id="part-2-testing-success-and-failure-7-minutes"><a class="header" href="#part-2-testing-success-and-failure-7-minutes">Part 2: Testing Success and Failure (7 minutes)</a></h2>
<h3 id="test-the-happy-path"><a class="header" href="#test-the-happy-path">Test the Happy Path</a></h3>
<p>When code works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_valid_number, {
    let result = "100".parse::&lt;u32&gt;();

    // Verify it's Ok
    assert_ok!(&amp;result);

    // Verify the value is correct
    assert_eq!(result.unwrap(), 100);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="test-the-error-path"><a class="header" href="#test-the-error-path">Test the Error Path</a></h3>
<p>When code fails (most bugs hide here!):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_invalid_number, {
    let result = "not_a_number".parse::&lt;u32&gt;();

    // Verify it's an error
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="test-boundary-conditions"><a class="header" href="#test-boundary-conditions">Test Boundary Conditions</a></h3>
<p>Edge cases are important:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundaries, {
    // Zero (special case)
    assert_ok!(&amp;"0".parse::&lt;u32&gt;());

    // Maximum value
    assert_ok!(&amp;u32::MAX.to_string().parse::&lt;u32&gt;());

    // Negative (not valid for u32)
    assert_err!(&amp;"-1".parse::&lt;u32&gt;());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="key-assertion-helpers"><a class="header" href="#key-assertion-helpers">Key Assertion Helpers</a></h3>
<p>Chicago TDD provides clear assertion helpers:</p>
<div class="table-wrapper"><table><thead><tr><th>Helper</th><th>What it checks</th><th>Example</th></tr></thead><tbody>
<tr><td><code>assert_ok!(&amp;result)</code></td><td>Is this an <code>Ok</code>?</td><td><code>assert_ok!(&amp;my_result)</code></td></tr>
<tr><td><code>assert_err!(&amp;result)</code></td><td>Is this an <code>Err</code>?</td><td><code>assert_err!(&amp;my_result)</code></td></tr>
<tr><td><code>assert_eq!(a, b)</code></td><td>Are these equal?</td><td><code>assert_eq!(value, 42)</code></td></tr>
<tr><td><code>assert!(condition)</code></td><td>Is this true?</td><td><code>assert!(value &gt; 0)</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="part-3-using-fixtures-for-test-setup-6-minutes"><a class="header" href="#part-3-using-fixtures-for-test-setup-6-minutes">Part 3: Using Fixtures for Test Setup (6 minutes)</a></h2>
<p>For complex tests, use <code>TestFixture</code> to set up test data:</p>
<h3 id="creating-a-fixture"><a class="header" href="#creating-a-fixture">Creating a Fixture</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::fixture::*;

test!(test_with_fixture, {
    // Create a fixture (isolated test environment)
    let fixture = TestFixture::new()?;

    // Store test data
    fixture.set_metadata("user_id", "123");
    fixture.set_metadata("username", "alice");

    // Retrieve test data
    let user_id = fixture.get_metadata("user_id");
    assert_eq!(user_id, Some("123"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="capturing-test-state"><a class="header" href="#capturing-test-state">Capturing Test State</a></h3>
<p>You can save snapshots of your test data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_snapshots, {
    let fixture = TestFixture::new()?;

    // ... do some work ...

    // Capture the current state
    let state = HashMap::from([
        ("step".to_string(), "completed".to_string()),
        ("items_processed".to_string(), "5".to_string()),
    ]);
    fixture.capture_snapshot(state);

    // Access all snapshots
    let snapshots = fixture.snapshots();
    assert_eq!(snapshots.len(), 1);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="benefits-of-fixtures"><a class="header" href="#benefits-of-fixtures">Benefits of Fixtures</a></h3>
<p>‚úÖ Each test gets its own isolated environment
‚úÖ Automatic cleanup when test ends
‚úÖ State tracking with metadata and snapshots
‚úÖ Great for complex multi-step tests</p>
<hr />
<h2 id="part-4-building-test-data-5-minutes"><a class="header" href="#part-4-building-test-data-5-minutes">Part 4: Building Test Data (5 minutes)</a></h2>
<p>For complex test data, use <code>TestDataBuilder</code>:</p>
<h3 id="basic-data-building"><a class="header" href="#basic-data-building">Basic Data Building</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::builders::*;

test!(test_with_builder, {
    // Create a builder
    let builder = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com");

    // Build as JSON
    let json = builder.build_json()?;
    assert!(json["name"] == "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="building-maps"><a class="header" href="#building-maps">Building Maps</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_building_map, {
    let data = TestDataBuilder::new()
        .with_var("key1", "value1")
        .with_var("key2", "value2")
        .build();

    // Returns HashMap&lt;String, String&gt;
    assert_eq!(data.get("key1"), Some(&amp;"value1".to_string()));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="fluent-api-style"><a class="header" href="#fluent-api-style">Fluent API Style</a></h3>
<p>Builders use a fluent API - chain method calls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fluent_style, {
    let data = TestDataBuilder::new()
        .with_var("first", "hello")
        .with_var("second", "world")
        .with_var("third", "!")
        .build_json()?;

    // Clean, readable syntax
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="part-5-complete-example-2-minutes"><a class="header" href="#part-5-complete-example-2-minutes">Part 5: Complete Example (2 minutes)</a></h2>
<p>Putting it all together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::builders::*;
use chicago_tdd_tools::fixture::*;

test!(complete_example, {
    // Arrange: Create fixture and test data
    let fixture = TestFixture::new()?;

    let user_data = TestDataBuilder::new()
        .with_var("username", "alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act: Parse the email
    let email = user_data["email"].as_str().unwrap();
    let valid = email.contains("@");

    // Assert: Verify the result
    assert!(valid, "Email should contain @");

    // Store result in fixture
    fixture.set_metadata("test_passed", "true");
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-what-youve-learned"><a class="header" href="#summary-what-youve-learned">Summary: What You've Learned</a></h2>
<p>‚úÖ Basic test structure with <code>test!</code> macro
‚úÖ Arrange-Act-Assert pattern
‚úÖ Assertion helpers (<code>assert_ok!</code>, <code>assert_err!</code>, etc.)
‚úÖ Testing success, error, and boundary cases
‚úÖ Using fixtures for test isolation
‚úÖ Building complex test data</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p><strong>Ready to dive deeper?</strong></p>
<ol>
<li><strong><a href="tutorials/fixtures-tutorial.html">Fixtures Deep Dive</a></strong> (10 minutes) - Master test isolation</li>
<li><strong><a href="tutorials/../core/error-paths.html">Error Path Testing</a></strong> - Learn where bugs hide</li>
<li><strong><a href="tutorials/../guides/real-world.html">Real-World Examples</a></strong> - See complete projects</li>
</ol>
<p><strong>Or choose your path:</strong></p>
<ul>
<li><strong>I want to learn more patterns</strong> ‚Üí <a href="tutorials/../core/README.html">Core Testing Patterns</a></li>
<li><strong>I want advanced techniques</strong> ‚Üí <a href="tutorials/../advanced/README.html">Advanced Testing</a></li>
<li><strong>I want to test a web service</strong> ‚Üí <a href="tutorials/../guides/web-service.html">Web Service Tutorial</a></li>
<li><strong>I want to test a CLI tool</strong> ‚Üí <a href="tutorials/../guides/cli-application.html">CLI Application Tutorial</a></li>
</ul>
<hr />
<h2 id="quick-reference-card"><a class="header" href="#quick-reference-card">Quick Reference Card</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic test
test!(test_name, { /* code */ });

// Fixtures
let fixture = TestFixture::new()?;
fixture.set_metadata("key", "value");

// Data builders
TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()?

// Assertions
assert_ok!(&amp;result);          // Result is Ok
assert_err!(&amp;result);         // Result is Err
assert_eq!(actual, expected); // Values match
assert!(condition);           // Condition is true
<span class="boring">}</span></code></pre></pre>
<hr />
<p><strong>Congratulations!</strong> You can now write tests with Chicago TDD Tools. The rest is practice and learning specific patterns for your use case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixtures-deep-dive-15-minute-tutorial"><a class="header" href="#fixtures-deep-dive-15-minute-tutorial">Fixtures Deep Dive: 15-Minute Tutorial</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | Master test isolation with fixtures</p>
</blockquote>
<p>Fixtures are the foundation of isolated testing. This tutorial builds on the basics and shows you how to use fixtures for real-world scenarios.</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/getting-started.html">Getting Started</a>
<strong>Time</strong>: ~15 minutes
<strong>What you'll learn</strong>: Advanced fixture patterns and isolation techniques</p>
<hr />
<h2 id="what-are-fixtures"><a class="header" href="#what-are-fixtures">What Are Fixtures?</a></h2>
<p>A <strong>fixture</strong> is a isolated test environment. Each test gets its own copy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_isolation_example, {
    // Each test gets a completely separate fixture
    let fixture = TestFixture::new()?;

    // Changes here don't affect other tests
    fixture.set_metadata("value", "100");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="why-fixtures-matter"><a class="header" href="#why-fixtures-matter">Why Fixtures Matter</a></h3>
<p>‚úÖ <strong>Isolation</strong>: Tests don't interfere with each other
‚úÖ <strong>Cleanup</strong>: Resources are automatically cleaned up
‚úÖ <strong>Repeatability</strong>: Same test always behaves the same way
‚úÖ <strong>Parallel execution</strong>: Tests can run safely in parallel</p>
<hr />
<h2 id="storing-test-state"><a class="header" href="#storing-test-state">Storing Test State</a></h2>
<h3 id="simple-key-value-storage"><a class="header" href="#simple-key-value-storage">Simple Key-Value Storage</a></h3>
<p>Store and retrieve test data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_storing_state, {
    let fixture = TestFixture::new()?;

    // Store data
    fixture.set_metadata("user_id", "123");
    fixture.set_metadata("status", "active");

    // Retrieve data
    let user_id = fixture.get_metadata("user_id");
    assert_eq!(user_id, Some("123"));

    // Non-existent key returns None
    let missing = fixture.get_metadata("missing");
    assert_eq!(missing, None);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="practical-example-user-setup"><a class="header" href="#practical-example-user-setup">Practical Example: User Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_creation, {
    let fixture = TestFixture::new()?;

    // Setup: Create a user
    let user = create_user("alice", "alice@example.com")?;
    fixture.set_metadata("user_id", &amp;user.id.to_string());
    fixture.set_metadata("username", &amp;user.name);

    // Test: Can we retrieve the user?
    let stored_id = fixture.get_metadata("user_id").unwrap();
    let retrieved = get_user(stored_id.parse()?)?;
    assert_eq!(retrieved.name, "alice");
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="snapshots-capturing-state-over-time"><a class="header" href="#snapshots-capturing-state-over-time">Snapshots: Capturing State Over Time</a></h2>
<p>Snapshots record your test's state at different points:</p>
<h3 id="taking-a-snapshot"><a class="header" href="#taking-a-snapshot">Taking a Snapshot</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

test!(test_with_snapshots, {
    let fixture = TestFixture::new()?;

    // Perform some operations
    let data = vec![1, 2, 3];

    // Capture state as a snapshot
    let state = HashMap::from([
        ("step".to_string(), "initial".to_string()),
        ("count".to_string(), data.len().to_string()),
    ]);
    fixture.capture_snapshot(state);

    // ... more operations ...

    let state2 = HashMap::from([
        ("step".to_string(), "processed".to_string()),
        ("count".to_string(), "5".to_string()),
    ]);
    fixture.capture_snapshot(state2);

    // Access all snapshots
    let snapshots = fixture.snapshots();
    assert_eq!(snapshots.len(), 2);

    // Access latest snapshot
    let latest = fixture.latest_snapshot();
    assert_eq!(latest.get("step"), Some(&amp;"processed".to_string()));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="real-world-example-multi-step-workflow"><a class="header" href="#real-world-example-multi-step-workflow">Real-World Example: Multi-Step Workflow</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_order_workflow, {
    let fixture = TestFixture::new()?;

    // Step 1: Create order
    let order = create_order("alice", 100.0)?;
    fixture.capture_snapshot(HashMap::from([
        ("stage".to_string(), "created".to_string()),
        ("order_id".to_string(), order.id.to_string()),
        ("amount".to_string(), "100.0".to_string()),
    ]));

    // Step 2: Process payment
    process_payment(&amp;order)?;
    fixture.capture_snapshot(HashMap::from([
        ("stage".to_string(), "paid".to_string()),
        ("payment_status".to_string(), "completed".to_string()),
    ]));

    // Step 3: Ship order
    ship_order(&amp;order)?;
    fixture.capture_snapshot(HashMap::from([
        ("stage".to_string(), "shipped".to_string()),
        ("tracking".to_string(), "12345".to_string()),
    ]));

    // Verify all stages completed
    let snapshots = fixture.snapshots();
    assert_eq!(snapshots.len(), 3);
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="multiple-fixtures-in-one-test"><a class="header" href="#multiple-fixtures-in-one-test">Multiple Fixtures in One Test</a></h2>
<p>You can use multiple fixtures for complex scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_multiple_fixtures, {
    // Fixture 1: First test environment
    let fixture1 = TestFixture::new()?;
    fixture1.set_metadata("context", "database");

    // Fixture 2: Separate test environment
    let fixture2 = TestFixture::new()?;
    fixture2.set_metadata("context", "cache");

    // They don't interfere
    let ctx1 = fixture1.get_metadata("context");
    let ctx2 = fixture2.get_metadata("context");

    assert_eq!(ctx1, Some("database"));
    assert_eq!(ctx2, Some("cache"));
    assert_ne!(ctx1, ctx2);  // Different values
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="fixtures-with-error-handling"><a class="header" href="#fixtures-with-error-handling">Fixtures with Error Handling</a></h2>
<p>Fixtures handle errors gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_error_handling, {
    // Create fixture might fail
    let fixture = TestFixture::new()?;

    // Operations might fail
    if let Err(e) = risky_operation() {
        // Record the error
        fixture.set_metadata("error", &amp;e.to_string());

        // Assert error was expected
        let recorded = fixture.get_metadata("error");
        assert!(recorded.is_some());
    }

    // Fixture cleanup still happens automatically
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="fixture-initialization-pattern"><a class="header" href="#fixture-initialization-pattern">Fixture Initialization Pattern</a></h2>
<p>For repeated setup, create a helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_user_fixture() -&gt; Result&lt;(TestFixture, User), Box&lt;dyn std::error::Error&gt;&gt; {
    let fixture = TestFixture::new()?;

    let user = create_user("test_user", "test@example.com")?;
    fixture.set_metadata("user_id", &amp;user.id.to_string());
    fixture.set_metadata("username", &amp;user.name);

    Ok((fixture, user))
}

test!(test_using_setup, {
    let (fixture, user) = setup_user_fixture()?;

    // Test can now use pre-initialized fixture
    assert_eq!(user.name, "test_user");

    // ... rest of test ...
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="best-practices-for-fixtures"><a class="header" href="#best-practices-for-fixtures">Best Practices for Fixtures</a></h2>
<h3 id="-do"><a class="header" href="#-do">‚úÖ Do:</a></h3>
<ol>
<li>
<p><strong>Create one fixture per test</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test1, { let f = TestFixture::new()?; /* ... */ });
test!(test2, { let f = TestFixture::new()?; /* ... */ }); // Separate!
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use metadata for state tracking</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixture.set_metadata("step", "processing");
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Capture snapshots at key points</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixture.capture_snapshot(state);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use descriptive metadata keys</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixture.set_metadata("user_id", "123");  // Clear
// Not: fixture.set_metadata("id", "123");  // Vague
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="-dont"><a class="header" href="#-dont">‚ùå Don't:</a></h3>
<ol>
<li>
<p><strong>Share fixtures between tests</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - fixture is shared!
let shared_fixture = TestFixture::new();
test!(test1, { /* use shared_fixture */ });
test!(test2, { /* use shared_fixture */ });
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use global state</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - global state affects test isolation
static FIXTURE: Lazy&lt;TestFixture&gt; = Lazy::new(|| TestFixture::new().unwrap());
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Forget to handle errors</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - TestFixture::new() can fail
let fixture = TestFixture::new().unwrap();  // Better: ?
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<hr />
<h2 id="common-fixture-patterns"><a class="header" href="#common-fixture-patterns">Common Fixture Patterns</a></h2>
<h3 id="pattern-1-setup-teardown"><a class="header" href="#pattern-1-setup-teardown">Pattern 1: Setup-Teardown</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_setup_teardown, {
    let fixture = TestFixture::new()?;

    // Setup
    setup_database(&amp;fixture)?;
    fixture.set_metadata("db_ready", "true");

    // Test logic
    assert_eq!(fixture.get_metadata("db_ready"), Some("true"));

    // Teardown happens automatically when fixture is dropped
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-state-validation"><a class="header" href="#pattern-2-state-validation">Pattern 2: State Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_state_validation, {
    let fixture = TestFixture::new()?;

    // Perform operations
    let result = do_work()?;

    // Capture and validate state
    let state = HashMap::from([
        ("success".to_string(), "true".to_string()),
        ("items".to_string(), "5".to_string()),
    ]);
    fixture.capture_snapshot(state);

    // Verify final state
    let latest = fixture.latest_snapshot().unwrap();
    assert_eq!(latest.get("success"), Some(&amp;"true".to_string()));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-3-progressive-testing"><a class="header" href="#pattern-3-progressive-testing">Pattern 3: Progressive Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_progressive, {
    let fixture = TestFixture::new()?;

    // Phase 1
    let result1 = operation1()?;
    fixture.set_metadata("phase", "1");
    assert_ok!(&amp;result1);

    // Phase 2
    let result2 = operation2()?;
    fixture.set_metadata("phase", "2");
    assert_ok!(&amp;result2);

    // Phase 3
    let result3 = operation3()?;
    fixture.set_metadata("phase", "3");
    assert_ok!(&amp;result3);

    // Verify we completed all phases
    assert_eq!(fixture.get_metadata("phase"), Some("3"));
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Fixtures provide:</p>
<p>‚úÖ <strong>Isolation</strong> - Each test has its own environment
‚úÖ <strong>State tracking</strong> - Store and retrieve metadata
‚úÖ <strong>Snapshots</strong> - Capture state at different points
‚úÖ <strong>Cleanup</strong> - Automatic resource cleanup
‚úÖ <strong>Parallel safety</strong> - Tests can run in parallel</p>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p><strong>Ready for more?</strong></p>
<ol>
<li><strong><a href="tutorials/../core/error-paths.html">Error Path Testing</a></strong> - Test error cases thoroughly</li>
<li><strong><a href="tutorials/../core/fixtures.html">Advanced Fixtures</a></strong> - API reference and examples</li>
<li><strong><a href="tutorials/../guides/real-world.html">Real-World Applications</a></strong> - See fixtures in action</li>
</ol>
<hr />
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create fixture
let fixture = TestFixture::new()?;

// Store metadata
fixture.set_metadata("key", "value");

// Retrieve metadata
let value = fixture.get_metadata("key");  // Returns Option&lt;&amp;str&gt;

// Capture snapshot
let state = HashMap::from([("key".to_string(), "value".to_string())]);
fixture.capture_snapshot(state);

// Access snapshots
let all_snapshots = fixture.snapshots();
let latest = fixture.latest_snapshot();
<span class="boring">}</span></code></pre></pre>
<p><strong>Congratulations!</strong> You've mastered fixtures. You can now write tests with proper isolation and state tracking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-real-cli-application-complete-tutorial"><a class="header" href="#building-a-real-cli-application-complete-tutorial">Building a Real CLI Application: Complete Tutorial</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | Build a complete CLI application using Chicago TDD</p>
</blockquote>
<p>This tutorial walks you through building a real command-line todo application from scratch using Chicago TDD principles.</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/getting-started.html">Getting Started</a>, <a href="tutorials/fixtures-tutorial.html">Fixtures Deep Dive</a>
<strong>Time</strong>: ~45 minutes
<strong>What you'll build</strong>: A working <code>todo-cli</code> application with tests</p>
<hr />
<h2 id="project-overview"><a class="header" href="#project-overview">Project Overview</a></h2>
<p>You'll build a <strong>todo-cli</strong> app with these features:</p>
<pre><code class="language-bash"># Add a todo
$ todo-cli add "Buy groceries"

# List todos
$ todo-cli list

# Complete a todo
$ todo-cli done 1

# Delete a todo
$ todo-cli delete 1
</code></pre>
<p>This is a real, testable application.</p>
<hr />
<h2 id="step-1-project-setup-2-minutes"><a class="header" href="#step-1-project-setup-2-minutes">Step 1: Project Setup (2 minutes)</a></h2>
<h3 id="create-the-project"><a class="header" href="#create-the-project">Create the project</a></h3>
<pre><code class="language-bash">cargo new todo-cli
cd todo-cli
</code></pre>
<h3 id="add-dependencies"><a class="header" href="#add-dependencies">Add dependencies</a></h3>
<p>Edit <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "todo-cli"
version = "0.1.0"
edition = "2021"

[dependencies]
# (no dependencies for basic version)

[dev-dependencies]
chicago-tdd-tools = { version = "1.1", features = ["testing-extras"] }
</code></pre>
<h3 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h3>
<pre><code>todo-cli/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs           # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ add.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ list.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ done.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ delete.rs
‚îÇ   ‚îî‚îÄ‚îÄ store.rs          # Todo storage
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ cli_tests.rs
    ‚îî‚îÄ‚îÄ commands_tests.rs
</code></pre>
<hr />
<h2 id="step-2-core-data-structures-5-minutes"><a class="header" href="#step-2-core-data-structures-5-minutes">Step 2: Core Data Structures (5 minutes)</a></h2>
<h3 id="define-a-todo-struct"><a class="header" href="#define-a-todo-struct">Define a Todo struct</a></h3>
<p>Create <code>src/store.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, PartialEq)]
pub struct Todo {
    pub id: u32,
    pub title: String,
    pub completed: bool,
}

#[derive(Clone, Debug)]
pub struct TodoStore {
    todos: Vec&lt;Todo&gt;,
    next_id: u32,
}

impl TodoStore {
    pub fn new() -&gt; Self {
        TodoStore {
            todos: Vec::new(),
            next_id: 1,
        }
    }

    pub fn add(&amp;mut self, title: &amp;str) -&gt; u32 {
        let id = self.next_id;
        self.todos.push(Todo {
            id,
            title: title.to_string(),
            completed: false,
        });
        self.next_id += 1;
        id
    }

    pub fn list(&amp;self) -&gt; Vec&lt;&amp;Todo&gt; {
        self.todos.iter().collect()
    }

    pub fn mark_done(&amp;mut self, id: u32) -&gt; bool {
        if let Some(todo) = self.todos.iter_mut().find(|t| t.id == id) {
            todo.completed = true;
            true
        } else {
            false
        }
    }

    pub fn delete(&amp;mut self, id: u32) -&gt; bool {
        let original_len = self.todos.len();
        self.todos.retain(|t| t.id != id);
        self.todos.len() &lt; original_len
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-3-test-the-core-logic-8-minutes"><a class="header" href="#step-3-test-the-core-logic-8-minutes">Step 3: Test the Core Logic (8 minutes)</a></h2>
<p>Create <code>tests/commands_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use todo_cli::store::{Todo, TodoStore};

test!(test_add_todo, {
    let mut store = TodoStore::new();

    let id = store.add("Buy groceries");

    assert_eq!(id, 1);
    let todos = store.list();
    assert_eq!(todos.len(), 1);
    assert_eq!(todos[0].title, "Buy groceries");
    assert!(!todos[0].completed);
});

test!(test_add_multiple, {
    let mut store = TodoStore::new();

    let id1 = store.add("Task 1");
    let id2 = store.add("Task 2");
    let id3 = store.add("Task 3");

    assert_eq!(id1, 1);
    assert_eq!(id2, 2);
    assert_eq!(id3, 3);

    assert_eq!(store.list().len(), 3);
});

test!(test_mark_done, {
    let mut store = TodoStore::new();
    let id = store.add("Task");

    let result = store.mark_done(id);
    assert!(result);

    let todos = store.list();
    assert!(todos[0].completed);
});

test!(test_mark_nonexistent_as_done, {
    let mut store = TodoStore::new();

    let result = store.mark_done(999);

    assert!(!result);
});

test!(test_delete_todo, {
    let mut store = TodoStore::new();
    store.add("Task 1");
    store.add("Task 2");

    let result = store.delete(1);

    assert!(result);
    assert_eq!(store.list().len(), 1);
});

test!(test_delete_nonexistent, {
    let mut store = TodoStore::new();

    let result = store.delete(999);

    assert!(!result);
});

test!(test_empty_store, {
    let store = TodoStore::new();

    assert_eq!(store.list().len(), 0);
});
<span class="boring">}</span></code></pre></pre>
<p>Run tests: <code>cargo test</code></p>
<hr />
<h2 id="step-4-cli-commands-10-minutes"><a class="header" href="#step-4-cli-commands-10-minutes">Step 4: CLI Commands (10 minutes)</a></h2>
<p>Create <code>src/commands/add.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::store::TodoStore;

pub fn execute(store: &amp;mut TodoStore, args: &amp;[String]) -&gt; Result&lt;String, String&gt; {
    if args.is_empty() {
        return Err("Usage: add &lt;title&gt;".to_string());
    }

    let title = args.join(" ");
    let id = store.add(&amp;title);

    Ok(format!("Added todo #{}: {}", id, title))
}

#[cfg(test)]
mod tests {
    use super::*;
    use chicago_tdd_tools::prelude::*;

    test!(test_add_command, {
        let mut store = TodoStore::new();
        let args = vec!["Buy milk".to_string()];

        let result = execute(&amp;mut store, &amp;args);

        assert_ok!(&amp;result);
        assert!(result.unwrap().contains("Buy milk"));
        assert_eq!(store.list().len(), 1);
    });

    test!(test_add_with_spaces, {
        let mut store = TodoStore::new();
        let args = vec!["Buy".to_string(), "milk".to_string(), "and".to_string(), "eggs".to_string()];

        let result = execute(&amp;mut store, &amp;args);

        assert_ok!(&amp;result);
        let msg = result.unwrap();
        assert!(msg.contains("Buy milk and eggs"));
    });

    test!(test_add_no_args, {
        let mut store = TodoStore::new();
        let args = vec![];

        let result = execute(&amp;mut store, &amp;args);

        assert_err!(&amp;result);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>Create <code>src/commands/list.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::store::TodoStore;

pub fn execute(store: &amp;TodoStore) -&gt; String {
    let todos = store.list();

    if todos.is_empty() {
        return "No todos".to_string();
    }

    let mut output = String::new();
    for todo in todos {
        let status = if todo.completed { "‚úì" } else { " " };
        output.push_str(&amp;format!("[{}] #{}: {}\n", status, todo.id, todo.title));
    }

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use chicago_tdd_tools::prelude::*;

    test!(test_list_empty, {
        let store = TodoStore::new();

        let output = execute(&amp;store);

        assert_eq!(output, "No todos");
    });

    test!(test_list_with_items, {
        let mut store = TodoStore::new();
        store.add("Task 1");
        store.add("Task 2");

        let output = execute(&amp;store);

        assert!(output.contains("Task 1"));
        assert!(output.contains("Task 2"));
    });

    test!(test_list_shows_completion, {
        let mut store = TodoStore::new();
        let id = store.add("Task");
        store.mark_done(id);

        let output = execute(&amp;store);

        assert!(output.contains("‚úì"));
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-5-main-entry-point-5-minutes"><a class="header" href="#step-5-main-entry-point-5-minutes">Step 5: Main Entry Point (5 minutes)</a></h2>
<p>Create <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::env;
use std::io::{self, BufRead};

mod commands;
mod store;

use commands::{add, list, done, delete};
use store::TodoStore;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut store = TodoStore::new();

    let stdin = io::stdin();
    let reader = stdin.lock();

    for line in reader.lines() {
        let line = line?;
        let parts: Vec&lt;&amp;str&gt; = line.trim().split_whitespace().collect();

        if parts.is_empty() {
            continue;
        }

        let command = parts[0];
        let args: Vec&lt;String&gt; = parts[1..].iter().map(|s| s.to_string()).collect();

        let result = match command {
            "add" =&gt; add::execute(&amp;mut store, &amp;args),
            "list" =&gt; Ok(list::execute(&amp;store)),
            "done" =&gt; done::execute(&amp;mut store, &amp;args),
            "delete" =&gt; delete::execute(&amp;mut store, &amp;args),
            _ =&gt; Err(format!("Unknown command: {}", command)),
        };

        match result {
            Ok(msg) =&gt; println!("{}", msg),
            Err(e) =&gt; eprintln!("Error: {}", e),
        }
    }

    Ok(())
}</code></pre></pre>
<hr />
<h2 id="step-6-integration-tests-10-minutes"><a class="header" href="#step-6-integration-tests-10-minutes">Step 6: Integration Tests (10 minutes)</a></h2>
<p>Create <code>tests/cli_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use todo_cli::store::TodoStore;

test!(complete_workflow, {
    let mut store = TodoStore::new();

    // Add some todos
    store.add("Buy groceries");
    store.add("Pay bills");
    store.add("Call mom");

    let todos = store.list();
    assert_eq!(todos.len(), 3);

    // Mark one as done
    store.mark_done(2);

    // Delete one
    store.delete(3);

    let final_todos = store.list();
    assert_eq!(final_todos.len(), 2);
    assert!(!final_todos[0].completed);
    assert!(final_todos[1].completed);
});

test!(id_increment, {
    let mut store = TodoStore::new();

    let id1 = store.add("First");
    let id2 = store.add("Second");
    let id3 = store.add("Third");

    assert_eq!(id1, 1);
    assert_eq!(id2, 2);
    assert_eq!(id3, 3);

    store.delete(id2);  // Delete middle one

    let id4 = store.add("Fourth");
    assert_eq!(id4, 4);  // ID still increments
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-7-testing-with-fixtures-5-minutes"><a class="header" href="#step-7-testing-with-fixtures-5-minutes">Step 7: Testing with Fixtures (5 minutes)</a></h2>
<p>Create <code>tests/fixture_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::fixture::*;
use todo_cli::store::TodoStore;
use std::collections::HashMap;

test!(fixture_based_workflow, {
    let fixture = TestFixture::new()?;
    let mut store = TodoStore::new();

    // Phase 1: Initial setup
    let id1 = store.add("Task 1");
    let id2 = store.add("Task 2");
    fixture.set_metadata("initial_count", "2");
    fixture.capture_snapshot(HashMap::from([
        ("phase".to_string(), "1".to_string()),
        ("todos".to_string(), "2".to_string()),
    ]));

    // Phase 2: Mark complete
    store.mark_done(id1);
    fixture.set_metadata("current_phase", "mark_done");
    fixture.capture_snapshot(HashMap::from([
        ("phase".to_string(), "2".to_string()),
        ("completed".to_string(), "1".to_string()),
    ]));

    // Phase 3: Delete
    store.delete(id2);
    fixture.set_metadata("current_phase", "delete");
    fixture.capture_snapshot(HashMap::from([
        ("phase".to_string(), "3".to_string()),
        ("remaining".to_string(), "1".to_string()),
    ]));

    // Verify
    assert_eq!(fixture.snapshots().len(), 3);
    assert_eq!(store.list().len(), 1);
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-8-running-everything-5-minutes"><a class="header" href="#step-8-running-everything-5-minutes">Step 8: Running Everything (5 minutes)</a></h2>
<pre><code class="language-bash"># Run all tests
cargo test

# Run unit tests only
cargo test --lib

# Run integration tests only
cargo test --test '*'

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_add_todo
</code></pre>
<p>Expected output:</p>
<pre><code>running X tests
...
test result: ok. X passed; 0 failed; 0 ignored; X measured
</code></pre>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>You've built a real CLI application with:</p>
<p>‚úÖ Core data structures with tests
‚úÖ Command modules with unit tests
‚úÖ Integration tests
‚úÖ Fixture-based tests
‚úÖ Main CLI entry point
‚úÖ Error handling
‚úÖ Real-world usage patterns</p>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p><strong>Enhance your application:</strong></p>
<ul>
<li>Add persistence (save todos to file)</li>
<li>Add priorities to todos</li>
<li>Add due dates</li>
<li>Add categories/tags</li>
<li>Build a web API version</li>
</ul>
<p><strong>Learn more:</strong></p>
<ul>
<li><a href="tutorials/../advanced/snapshot-testing.html">Snapshot Testing</a> - Test CLI output</li>
<li><a href="tutorials/../advanced/README.html">Advanced Techniques</a> - More sophisticated testing</li>
<li><a href="tutorials/../guides/best-practices.html">Best Practices</a> - Production patterns</li>
</ul>
<p><strong>Share your code:</strong></p>
<ul>
<li>Push to GitHub</li>
<li>Add CI/CD pipeline</li>
<li>Write documentation</li>
<li>Create GitHub issues for features</li>
</ul>
<hr />
<p><strong>Congratulations!</strong> You've built and tested a real CLI application using Chicago TDD. You're now ready to build production applications!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-rest-web-service-complete-tutorial"><a class="header" href="#building-a-rest-web-service-complete-tutorial">Building a REST Web Service: Complete Tutorial</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | Build a production-ready REST API with Chicago TDD</p>
</blockquote>
<p>This tutorial guides you through building a real REST web service with comprehensive tests, using Rust and common web frameworks.</p>
<p><strong>Prerequisites</strong>: <a href="tutorials/getting-started.html">Getting Started</a>, <a href="tutorials/cli-app-tutorial.html">CLI Application Tutorial</a>
<strong>Time</strong>: ~50 minutes
<strong>What you'll build</strong>: A working <code>user-api</code> with CRUD operations</p>
<hr />
<h2 id="project-overview-1"><a class="header" href="#project-overview-1">Project Overview</a></h2>
<p>You'll build a <strong>user-api</strong> REST service:</p>
<pre><code class="language-bash"># Get all users
GET /api/users
-&gt; [{"id": 1, "name": "Alice", "email": "alice@example.com"}, ...]

# Get specific user
GET /api/users/:id
-&gt; {"id": 1, "name": "Alice", "email": "alice@example.com"}

# Create user
POST /api/users
-&gt; {"id": 2, "name": "Bob", "email": "bob@example.com"}

# Update user
PUT /api/users/:id
-&gt; {"id": 1, "name": "Alice Updated", ...}

# Delete user
DELETE /api/users/:id
-&gt; {}
</code></pre>
<hr />
<h2 id="step-1-project-setup-3-minutes"><a class="header" href="#step-1-project-setup-3-minutes">Step 1: Project Setup (3 minutes)</a></h2>
<h3 id="create-project"><a class="header" href="#create-project">Create project</a></h3>
<pre><code class="language-bash">cargo new user-api
cd user-api
</code></pre>
<h3 id="update-cargotoml"><a class="header" href="#update-cargotoml">Update Cargo.toml</a></h3>
<pre><code class="language-toml">[package]
name = "user-api"
version = "0.1.0"
edition = "2021"

[dependencies]
# JSON support
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[dev-dependencies]
chicago-tdd-tools = { version = "1.1", features = ["testing-extras"] }
</code></pre>
<h3 id="project-structure-1"><a class="header" href="#project-structure-1">Project structure</a></h3>
<pre><code>user-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.rs
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.rs
‚îÇ   ‚îî‚îÄ‚îÄ store.rs
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ user_tests.rs
    ‚îî‚îÄ‚îÄ api_tests.rs
</code></pre>
<hr />
<h2 id="step-2-data-models-5-minutes"><a class="header" href="#step-2-data-models-5-minutes">Step 2: Data Models (5 minutes)</a></h2>
<p>Create <code>src/models/user.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct User {
    pub id: u32,
    pub name: String,
    pub email: String,
}

#[derive(Clone, Debug, Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(Clone, Debug, Deserialize)]
pub struct UpdateUserRequest {
    pub name: Option&lt;String&gt;,
    pub email: Option&lt;String&gt;,
}

impl User {
    pub fn new(id: u32, name: String, email: String) -&gt; Self {
        User { id, name, email }
    }

    pub fn validate(&amp;self) -&gt; Result&lt;(), String&gt; {
        if self.name.is_empty() {
            return Err("Name cannot be empty".to_string());
        }
        if !self.email.contains('@') {
            return Err("Invalid email format".to_string());
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-3-test-the-models-8-minutes"><a class="header" href="#step-3-test-the-models-8-minutes">Step 3: Test the Models (8 minutes)</a></h2>
<p>Create <code>tests/user_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use user_api::models::User;

test!(test_create_user, {
    let user = User::new(1, "Alice".to_string(), "alice@example.com".to_string());

    assert_eq!(user.id, 1);
    assert_eq!(user.name, "Alice");
    assert_eq!(user.email, "alice@example.com");
});

test!(test_user_validation_valid, {
    let user = User::new(1, "Alice".to_string(), "alice@example.com".to_string());

    let result = user.validate();

    assert_ok!(&amp;result);
});

test!(test_user_validation_empty_name, {
    let user = User::new(1, String::new(), "alice@example.com".to_string());

    let result = user.validate();

    assert_err!(&amp;result);
    if let Err(e) = result {
        assert!(e.contains("Name"));
    }
});

test!(test_user_validation_invalid_email, {
    let user = User::new(1, "Alice".to_string(), "not-an-email".to_string());

    let result = user.validate();

    assert_err!(&amp;result);
    if let Err(e) = result {
        assert!(e.contains("email"));
    }
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-4-user-repository-8-minutes"><a class="header" href="#step-4-user-repository-8-minutes">Step 4: User Repository (8 minutes)</a></h2>
<p>Create <code>src/store.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::models::{User, CreateUserRequest, UpdateUserRequest};
use std::collections::HashMap;

pub struct UserStore {
    users: HashMap&lt;u32, User&gt;,
    next_id: u32,
}

impl UserStore {
    pub fn new() -&gt; Self {
        UserStore {
            users: HashMap::new(),
            next_id: 1,
        }
    }

    pub fn create(&amp;mut self, req: CreateUserRequest) -&gt; Result&lt;User, String&gt; {
        let user = User::new(self.next_id, req.name, req.email);
        user.validate()?;

        self.users.insert(user.id, user.clone());
        self.next_id += 1;

        Ok(user)
    }

    pub fn get(&amp;self, id: u32) -&gt; Option&lt;User&gt; {
        self.users.get(&amp;id).cloned()
    }

    pub fn list(&amp;self) -&gt; Vec&lt;User&gt; {
        let mut users: Vec&lt;_&gt; = self.users.values().cloned().collect();
        users.sort_by_key(|u| u.id);
        users
    }

    pub fn update(&amp;mut self, id: u32, req: UpdateUserRequest) -&gt; Result&lt;User, String&gt; {
        let user = self.users.get_mut(&amp;id)
            .ok_or("User not found".to_string())?;

        if let Some(name) = req.name {
            user.name = name;
        }
        if let Some(email) = req.email {
            user.email = email;
        }

        user.validate()?;
        Ok(user.clone())
    }

    pub fn delete(&amp;mut self, id: u32) -&gt; bool {
        self.users.remove(&amp;id).is_some()
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-5-repository-tests-10-minutes"><a class="header" href="#step-5-repository-tests-10-minutes">Step 5: Repository Tests (10 minutes)</a></h2>
<p>Create <code>tests/api_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use user_api::models::{User, CreateUserRequest, UpdateUserRequest};
use user_api::store::UserStore;

test!(test_create_user_success, {
    let mut store = UserStore::new();
    let req = CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };

    let result = store.create(req);

    assert_ok!(&amp;result);
    let user = result.unwrap();
    assert_eq!(user.name, "Alice");
});

test!(test_create_user_invalid_email, {
    let mut store = UserStore::new();
    let req = CreateUserRequest {
        name: "Alice".to_string(),
        email: "invalid".to_string(),
    };

    let result = store.create(req);

    assert_err!(&amp;result);
});

test!(test_get_user, {
    let mut store = UserStore::new();
    let req = CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };
    let created = store.create(req).unwrap();

    let retrieved = store.get(created.id);

    assert_eq!(retrieved, Some(created));
});

test!(test_get_nonexistent_user, {
    let store = UserStore::new();

    let result = store.get(999);

    assert_eq!(result, None);
});

test!(test_list_users, {
    let mut store = UserStore::new();

    store.create(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    }).ok();

    store.create(CreateUserRequest {
        name: "Bob".to_string(),
        email: "bob@example.com".to_string(),
    }).ok();

    let users = store.list();

    assert_eq!(users.len(), 2);
    assert_eq!(users[0].name, "Alice");
    assert_eq!(users[1].name, "Bob");
});

test!(test_update_user, {
    let mut store = UserStore::new();
    store.create(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    }).ok();

    let result = store.update(1, UpdateUserRequest {
        name: Some("Alice Updated".to_string()),
        email: None,
    });

    assert_ok!(&amp;result);
    let updated = result.unwrap();
    assert_eq!(updated.name, "Alice Updated");
});

test!(test_update_nonexistent_user, {
    let mut store = UserStore::new();

    let result = store.update(999, UpdateUserRequest {
        name: Some("Bob".to_string()),
        email: None,
    });

    assert_err!(&amp;result);
});

test!(test_delete_user, {
    let mut store = UserStore::new();
    store.create(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    }).ok();

    let result = store.delete(1);

    assert!(result);
    assert_eq!(store.list().len(), 0);
});

test!(test_delete_nonexistent_user, {
    let mut store = UserStore::new();

    let result = store.delete(999);

    assert!(!result);
});

test!(complete_api_workflow, {
    let mut store = UserStore::new();

    // Create users
    let alice = store.create(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    }).unwrap();

    store.create(CreateUserRequest {
        name: "Bob".to_string(),
        email: "bob@example.com".to_string(),
    }).ok();

    // Verify list
    assert_eq!(store.list().len(), 2);

    // Update Alice
    store.update(alice.id, UpdateUserRequest {
        name: Some("Alice Wonder".to_string()),
        email: None,
    }).ok();

    // Verify update
    let updated = store.get(alice.id).unwrap();
    assert_eq!(updated.name, "Alice Wonder");

    // Delete Bob
    store.delete(2);

    // Verify deletion
    assert_eq!(store.list().len(), 1);
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-6-handlers-8-minutes"><a class="header" href="#step-6-handlers-8-minutes">Step 6: Handlers (8 minutes)</a></h2>
<p>Create <code>src/handlers/users.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::models::CreateUserRequest;
use crate::store::UserStore;
use serde_json::json;

pub fn get_users(store: &amp;UserStore) -&gt; String {
    let users = store.list();
    serde_json::to_string(&amp;users).unwrap_or_else(|_| "[]".to_string())
}

pub fn get_user(store: &amp;UserStore, id: u32) -&gt; Result&lt;String, String&gt; {
    let user = store.get(id).ok_or("User not found".to_string())?;
    serde_json::to_string(&amp;user).map_err(|e| e.to_string())
}

pub fn create_user(store: &amp;mut UserStore, body: &amp;str) -&gt; Result&lt;String, String&gt; {
    let req: CreateUserRequest = serde_json::from_str(body)
        .map_err(|e| format!("Invalid JSON: {}", e))?;

    let user = store.create(req)?;
    serde_json::to_string(&amp;user).map_err(|e| e.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use chicago_tdd_tools::prelude::*;

    test!(test_get_users_empty, {
        let store = UserStore::new();

        let result = get_users(&amp;store);

        assert_eq!(result, "[]");
    });

    test!(test_create_user_from_json, {
        let mut store = UserStore::new();
        let json = r#"{"name":"Alice","email":"alice@example.com"}"#;

        let result = create_user(&amp;mut store, json);

        assert_ok!(&amp;result);
        let response = result.unwrap();
        assert!(response.contains("Alice"));
    });

    test!(test_create_user_invalid_json, {
        let mut store = UserStore::new();
        let json = "invalid json";

        let result = create_user(&amp;mut store, json);

        assert_err!(&amp;result);
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="step-7-main-application-5-minutes"><a class="header" href="#step-7-main-application-5-minutes">Step 7: Main Application (5 minutes)</a></h2>
<p>Create <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">mod models;
mod handlers;
mod store;

use models::{User, CreateUserRequest};
use store::UserStore;

fn main() {
    let mut store = UserStore::new();

    // Sample data
    store.create(CreateUserRequest {
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    }).ok();

    store.create(CreateUserRequest {
        name: "Bob".to_string(),
        email: "bob@example.com".to_string(),
    }).ok();

    // List users
    for user in store.list() {
        println!("User #{}: {} ({})", user.id, user.name, user.email);
    }
}</code></pre></pre>
<hr />
<h2 id="step-8-running-tests-5-minutes"><a class="header" href="#step-8-running-tests-5-minutes">Step 8: Running Tests (5 minutes)</a></h2>
<pre><code class="language-bash"># Run all tests
cargo test

# Run with output
cargo test -- --nocapture

# Run specific test
cargo test test_create_user_success
</code></pre>
<p>Expected output:</p>
<pre><code>running 11 tests
...
test result: ok. 11 passed; 0 failed
</code></pre>
<hr />
<h2 id="extending-the-api"><a class="header" href="#extending-the-api">Extending the API</a></h2>
<h3 id="add-error-responses"><a class="header" href="#add-error-responses">Add error responses</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize)]
pub struct ErrorResponse {
    pub error: String,
}

pub fn format_error(message: String) -&gt; String {
    serde_json::to_string(&amp;ErrorResponse { error: message })
        .unwrap_or_else(|_| r#"{"error":"Unknown error"}"#.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-pagination"><a class="header" href="#add-pagination">Add pagination</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn list_users_paginated(
    store: &amp;UserStore,
    page: u32,
    limit: u32,
) -&gt; (Vec&lt;User&gt;, u32) {
    let all = store.list();
    let total = all.len() as u32;
    let start = (page - 1) * limit;
    let end = std::cmp::min(start + limit, total);

    (all[start as usize..end as usize].to_vec(), total)
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p><strong>Enhance your API:</strong></p>
<ul>
<li>Add authentication</li>
<li>Add validation</li>
<li>Add pagination</li>
<li>Add filtering/searching</li>
<li>Add real database (PostgreSQL/SQLite)</li>
</ul>
<p><strong>Testing enhancements:</strong></p>
<ul>
<li><a href="tutorials/../guides/integration-docker.html">Integration Testing with Docker</a> - Test with real database</li>
<li><a href="tutorials/../advanced/snapshot-testing.html">Snapshot Testing</a> - Test API responses</li>
<li><a href="tutorials/../advanced/property-testing.html">Property Testing</a> - Fuzz test API handlers</li>
</ul>
<p><strong>Deployment:</strong></p>
<ul>
<li>Build Docker image</li>
<li>Deploy to cloud (AWS, Heroku, etc.)</li>
<li>Set up CI/CD pipeline</li>
<li>Monitor with observability tools</li>
</ul>
<hr />
<p><strong>Congratulations!</strong> You've built a production-ready REST API with comprehensive tests. You're ready to deploy real services!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testfixture-api-reference"><a class="header" href="#testfixture-api-reference">TestFixture API Reference</a></h1>
<blockquote>
<p>üìö <strong>REFERENCE</strong> | Complete API documentation for test fixtures</p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p><code>TestFixture</code> provides isolated test environments with metadata storage and state snapshots.</p>
<p><strong>Module</strong>: <code>chicago_tdd_tools::fixture</code>
<strong>Stability</strong>: Stable
<strong>Feature flag</strong>: Core (always available)</p>
<hr />
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<h3 id="testfixturenew---resulttestfixture-fixtureerror"><a class="header" href="#testfixturenew---resulttestfixture-fixtureerror"><code>TestFixture::new() -&gt; Result&lt;TestFixture, FixtureError&gt;</code></a></h3>
<p>Creates a new isolated test fixture.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Ok(TestFixture)</code> - New fixture instance</li>
<li><code>Err(FixtureError)</code> - Fixture creation failed</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fixture = TestFixture::new()?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Error cases:</strong></p>
<ul>
<li>IO errors during fixture initialization</li>
<li>Permission errors</li>
<li>System resource unavailability</li>
</ul>
<hr />
<h2 id="metadata-methods"><a class="header" href="#metadata-methods">Metadata Methods</a></h2>
<h3 id="set_metadatakey-impl-asrefstr-value-impl-asrefstr---"><a class="header" href="#set_metadatakey-impl-asrefstr-value-impl-asrefstr---"><code>set_metadata(key: impl AsRef&lt;str&gt;, value: impl AsRef&lt;str&gt;) -&gt; ()</code></a></h3>
<p>Stores a key-value pair in fixture metadata.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>key: impl AsRef&lt;str&gt;</code> - Metadata key (e.g., "user_id")</li>
<li><code>value: impl AsRef&lt;str&gt;</code> - Metadata value (e.g., "123")</li>
</ul>
<p><strong>Returns:</strong> Unit (always succeeds)</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixture.set_metadata("user_id", "123");
fixture.set_metadata("status", "active");
<span class="boring">}</span></code></pre></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>Overwrites existing key if present</li>
<li>Keys and values are strings</li>
<li>No size limits on metadata</li>
</ul>
<h3 id="get_metadatakey-str---optionstring"><a class="header" href="#get_metadatakey-str---optionstring"><code>get_metadata(key: &amp;str) -&gt; Option&lt;&amp;String&gt;</code></a></h3>
<p>Retrieves a value from fixture metadata.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>key: &amp;str</code> - Metadata key to look up</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Some(&amp;String)</code> - Value if key exists</li>
<li><code>None</code> - Key not found</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_id = fixture.get_metadata("user_id");
match user_id {
    Some(id) =&gt; println!("User: {}", id),
    None =&gt; println!("User ID not set"),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>Returns reference, not owned value</li>
<li>Reference is valid only while fixture exists</li>
<li>Returns None for non-existent keys</li>
</ul>
<hr />
<h2 id="snapshot-methods"><a class="header" href="#snapshot-methods">Snapshot Methods</a></h2>
<h3 id="capture_snapshotstate-hashmapstring-string---"><a class="header" href="#capture_snapshotstate-hashmapstring-string---"><code>capture_snapshot(state: HashMap&lt;String, String&gt;) -&gt; ()</code></a></h3>
<p>Captures the current test state as a snapshot.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>state: HashMap&lt;String, String&gt;</code> - State to capture</li>
</ul>
<p><strong>Returns:</strong> Unit (always succeeds)</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let state = HashMap::from([
    ("step".to_string(), "processing".to_string()),
    ("count".to_string(), "5".to_string()),
]);
fixture.capture_snapshot(state);
<span class="boring">}</span></code></pre></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>Creates immutable snapshot of provided state</li>
<li>State is copied, original HashMap can be modified</li>
<li>Snapshots are stored in order</li>
</ul>
<h3 id="snapshots---hashmapstring-string"><a class="header" href="#snapshots---hashmapstring-string"><code>snapshots() -&gt; &amp;[HashMap&lt;String, String&gt;]</code></a></h3>
<p>Returns all captured snapshots.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>&amp;[HashMap&lt;String, String&gt;]</code> - Slice of all snapshots</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let all = fixture.snapshots();
println!("Total snapshots: {}", all.len());

for (i, snapshot) in all.iter().enumerate() {
    println!("Snapshot {}: {:?}", i, snapshot);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>Returns empty slice if no snapshots captured</li>
<li>Snapshots are in capture order (chronological)</li>
<li>Reference is valid only while fixture exists</li>
</ul>
<h3 id="latest_snapshot---optionhashmapstring-string"><a class="header" href="#latest_snapshot---optionhashmapstring-string"><code>latest_snapshot() -&gt; Option&lt;&amp;HashMap&lt;String, String&gt;&gt;</code></a></h3>
<p>Returns the most recently captured snapshot.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Some(&amp;HashMap)</code> - Last captured snapshot</li>
<li><code>None</code> - No snapshots captured yet</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(latest) = fixture.latest_snapshot() {
    if let Some(step) = latest.get("step") {
        println!("Current step: {}", step);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Notes:</strong></p>
<ul>
<li>Convenience method for accessing most recent state</li>
<li>Returns None if <code>snapshots().is_empty()</code></li>
<li>Equivalent to <code>snapshots().last()</code></li>
</ul>
<hr />
<h2 id="lifecycle"><a class="header" href="#lifecycle">Lifecycle</a></h2>
<h3 id="creation-and-cleanup"><a class="header" href="#creation-and-cleanup">Creation and Cleanup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(fixture_lifecycle, {
    // Creation: new() initializes resources
    let fixture = TestFixture::new()?;

    // Usage: store state and snapshots
    fixture.set_metadata("key", "value");

    // Cleanup: automatic when fixture is dropped
    // (at end of test scope)
}); // Fixture dropped here - cleanup happens
<span class="boring">}</span></code></pre></pre>
<h3 id="automatic-cleanup"><a class="header" href="#automatic-cleanup">Automatic Cleanup</a></h3>
<p>When <code>TestFixture</code> is dropped:</p>
<ol>
<li>All metadata is cleared</li>
<li>All snapshots are cleared</li>
<li>File handles/resources are released</li>
<li>Directory/files created by fixture are removed</li>
</ol>
<p><strong>Note:</strong> You don't need to manually call cleanup. It happens automatically.</p>
<hr />
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="pattern-setup-and-verify-state"><a class="header" href="#pattern-setup-and-verify-state">Pattern: Setup and Verify State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(verify_state_pattern, {
    let fixture = TestFixture::new()?;

    // Setup phase
    fixture.set_metadata("initialized", "false");
    assert_eq!(fixture.get_metadata("initialized"), Some("false"));

    // Initialization happens
    // ...

    // Verify state changed
    fixture.set_metadata("initialized", "true");
    assert_eq!(fixture.get_metadata("initialized"), Some("true"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-multi-phase-test"><a class="header" href="#pattern-multi-phase-test">Pattern: Multi-Phase Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(multi_phase_pattern, {
    let fixture = TestFixture::new()?;

    // Phase 1
    fixture.set_metadata("phase", "1");
    let result1 = do_phase_1()?;
    fixture.capture_snapshot(state_at_phase1());
    assert_ok!(&amp;result1);

    // Phase 2
    fixture.set_metadata("phase", "2");
    let result2 = do_phase_2()?;
    fixture.capture_snapshot(state_at_phase2());
    assert_ok!(&amp;result2);

    // Verify all phases completed
    assert_eq!(fixture.get_metadata("phase"), Some("2"));
    assert_eq!(fixture.snapshots().len(), 2);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-context-association"><a class="header" href="#pattern-context-association">Pattern: Context Association</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(context_pattern, {
    let fixture = TestFixture::new()?;

    // Associate test context
    fixture.set_metadata("test_name", "my_test");
    fixture.set_metadata("test_version", "1.0");
    fixture.set_metadata("test_category", "integration");

    // ... test code ...
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="handling-fixture-creation-errors"><a class="header" href="#handling-fixture-creation-errors">Handling Fixture Creation Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(error_handling, {
    match TestFixture::new() {
        Ok(fixture) =&gt; {
            // Use fixture
            fixture.set_metadata("key", "value");
        }
        Err(e) =&gt; {
            // Log error or skip test
            eprintln!("Failed to create fixture: {}", e);
            return;  // Skip this test
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="propagating-errors-with-"><a class="header" href="#propagating-errors-with-">Propagating Errors with <code>?</code></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(error_propagation, {
    let fixture = TestFixture::new()?;
    // If creation fails, entire test returns error
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Time</th><th>Notes</th></tr></thead><tbody>
<tr><td><code>new()</code></td><td>~1ms</td><td>I/O heavy, system dependent</td></tr>
<tr><td><code>set_metadata()</code></td><td>&lt;1Œºs</td><td>In-memory</td></tr>
<tr><td><code>get_metadata()</code></td><td>&lt;1Œºs</td><td>In-memory lookup</td></tr>
<tr><td><code>capture_snapshot()</code></td><td>&lt;1Œºs</td><td>Copy HashMap to internal storage</td></tr>
<tr><td><code>snapshots()</code></td><td>&lt;1Œºs</td><td>Returns slice reference</td></tr>
<tr><td><code>latest_snapshot()</code></td><td>&lt;1Œºs</td><td>Slice operation</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h2>
<ul>
<li><strong>Metadata</strong>: ~50 bytes per key-value pair (plus string data)</li>
<li><strong>Snapshots</strong>: ~100 bytes per snapshot (plus HashMap overhead)</li>
<li><strong>Total per test</strong>: Usually &lt;1MB unless storing large amounts of state</li>
</ul>
<hr />
<h2 id="limitations-and-constraints"><a class="header" href="#limitations-and-constraints">Limitations and Constraints</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Constraint</th><th>Limit</th><th>Workaround</th></tr></thead><tbody>
<tr><td>Metadata key length</td><td>Unlimited</td><td>Use short, memorable keys</td></tr>
<tr><td>Metadata value length</td><td>Unlimited</td><td>Avoid storing binary data</td></tr>
<tr><td>Number of snapshots</td><td>Unlimited</td><td>Limit snapshots to key points</td></tr>
<tr><td>Parallel tests</td><td>Fully safe</td><td>Tests run with separate fixtures</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="integration-with-other-tools"><a class="header" href="#integration-with-other-tools">Integration with Other Tools</a></h2>
<h3 id="with-testdatabuilder"><a class="header" href="#with-testdatabuilder">With TestDataBuilder</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(integration_builder, {
    let fixture = TestFixture::new()?;

    let data = TestDataBuilder::new()
        .with_var("key", "value")
        .build_json()?;

    fixture.set_metadata("data", &amp;data.to_string());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="with-async-tests"><a class="header" href="#with-async-tests">With Async Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn async_with_fixture() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let fixture = TestFixture::new()?;

    fixture.set_metadata("async", "true");

    // async operations

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="example-1-simple-setup"><a class="header" href="#example-1-simple-setup">Example 1: Simple Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(simple_setup, {
    let fixture = TestFixture::new()?;
    fixture.set_metadata("user", "alice");
    assert_eq!(fixture.get_metadata("user"), Some("alice"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-2-complex-state-tracking"><a class="header" href="#example-2-complex-state-tracking">Example 2: Complex State Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(complex_tracking, {
    let fixture = TestFixture::new()?;

    for i in 0..3 {
        fixture.set_metadata("iteration", &amp;i.to_string());

        let state = HashMap::from([
            ("step".to_string(), format!("step_{}", i)),
            ("count".to_string(), i.to_string()),
        ]);
        fixture.capture_snapshot(state);
    }

    assert_eq!(fixture.snapshots().len(), 3);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-3-error-recovery"><a class="header" href="#example-3-error-recovery">Example 3: Error Recovery</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(error_recovery, {
    let fixture = TestFixture::new()?;

    fixture.set_metadata("status", "starting");

    if let Err(e) = risky_operation() {
        fixture.set_metadata("status", "failed");
        fixture.set_metadata("error", &amp;e.to_string());

        // Can still verify error was recorded
        assert!(fixture.get_metadata("error").is_some());
    }
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="related-types"><a class="header" href="#related-types">Related Types</a></h2>
<ul>
<li><code>FixtureError</code> - Error type for fixture operations</li>
<li><code>HashMap&lt;String, String&gt;</code> - Type for snapshot state</li>
</ul>
<hr />
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="reference/../tutorials/getting-started.html">Getting Started</a> - Tutorial on basic fixtures</li>
<li><a href="reference/../tutorials/fixtures-tutorial.html">Fixtures Deep Dive</a> - Advanced patterns</li>
<li><a href="reference/../core/fixtures.html">Fixtures How-to</a> - Practical guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-testing-patterns"><a class="header" href="#core-testing-patterns">Core Testing Patterns</a></h1>
<p>Welcome to the core testing patterns section! Here you'll learn the everyday patterns you'll use in almost every test.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Core patterns include:</p>
<ol>
<li><strong>Fixtures</strong> - Isolated test state and setup</li>
<li><strong>Data Builders</strong> - Fluent API for constructing test data</li>
<li><strong>Assertions</strong> - Clear, readable verification of results</li>
<li><strong>Error Paths</strong> - Testing failure scenarios</li>
</ol>
<p>These patterns form the foundation of all testing in Chicago TDD Tools.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Here's a complete test using core patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_user_creation, {
    // Arrange: Set up with fixtures and builders
    let fixture = TestFixture::new()?;
    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act: Execute the code under test
    let result = create_user(&amp;user_data)?;

    // Assert: Verify with assertions
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().name, "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="test-isolation"><a class="header" href="#test-isolation">Test Isolation</a></h3>
<p>Each test must be independent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test1, {
    let fixture = TestFixture::new()?;  // Fresh fixture
    // test1 uses fixture1
});

test!(test2, {
    let fixture = TestFixture::new()?;  // Different fixture
    // test2 uses fixture2
    // Both tests can run in parallel with no interference
});
<span class="boring">}</span></code></pre></pre>
<h3 id="data-construction"><a class="header" href="#data-construction">Data Construction</a></h3>
<p>Build complex test data with fluent builders:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let order = TestDataBuilder::new()
    .with_var("order_id", "ORD-001")
    .with_order_data("ORD-001", "100.50")
    .build_json()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="clear-assertions"><a class="header" href="#clear-assertions">Clear Assertions</a></h3>
<p>Use assertion helpers for readability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_ok!(&amp;result);           // Checks is_ok()
assert_err!(&amp;result);          // Checks is_err()
assert_eq!(value, expected);   // Equality check
<span class="boring">}</span></code></pre></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="core/fixtures.html">Getting Started with Fixtures</a> - Fixture lifecycle and setup</li>
<li><a href="core/data-builders.html">Building Test Data</a> - Data builders and fluent API</li>
<li><a href="core/assertions.html">Assertions &amp; Verification</a> - Assertion helpers and patterns</li>
<li><a href="core/error-paths.html">Error Path Testing</a> - Testing failure scenarios</li>
</ul>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="pattern-arrange-act-assert"><a class="header" href="#pattern-arrange-act-assert">Pattern: Arrange-Act-Assert</a></h3>
<p>Every test follows this structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_example, {
    // Arrange: Set up test state
    let fixture = TestFixture::new()?;
    let data = TestDataBuilder::new()...build_json()?;

    // Act: Execute code under test
    let result = function_under_test(&amp;data)?;

    // Assert: Verify behavior
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().field, expected_value);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-error-path-testing"><a class="header" href="#pattern-error-path-testing">Pattern: Error Path Testing</a></h3>
<p>Always test both success and failure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_error_path, {
    // Success path
    let ok_result = parse_number("42");
    assert_ok!(&amp;ok_result);

    // Error path
    let err_result = parse_number("not_a_number");
    assert_err!(&amp;err_result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-boundary-conditions"><a class="header" href="#pattern-boundary-conditions">Pattern: Boundary Conditions</a></h3>
<p>Test edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundaries, {
    // Minimum value
    assert_ok!(&amp;function(0));

    // Maximum value
    assert_ok!(&amp;function(u32::MAX));

    // Off-by-one
    assert_ok!(&amp;function(1));
    assert_ok!(&amp;function(u32::MAX - 1));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-core-patterns"><a class="header" href="#when-to-use-core-patterns">When to Use Core Patterns</a></h2>
<p>Use core patterns for:</p>
<ul>
<li>‚úÖ Testing individual functions</li>
<li>‚úÖ Testing pure logic</li>
<li>‚úÖ Testing with simple setup</li>
<li>‚úÖ Most of your test suite (80%+)</li>
</ul>
<p>For complex scenarios, see:</p>
<ul>
<li><a href="core/../advanced/property-testing.html">Property-Based Testing</a> - Random test data</li>
<li><a href="core/../advanced/snapshot-testing.html">Snapshot Testing</a> - Golden files</li>
<li><a href="core/../advanced/cli-testing.html">CLI Testing</a> - Command-line interfaces</li>
</ul>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>üëâ <strong>Start with <a href="core/fixtures.html">Fixtures</a></strong></p>
<p>Then learn:</p>
<ol>
<li><a href="core/data-builders.html">Data Builders</a> - Construct test data</li>
<li><a href="core/assertions.html">Assertions</a> - Verify results</li>
<li><a href="core/error-paths.html">Error Paths</a> - Test failures</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-fixtures"><a class="header" href="#getting-started-with-fixtures">Getting Started with Fixtures</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Learn to use fixtures for test isolation</p>
</blockquote>
<p>Fixtures are isolated test environments that provide controlled setup and automatic cleanup.</p>
<h2 id="what-is-a-fixture"><a class="header" href="#what-is-a-fixture">What is a Fixture?</a></h2>
<p>A fixture is a test object that:</p>
<ul>
<li>Provides fresh, isolated state for each test</li>
<li>Handles setup automatically</li>
<li>Cleans up resources when the test ends</li>
<li>Prevents state leakage between tests</li>
</ul>
<h2 id="creating-a-fixture-1"><a class="header" href="#creating-a-fixture-1">Creating a Fixture</a></h2>
<h3 id="basic-fixture-creation"><a class="header" href="#basic-fixture-creation">Basic Fixture Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_with_fixture, {
    // Create a fresh fixture
    let fixture = TestFixture::new()?;

    // Fixtures provide isolation and utilities
    // Store metadata for the test
    fixture.set_metadata("test_id".to_string(), "123".to_string());

    // Retrieve metadata
    let test_id = fixture.get_metadata("test_id");
    assert_eq!(test_id, Some(&amp;"123".to_string()));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<p>Fixtures return <code>Result</code> - always handle the error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_error_handling, {
    // ‚úÖ Handle the Result properly
    match TestFixture::new() {
        Ok(fixture) =&gt; {
            // Use fixture
            fixture.set_metadata("key".to_string(), "value".to_string());
        }
        Err(e) =&gt; {
            alert_critical!("Fixture creation failed: {}", e);
            return Err(e.into());
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<p>Or use the <code>?</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_with_question_mark, {
    let fixture = TestFixture::new()?;  // Propagates error
    fixture.set_metadata("test_data".to_string(), "setup_complete".to_string());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="fixture-features"><a class="header" href="#fixture-features">Fixture Features</a></h2>
<p>The <code>TestFixture</code> provides utilities for tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_features, {
    let mut fixture = TestFixture::new()?;

    // Store and retrieve metadata
    fixture.set_metadata("user_id".to_string(), "42".to_string());
    assert_eq!(
        fixture.get_metadata("user_id"),
        Some(&amp;"42".to_string())
    );

    // Capture snapshots of test state
    let mut state = HashMap::new();
    state.insert("status".to_string(), "initialized".to_string());
    fixture.capture_snapshot(state);

    // Retrieve snapshots
    let snapshots = fixture.snapshots();
    assert!(!snapshots.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="quick-reference-testfixture-api"><a class="header" href="#quick-reference-testfixture-api">Quick Reference: TestFixture API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Parameters</th><th>Returns</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>new()</code></td><td>none</td><td><code>Result&lt;TestFixture, FixtureError&gt;</code></td><td>Create new isolated fixture</td></tr>
<tr><td><code>set_metadata()</code></td><td><code>key: String</code>, <code>value: String</code></td><td><code>()</code></td><td>Store test state</td></tr>
<tr><td><code>get_metadata()</code></td><td><code>key: &amp;str</code></td><td><code>Option&lt;&amp;String&gt;</code></td><td>Retrieve stored state</td></tr>
<tr><td><code>capture_snapshot()</code></td><td><code>state: HashMap&lt;String, String&gt;</code></td><td><code>()</code></td><td>Save test state snapshot</td></tr>
<tr><td><code>snapshots()</code></td><td>none</td><td><code>&amp;[HashMap&lt;String, String&gt;]</code></td><td>Get all snapshots</td></tr>
<tr><td><code>latest_snapshot()</code></td><td>none</td><td><code>Option&lt;&amp;HashMap&lt;...&gt;&gt;</code></td><td>Get most recent snapshot</td></tr>
</tbody></table>
</div>
<h2 id="fixture-lifecycle"><a class="header" href="#fixture-lifecycle">Fixture Lifecycle</a></h2>
<h3 id="setup-phase"><a class="header" href="#setup-phase">Setup Phase</a></h3>
<p>Setup happens when <code>TestFixture::new()</code> is called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_setup, {
    // This is the setup phase
    let fixture = TestFixture::new()?;
    // Fixture is fully initialized here
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cleanup-phase"><a class="header" href="#cleanup-phase">Cleanup Phase</a></h3>
<p>Cleanup happens automatically when the fixture is dropped (at the end of the test):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cleanup, {
    let fixture = TestFixture::new()?;
    // Use fixture

    // When this scope ends, fixture is dropped and cleaned up
    // No explicit cleanup needed!
});
<span class="boring">}</span></code></pre></pre>
<h2 id="test-isolation-1"><a class="header" href="#test-isolation-1">Test Isolation</a></h2>
<p>Each test gets a fresh fixture:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_isolation_1, {
    let fixture1 = TestFixture::new()?;
    fixture1.set_metadata("test".to_string(), "isolation_1".to_string());
    // Uses fixture1
});

test!(test_isolation_2, {
    let fixture2 = TestFixture::new()?;
    fixture2.set_metadata("test".to_string(), "isolation_2".to_string());
    // Uses fixture2
    // fixture1 and fixture2 are completely independent
});
<span class="boring">}</span></code></pre></pre>
<p>Both tests can run in parallel with no interference.</p>
<h2 id="advanced-multiple-fixtures"><a class="header" href="#advanced-multiple-fixtures">Advanced: Multiple Fixtures</a></h2>
<p>Create multiple fixtures in one test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_multiple_fixtures, {
    let fixture1 = TestFixture::new()?;
    let fixture2 = TestFixture::new()?;

    // Both fixtures exist independently
    fixture1.set_metadata("fixture".to_string(), "first".to_string());
    fixture2.set_metadata("fixture".to_string(), "second".to_string());

    assert_eq!(fixture1.get_metadata("fixture"), Some(&amp;"first".to_string()));
    assert_eq!(fixture2.get_metadata("fixture"), Some(&amp;"second".to_string()));

    // Both are cleaned up when the test ends
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example"><a class="header" href="#real-world-example">Real-World Example</a></h2>
<h3 id="scenario-testing-a-user-service"><a class="header" href="#scenario-testing-a-user-service">Scenario: Testing a User Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_service, {
    // Arrange: Set up fixture with data
    let mut fixture = TestFixture::new()?;
    fixture.set_metadata("user_id".to_string(), "123".to_string());

    // Act: Perform test operations
    // Use fixture metadata for test coordination
    let user_id = fixture.get_metadata("user_id");

    // Assert: Verify
    assert_eq!(user_id, Some(&amp;"123".to_string()));

    // Cleanup: Automatic! No explicit cleanup needed.
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="pattern-reusable-fixture-setup"><a class="header" href="#pattern-reusable-fixture-setup">Pattern: Reusable Fixture Setup</a></h3>
<p>Create a helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_user_fixture() -&gt; Result&lt;TestFixture, Box&lt;dyn std::error::Error&gt;&gt; {
    let fixture = TestFixture::new()?;
    // Additional setup here if needed
    Ok(fixture)
}

test!(test_with_helper, {
    let fixture = setup_user_fixture()?;
    // Use configured fixture
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-nested-fixtures"><a class="header" href="#pattern-nested-fixtures">Pattern: Nested Fixtures</a></h3>
<p>Fixtures can use other fixtures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_nested, {
    let outer = TestFixture::new()?;
    let inner = TestFixture::new()?;
    // Both are available
    // Inner is cleaned up first (LIFO order)
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="failed-to-create-fixture"><a class="header" href="#failed-to-create-fixture">"Failed to create fixture"</a></h3>
<p>This usually means an environment issue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_error, {
    match TestFixture::new() {
        Ok(fixture) =&gt; {
            // Successfully created
        }
        Err(e) =&gt; {
            // Check your environment configuration
            alert_critical!("Environment issue: {}", e);
            return Err(e.into());
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="tests-running-sequentially"><a class="header" href="#tests-running-sequentially">Tests Running Sequentially</a></h3>
<p>Chicago TDD Tools tests run in parallel by default. If you see sequential execution:</p>
<ol>
<li>Check for shared state (file I/O, network)</li>
<li>Ensure each test has its own fixture</li>
<li>Use <code>cargo test -- --test-threads=1</code> to force sequential (for debugging)</li>
</ol>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Create a fresh fixture in each test</li>
<li>Handle the <code>Result</code> with <code>?</code> or <code>match</code></li>
<li>Let fixtures clean up automatically</li>
<li>Use multiple fixtures if needed</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Share fixtures between tests</li>
<li>Manually clean up (let the fixture drop)</li>
<li>Rely on global state</li>
<li>Use <code>unwrap()</code> on fixture creation</li>
</ul>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>Learn how to use fixtures with data builders: <a href="core/data-builders.html">Building Test Data</a></p>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Fixture</strong></td><td>Isolated test state</td></tr>
<tr><td><strong>Setup</strong></td><td>Happens in <code>TestFixture::new()</code></td></tr>
<tr><td><strong>Cleanup</strong></td><td>Automatic on drop</td></tr>
<tr><td><strong>Isolation</strong></td><td>Each test gets fresh fixture</td></tr>
<tr><td><strong>Error Handling</strong></td><td>Use <code>?</code> operator or <code>match</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="building-test-data-with-data-builders"><a class="header" href="#building-test-data-with-data-builders">Building Test Data with Data Builders</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Learn to construct test data efficiently</p>
</blockquote>
<p>Data builders provide a fluent API for constructing complex test data structures.</p>
<h2 id="why-data-builders"><a class="header" href="#why-data-builders">Why Data Builders?</a></h2>
<p>Raw test data is hard to read and maintain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Hard to understand what this represents
let mut data = HashMap::new();
data.insert("key1".to_string(), "value1".to_string());
data.insert("key2".to_string(), "value2".to_string());
data.insert("order_id".to_string(), "ORD-001".to_string());
<span class="boring">}</span></code></pre></pre>
<p>Data builders are readable and maintainable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Clear intent - building an order
let data = TestDataBuilder::new()
    .with_var("key1", "value1")
    .with_var("key2", "value2")
    .with_order_data("ORD-001", "100.00")
    .build_json()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-data-builder-usage"><a class="header" href="#basic-data-builder-usage">Basic Data Builder Usage</a></h2>
<h3 id="creating-simple-data"><a class="header" href="#creating-simple-data">Creating Simple Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_data_builder, {
    // Arrange: Build test data
    let builder = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com");

    // Build as JSON
    let json_data = builder.build_json()?;
    assert!(json_data.is_object());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="building-json-data"><a class="header" href="#building-json-data">Building JSON Data</a></h3>
<p>The primary format is JSON:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()?;  // Returns serde_json::Value
<span class="boring">}</span></code></pre></pre>
<p>All test data is built as JSON, which is flexible and works with most applications.</p>
<h2 id="fluent-builder-pattern"><a class="header" href="#fluent-builder-pattern">Fluent Builder Pattern</a></h2>
<p>Builders use method chaining for readability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("user_id", "123")
    .with_var("name", "Bob")
    .with_var("email", "bob@example.com")
    .with_var("status", "active")
    .with_order_data("ORD-001", "250.99")
    .build_json()?;
<span class="boring">}</span></code></pre></pre>
<p>Each method returns <code>Self</code>, allowing unlimited chaining.</p>
<h2 id="quick-reference-testdatabuilder-api"><a class="header" href="#quick-reference-testdatabuilder-api">Quick Reference: TestDataBuilder API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Parameters</th><th>Returns</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>new()</code></td><td>none</td><td><code>TestDataBuilder</code></td><td>Create new builder</td></tr>
<tr><td><code>with_var()</code></td><td><code>key: &amp;str</code>, <code>value: &amp;str</code></td><td><code>Self</code></td><td>Add string variable</td></tr>
<tr><td><code>with_order_data()</code></td><td><code>id: &amp;str</code>, <code>amount: &amp;str</code></td><td><code>Self</code></td><td>Add order info</td></tr>
<tr><td><code>build_json()</code></td><td>none</td><td><code>Result&lt;Value, Error&gt;</code></td><td>Build as JSON</td></tr>
<tr><td><code>build()</code></td><td>none</td><td><code>HashMap&lt;String, String&gt;</code></td><td>Build as HashMap</td></tr>
<tr><td><code>build_with_otel()</code></td><td><code>span_name: &amp;str</code></td><td><code>(HashMap, Span)</code></td><td>Build with OTEL span</td></tr>
</tbody></table>
</div>
<h2 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h2>
<h3 id="basic-variables"><a class="header" href="#basic-variables">Basic Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_var(key, value)           // Add a string variable
<span class="boring">}</span></code></pre></pre>
<h3 id="complex-data"><a class="header" href="#complex-data">Complex Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_order_data(id, amount)    // Add order information
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h3>
<p>Always handle the Result from <code>build_*()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()
{
    Ok(data) =&gt; {
        // Use data
        assert!(data.is_object());
    }
    Err(e) =&gt; {
        alert_critical!("Failed to build data: {}", e);
        return Err(e.into());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or use <code>?</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()?;  // Propagates error
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-building-user-data"><a class="header" href="#real-world-example-building-user-data">Real-World Example: Building User Data</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_registration, {
    // Build user data
    let user_data = TestDataBuilder::new()
        .with_var("username", "alice_wonder")
        .with_var("email", "alice@example.com")
        .with_var("password", "secure_password_123")
        .with_var("first_name", "Alice")
        .with_var("last_name", "Wonder")
        .with_var("country", "US")
        .build_json()?;

    // Use in test
    let result = register_user(&amp;user_data)?;

    // Verify
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().email, "alice@example.com");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-building-order-data"><a class="header" href="#real-world-example-building-order-data">Real-World Example: Building Order Data</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_order_processing, {
    // Build order
    let order = TestDataBuilder::new()
        .with_order_data("ORD-12345", "499.99")
        .with_var("customer_id", "CUST-001")
        .with_var("shipping_address", "123 Main St")
        .with_var("payment_method", "credit_card")
        .build_json()?;

    // Process order
    let result = process_order(&amp;order)?;

    // Verify
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().status, "processed");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-composition"><a class="header" href="#advanced-composition">Advanced: Composition</a></h2>
<p>Build complex structures by combining builders:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_composition, {
    // Build related data
    let user = TestDataBuilder::new()
        .with_var("user_id", "123")
        .with_var("name", "Alice")
        .build_json()?;

    let order = TestDataBuilder::new()
        .with_order_data("ORD-001", "100.00")
        .with_var("user_id", "123")  // Link to user
        .build_json()?;

    // Both built, ready to use
    assert_eq!(user["user_id"], "123");
    assert_eq!(order["user_id"], "123");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="boundary-conditions-with-builders"><a class="header" href="#boundary-conditions-with-builders">Boundary Conditions with Builders</a></h2>
<p>Test edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_builder_boundaries, {
    // Empty data
    let empty = TestDataBuilder::new().build_json()?;
    assert!(empty.is_object());

    // Minimal data
    let minimal = TestDataBuilder::new()
        .with_var("id", "1")
        .build_json()?;
    assert_eq!(minimal["id"], "1");

    // Maximum data (many fields)
    let mut builder = TestDataBuilder::new();
    for i in 0..1000 {
        builder = builder.with_var(&amp;format!("field_{}", i), &amp;format!("value_{}", i));
    }
    let large = builder.build_json()?;
    assert!(large.is_object());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-built-data"><a class="header" href="#accessing-built-data">Accessing Built Data</a></h2>
<h3 id="access-as-json"><a class="header" href="#access-as-json">Access as JSON</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("name", "Alice")
    .with_var("age", "30")
    .build_json()?;

// Access fields
assert_eq!(data["name"], "Alice");
assert_eq!(data["age"], "30");
<span class="boring">}</span></code></pre></pre>
<h3 id="serialize-to-struct"><a class="header" href="#serialize-to-struct">Serialize to Struct</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct User {
    name: String,
    age: u32,
}

let data = TestDataBuilder::new()
    .with_var("name", "Alice")
    .with_var("age", "30")
    .build_json()?;

let user: User = serde_json::from_value(data)?;
assert_eq!(user.name, "Alice");
assert_eq!(user.age, 30);
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use descriptive variable names</li>
<li>Chain methods for readability</li>
<li>Handle errors with <code>?</code></li>
<li>Build all data before acting</li>
<li>Use order data for order-specific fields</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use unclear abbreviations</li>
<li>Mix high-level and low-level builders</li>
<li>Build data after acting (arrange first!)</li>
<li>Ignore build errors</li>
</ul>
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="pattern-reusable-builder-factory"><a class="header" href="#pattern-reusable-builder-factory">Pattern: Reusable Builder Factory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_valid_user_data() -&gt; Result&lt;serde_json::Value, String&gt; {
    TestDataBuilder::new()
        .with_var("username", "test_user")
        .with_var("email", "test@example.com")
        .with_var("status", "active")
        .build_json()
}

test!(test_with_factory, {
    let user_data = create_valid_user_data()?;
    // Use pre-built data
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-variation-for-edge-cases"><a class="header" href="#pattern-variation-for-edge-cases">Pattern: Variation for Edge Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_inactive_user_data() -&gt; Result&lt;serde_json::Value, String&gt; {
    TestDataBuilder::new()
        .with_var("username", "inactive_user")
        .with_var("email", "inactive@example.com")
        .with_var("status", "inactive")  // Key difference
        .build_json()
}

test!(test_inactive_user, {
    let user_data = create_inactive_user_data()?;
    // Test inactive user handling
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="failed-to-build-data-invalid-json"><a class="header" href="#failed-to-build-data-invalid-json">"Failed to build data: Invalid JSON"</a></h3>
<p>Check for:</p>
<ul>
<li>Malformed variable values</li>
<li>Type mismatches</li>
<li>Missing required fields</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug by building step-by-step
let builder1 = TestDataBuilder::new().with_var("key1", "value1");
// builder1 is valid

let builder2 = builder1.with_var("key2", "value2");
// builder2 is valid

// etc.
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>Learn assertions: <a href="core/assertions.html">Assertions &amp; Verification</a></p>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Fluent API</strong></td><td>Readable data construction</td></tr>
<tr><td><strong>Chaining</strong></td><td><code>.with_var()</code> returns <code>Self</code></td></tr>
<tr><td><strong>Error Handling</strong></td><td><code>build_json()</code> returns <code>Result</code></td></tr>
<tr><td><strong>Composition</strong></td><td>Combine multiple builders</td></tr>
<tr><td><strong>Reusability</strong></td><td>Extract to helper functions</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="assertions--verification"><a class="header" href="#assertions--verification">Assertions &amp; Verification</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Write clear, effective assertions</p>
</blockquote>
<p>Assertions verify that code behaves correctly. Chicago TDD Tools provides helpers for clear, readable assertions.</p>
<h2 id="basic-assertions"><a class="header" href="#basic-assertions">Basic Assertions</a></h2>
<h3 id="standard-assertions"><a class="header" href="#standard-assertions">Standard Assertions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_basic_assertions, {
    let result: Result&lt;u32, String&gt; = Ok(42);

    // ‚úÖ Chicago TDD style - clear intent
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);

    // Error result
    let error: Result&lt;u32, String&gt; = Err("failed".to_string());
    assert_err!(&amp;error);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="common-assertion-helpers"><a class="header" href="#common-assertion-helpers">Common Assertion Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Success/Error checks
assert_ok!(&amp;result);           // Verifies Ok(_)
assert_err!(&amp;result);          // Verifies Err(_)

// Equality
assert_eq!(actual, expected);   // Equality check
assert_ne!(actual, expected);   // Inequality check

// Boolean
assert!(condition);             // Checks true
assert!(!condition);            // Checks false
<span class="boring">}</span></code></pre></pre>
<h2 id="numeric-assertions"><a class="header" href="#numeric-assertions">Numeric Assertions</a></h2>
<h3 id="range-checking"><a class="header" href="#range-checking">Range Checking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_numeric_assertions, {
    let value = 42;

    // Standard assertions
    assert_eq!(value, 42);
    assert!(value &gt; 40);
    assert!(value &lt; 50);

    // Chicago TDD helper
    assert_in_range!(value, 40, 50);  // Inclusive range
});
<span class="boring">}</span></code></pre></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating Point</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_floating_point, {
    let value: f64 = 3.14159;
    let expected: f64 = 3.14;

    // ‚úÖ Epsilon comparison (handles rounding errors)
    assert!((value - expected).abs() &lt; 0.01);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="string-assertions"><a class="header" href="#string-assertions">String Assertions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_string_assertions, {
    let text = "Hello, World!";

    // Equality
    assert_eq!(text, "Hello, World!");

    // Containment
    assert!(text.contains("World"));

    // Pattern matching
    assert!(text.starts_with("Hello"));
    assert!(text.ends_with("!"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="collection-assertions"><a class="header" href="#collection-assertions">Collection Assertions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_collection_assertions, {
    let vec = vec![1, 2, 3];

    // Length
    assert_eq!(vec.len(), 3);

    // Containment
    assert!(vec.contains(&amp;2));

    // Empty check
    assert!(!vec.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="optionresult-assertions"><a class="header" href="#optionresult-assertions">Option/Result Assertions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_option_result_assertions, {
    let some_value: Option&lt;i32&gt; = Some(42);
    let none_value: Option&lt;i32&gt; = None;

    // Option checks
    assert!(some_value.is_some());
    assert!(none_value.is_none());

    // Result checks
    let ok_result: Result&lt;i32, String&gt; = Ok(42);
    let err_result: Result&lt;i32, String&gt; = Err("error".to_string());

    assert!(ok_result.is_ok());
    assert!(err_result.is_err());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h2>
<p>Add context to assertions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_messages, {
    let result = divide(10, 2);
    assert_eq!(result, 5, "Expected division to work correctly");

    let empty = vec![];
    assert!(!empty.is_empty(), "Vector should not be empty after initialization");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-user-creation"><a class="header" href="#real-world-example-user-creation">Real-World Example: User Creation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_creation, {
    // Create user
    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    let result = create_user(&amp;user_data)?;

    // Assert success
    assert_ok!(&amp;result);
    let user = result.unwrap();

    // Assert properties
    assert_eq!(user.name, "Alice");
    assert_eq!(user.email, "alice@example.com");
    assert!(user.id &gt; 0);
    assert!(user.created_at.len() &gt; 0);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-collection-processing"><a class="header" href="#real-world-example-collection-processing">Real-World Example: Collection Processing</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_filter_operations, {
    let numbers = vec![1, 2, 3, 4, 5];

    // Filter evens
    let evens: Vec&lt;_&gt; = numbers
        .iter()
        .filter(|n| n % 2 == 0)
        .cloned()
        .collect();

    // Assertions
    assert_eq!(evens.len(), 2);
    assert!(evens.contains(&amp;2));
    assert!(evens.contains(&amp;4));
    assert!(!evens.contains(&amp;1));  // 1 is odd
});
<span class="boring">}</span></code></pre></pre>
<h2 id="assert-patterns"><a class="header" href="#assert-patterns">Assert Patterns</a></h2>
<h3 id="pattern-positive-case"><a class="header" href="#pattern-positive-case">Pattern: Positive Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_positive, {
    let result = parse_number("42");
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-negative-case"><a class="header" href="#pattern-negative-case">Pattern: Negative Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_negative, {
    let result = parse_number("invalid");
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-boundary-case"><a class="header" href="#pattern-boundary-case">Pattern: Boundary Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundary, {
    // Zero
    assert_ok!(&amp;parse_number("0"));

    // Large value
    assert_ok!(&amp;parse_number("999999"));

    // Negative
    assert_ok!(&amp;parse_number("-42"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="avoiding-common-pitfalls"><a class="header" href="#avoiding-common-pitfalls">Avoiding Common Pitfalls</a></h2>
<h3 id="-dont-use-unwrap-in-assertions"><a class="header" href="#-dont-use-unwrap-in-assertions">‚ùå Don't: Use unwrap() in assertions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad - panics if result is Err
let value = result.unwrap();
assert_eq!(value, 42);
<span class="boring">}</span></code></pre></pre>
<h3 id="-do-check-first"><a class="header" href="#-do-check-first">‚úÖ Do: Check first</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - checks properly
assert_ok!(&amp;result);
if let Ok(value) = result {
    assert_eq!(value, 42);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-dont-assert-implementation-details"><a class="header" href="#-dont-assert-implementation-details">‚ùå Don't: Assert implementation details</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad - depends on internal structure
assert_eq!(user.internal_id, 123);
<span class="boring">}</span></code></pre></pre>
<h3 id="-do-assert-behavior"><a class="header" href="#-do-assert-behavior">‚úÖ Do: Assert behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - asserts external behavior
assert_eq!(user.name, "Alice");
assert_eq!(user.email, "alice@example.com");
<span class="boring">}</span></code></pre></pre>
<h2 id="assertion-order"><a class="header" href="#assertion-order">Assertion Order</a></h2>
<p>Follow AAA pattern:</p>
<ol>
<li><strong>Arrange</strong> - Build data</li>
<li><strong>Act</strong> - Execute code</li>
<li><strong>Assert</strong> - Verify behavior</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_order, {
    // Arrange
    let input = 5;

    // Act
    let result = multiply_by_two(input);

    // Assert (all together, at the end)
    assert_eq!(result, 10);
    assert!(result &gt; 0);
    assert!(result &lt; 100);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use helper macros (<code>assert_ok!</code>, <code>assert_err!</code>)</li>
<li>Assert one behavior per test</li>
<li>Add context with messages</li>
<li>Check both success and error paths</li>
<li>Use descriptive assertion messages</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use <code>unwrap()</code> in assertions</li>
<li>Mix act and assert</li>
<li>Assert implementation details</li>
<li>Skip error case assertions</li>
<li>Use vague assertion messages</li>
</ul>
<h2 id="common-assertions-reference"><a class="header" href="#common-assertions-reference">Common Assertions Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Code</th></tr></thead><tbody>
<tr><td>Value matches</td><td><code>assert_eq!(actual, expected)</code></td></tr>
<tr><td>Value different</td><td><code>assert_ne!(actual, expected)</code></td></tr>
<tr><td>True condition</td><td><code>assert!(condition)</code></td></tr>
<tr><td>Ok result</td><td><code>assert_ok!(&amp;result)</code></td></tr>
<tr><td>Err result</td><td><code>assert_err!(&amp;result)</code></td></tr>
<tr><td>In range</td><td><code>assert_in_range!(value, min, max)</code></td></tr>
<tr><td>Contains text</td><td><code>assert!(text.contains("substring"))</code></td></tr>
<tr><td>Empty collection</td><td><code>assert!(collection.is_empty())</code></td></tr>
</tbody></table>
</div>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>Learn about error paths: <a href="core/error-paths.html">Error Path Testing</a></p>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Chicago TDD emphasizes:</p>
<ul>
<li>Clear assertions with helper macros</li>
<li>Both success and error case verification</li>
<li>AAA pattern (Arrange-Act-Assert)</li>
<li>Behavior verification, not implementation details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-path-testing"><a class="header" href="#error-path-testing">Error Path Testing</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | Learn to test failure scenarios thoroughly</p>
</blockquote>
<p>Error paths are where 80% of bugs hide. Chicago TDD emphasizes comprehensive error testing.</p>
<h2 id="why-error-paths-matter"><a class="header" href="#why-error-paths-matter">Why Error Paths Matter</a></h2>
<p>Most code focuses on the "happy path" (success). Bugs hide in error cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Happy path is obvious
let parsed = "42".parse::&lt;u32&gt;()?;
assert_eq!(parsed, 42);

// Error path has subtle bugs
// What about "not_a_number"?
// What about negative "-42"?
// What about overflow "99999999999999999999"?
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-both-paths"><a class="header" href="#testing-both-paths">Testing Both Paths</a></h2>
<p>Every function should test both success and failure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_complete_behavior, {
    // Success path
    let ok_result = parse_number::&lt;u32&gt;("42");
    assert_ok!(&amp;ok_result);
    assert_eq!(ok_result.unwrap(), 42);

    // Error path
    let err_result = parse_number::&lt;u32&gt;("invalid");
    assert_err!(&amp;err_result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h2>
<h3 id="1-invalid-input"><a class="header" href="#1-invalid-input">1. Invalid Input</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_invalid_input, {
    let result = validate_email("not_an_email");
    assert_err!(&amp;result);

    let result = validate_email("");
    assert_err!(&amp;result);

    let result = validate_email("@");
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="2-boundary-conditions"><a class="header" href="#2-boundary-conditions">2. Boundary Conditions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundaries, {
    // Minimum
    assert_ok!(&amp;process(0));

    // Just above minimum
    assert_ok!(&amp;process(1));

    // Maximum valid
    assert_ok!(&amp;process(u32::MAX - 1));

    // Just past maximum
    assert_err!(&amp;process(u32::MAX + 1));  // If checked
});
<span class="boring">}</span></code></pre></pre>
<h3 id="3-resource-errors"><a class="header" href="#3-resource-errors">3. Resource Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_resource_errors, {
    // File doesn't exist
    let result = read_file("nonexistent.txt");
    assert_err!(&amp;result);

    // Permission denied
    let result = write_file("/root/restricted.txt", "data");
    assert_err!(&amp;result);

    // Out of memory (hard to test, but consider it)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="4-state-errors"><a class="header" href="#4-state-errors">4. State Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_state_errors, {
    let state = MyStateMachine::new();

    // Valid transition
    assert_ok!(&amp;state.transition_to_active());

    // Invalid transition
    let already_active = MyStateMachine::new().transition_to_active();
    assert_err!(&amp;already_active.transition_to_active());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h2>
<p>Test that error messages are helpful:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_messages, {
    let result = parse_number::&lt;u32&gt;("not_a_number");

    match result {
        Err(e) =&gt; {
            // Verify error message is clear
            assert!(e.to_string().contains("parse error"));
            assert!(e.to_string().contains("not_a_number"));
        }
        Ok(_) =&gt; panic!("Should have failed"),
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<p>Test that code recovers from errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_recovery, {
    // First attempt fails
    let result1 = connect_to_database("invalid_url");
    assert_err!(&amp;result1);

    // Code continues and retries with valid URL
    let result2 = connect_to_database("valid_url");
    assert_ok!(&amp;result2);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-form-validation"><a class="header" href="#real-world-example-form-validation">Real-World Example: Form Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_form_validation, {
    let validator = FormValidator::new();

    // Valid case
    let valid = validator.validate(&amp;FormData {
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
        password: "secure_password_123".to_string(),
    });
    assert_ok!(&amp;valid);

    // Missing username
    let missing_username = validator.validate(&amp;FormData {
        username: "".to_string(),
        email: "alice@example.com".to_string(),
        password: "secure_password_123".to_string(),
    });
    assert_err!(&amp;missing_username);

    // Invalid email
    let invalid_email = validator.validate(&amp;FormData {
        username: "alice".to_string(),
        email: "not_an_email".to_string(),
        password: "secure_password_123".to_string(),
    });
    assert_err!(&amp;invalid_email);

    // Weak password
    let weak_password = validator.validate(&amp;FormData {
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
        password: "123".to_string(),  // Too short
    });
    assert_err!(&amp;weak_password);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-api-endpoint"><a class="header" href="#real-world-example-api-endpoint">Real-World Example: API Endpoint</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_api_error_handling, {
    let client = ApiClient::new();

    // Success
    let result = client.get_user(123);
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().id, 123);

    // User not found
    let result = client.get_user(999999);
    assert_err!(&amp;result);

    // Invalid ID
    let result = client.get_user(-1);
    assert_err!(&amp;result);

    // Network error (mock or integration test)
    let result = client.get_user(456);  // Server down
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="pattern-check-and-handle"><a class="header" href="#pattern-check-and-handle">Pattern: Check and Handle</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_check_and_handle, {
    let result = risky_operation();

    match result {
        Ok(value) =&gt; {
            assert_eq!(value, expected);
        }
        Err(e) =&gt; {
            // Handle error
            assert!(e.to_string().len() &gt; 0);
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-map-error"><a class="header" href="#pattern-map-error">Pattern: Map Error</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_map_error, {
    let result = risky_operation()
        .map_err(|e| format!("Operation failed: {}", e));

    assert_err!(&amp;result);
    if let Err(e) = result {
        assert!(e.contains("Operation failed"));
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-recover"><a class="header" href="#pattern-recover">Pattern: Recover</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_recovery, {
    let result = risky_operation()
        .or_else(|_| fallback_operation());

    // Should succeed via fallback
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="comprehensive-error-test"><a class="header" href="#comprehensive-error-test">Comprehensive Error Test</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_comprehensive_errors, {
    // Arrange
    let test_cases = vec![
        ("valid_input", true),
        ("", false),
        ("too_long_" /* 100 chars */, false),
        ("special@chars#", false),
        ("123", true),
        ("-123", false),  // Negative not allowed
    ];

    // Act &amp; Assert
    for (input, should_succeed) in test_cases {
        let result = validate_input(input);

        if should_succeed {
            assert_ok!(&amp;result, "Input '{}' should be valid", input);
        } else {
            assert_err!(&amp;result, "Input '{}' should be invalid", input);
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test both success and error paths</li>
<li>Use boundary conditions</li>
<li>Test error messages</li>
<li>Verify error recovery</li>
<li>Document expected errors</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Only test the happy path</li>
<li>Assume error handling is correct</li>
<li>Ignore boundary conditions</li>
<li>Skip error message verification</li>
<li>Test implementation details of errors</li>
</ul>
<h2 id="error-testing-checklist"><a class="header" href="#error-testing-checklist">Error Testing Checklist</a></h2>
<p>For each function, test:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Happy path (normal input)</li>
<li><input disabled="" type="checkbox"/>
Invalid input</li>
<li><input disabled="" type="checkbox"/>
Boundary conditions (min, max, zero, -1)</li>
<li><input disabled="" type="checkbox"/>
Empty/null values</li>
<li><input disabled="" type="checkbox"/>
Resource errors (if applicable)</li>
<li><input disabled="" type="checkbox"/>
State errors (if applicable)</li>
<li><input disabled="" type="checkbox"/>
Error messages are clear</li>
<li><input disabled="" type="checkbox"/>
Error recovery is possible</li>
</ul>
<h2 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common Error Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Test Case</th></tr></thead><tbody>
<tr><td>Missing input</td><td>Empty string, None, empty Vec</td></tr>
<tr><td>Invalid format</td><td>Wrong type, malformed data</td></tr>
<tr><td>Out of range</td><td>Negative when only positive allowed</td></tr>
<tr><td>Resource unavailable</td><td>File not found, connection refused</td></tr>
<tr><td>State violation</td><td>Invalid state transition</td></tr>
<tr><td>Timeout</td><td>Operation takes too long</td></tr>
</tbody></table>
</div>
<h2 id="real-world-integration-example"><a class="header" href="#real-world-integration-example">Real-World Integration Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_database_operations, {
    let db = Database::new();

    // Success: Insert and retrieve
    let user_id = db.insert_user("alice", "alice@example.com");
    let result = db.get_user(user_id);
    assert_ok!(&amp;result);

    // Error: User not found
    let result = db.get_user(999999);
    assert_err!(&amp;result);

    // Error: Duplicate email
    let result = db.insert_user("bob", "alice@example.com");  // Email taken
    assert_err!(&amp;result);

    // Error: Invalid email
    let result = db.insert_user("carol", "not_an_email");
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>Learn advanced techniques: <a href="core/../advanced/README.html">Advanced Testing Techniques</a></p>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Chicago TDD prioritizes error testing because:</p>
<ul>
<li>Bugs hide in error paths</li>
<li>Error handling is often incorrect</li>
<li>Users encounter errors in real use</li>
</ul>
<p>Always test:</p>
<ul>
<li>‚úÖ Happy path</li>
<li>‚úÖ Error cases</li>
<li>‚úÖ Boundary conditions</li>
<li>‚úÖ Error messages</li>
<li>‚úÖ Recovery</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-testing-techniques"><a class="header" href="#advanced-testing-techniques">Advanced Testing Techniques</a></h1>
<p>Welcome to advanced testing techniques! These specialized methods help you test complex scenarios effectively.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Advanced techniques include:</p>
<ol>
<li><strong>Property-Based Testing</strong> - Generate random data and verify properties</li>
<li><strong>Mutation Testing</strong> - Validate test quality by introducing mutations</li>
<li><strong>Snapshot Testing</strong> - Golden files to detect unintended changes</li>
<li><strong>CLI Testing</strong> - Test command-line interfaces</li>
<li><strong>Concurrency Testing</strong> - Deterministic thread testing</li>
</ol>
<h2 id="when-to-use-advanced-techniques"><a class="header" href="#when-to-use-advanced-techniques">When to Use Advanced Techniques</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Technique</th><th>Best For</th><th>When to Use</th></tr></thead><tbody>
<tr><td><strong>Property-Based</strong></td><td>Mathematical properties, edge cases</td><td>Complex algorithms, parsing</td></tr>
<tr><td><strong>Mutation</strong></td><td>Test quality validation</td><td>Assessing test effectiveness</td></tr>
<tr><td><strong>Snapshot</strong></td><td>Stable output, complex structures</td><td>API responses, generated code</td></tr>
<tr><td><strong>CLI</strong></td><td>Command-line tools</td><td>CLI applications, scripts</td></tr>
<tr><td><strong>Concurrency</strong></td><td>Thread-safe code</td><td>Concurrent systems, race conditions</td></tr>
</tbody></table>
</div>
<h2 id="quick-reference-1"><a class="header" href="#quick-reference-1">Quick Reference</a></h2>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test that addition is commutative
test!(test_addition_commutative, {
    let strategy = ProptestStrategy::new().with_cases(100);
    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| a + b == b + a);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="mutation-testing"><a class="header" href="#mutation-testing">Mutation Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify tests catch mutations
let mut tester = MutationTester::new(data);
tester.apply_mutation(MutationOperator::ChangeValue(...));
let caught = tester.test_mutation_detection(|data| check_data(data));
assert!(caught);  // Tests should catch the mutation
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Golden file testing
let output = generate_report();
assert_matches!(output, "report");  // Compares with snapshot
<span class="boring">}</span></code></pre></pre>
<h3 id="cli-testing"><a class="header" href="#cli-testing">CLI Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test CLI commands
let output = CliTest::new("myapp", vec!["list", "--verbose"])
    .run()?;
assert!(output.contains("item1"));
<span class="boring">}</span></code></pre></pre>
<h3 id="concurrency-testing"><a class="header" href="#concurrency-testing">Concurrency Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Deterministic thread testing
loom::model(|| {
    let data = Arc::new(Mutex::new(0));
    thread::spawn({
        let data = data.clone();
        move || *data.lock().unwrap() += 1;
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="learning-path"><a class="header" href="#learning-path">Learning Path</a></h2>
<ol>
<li><strong>Start with</strong> <a href="advanced/property-testing.html">Property-Based Testing</a> - Easy to understand, powerful</li>
<li><strong>Then explore</strong> <a href="advanced/mutation-testing.html">Mutation Testing</a> - Validates your tests</li>
<li><strong>Add</strong> <a href="advanced/snapshot-testing.html">Snapshot Testing</a> - For regression detection</li>
<li><strong>Test CLIs with</strong> <a href="advanced/cli-testing.html">CLI Testing</a> - If you have CLI tools</li>
<li><strong>Thread-safe code with</strong> <a href="advanced/concurrency-testing.html">Concurrency Testing</a> - For concurrent systems</li>
</ol>
<h2 id="combining-techniques"><a class="header" href="#combining-techniques">Combining Techniques</a></h2>
<p>You can combine advanced techniques:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(comprehensive_test, {
    // Use fixtures and data builders (core)
    let fixture = TestFixture::new()?;
    let data = TestDataBuilder::new()...build_json()?;

    // Use property-based testing (advanced)
    let strategy = ProptestStrategy::new().with_cases(50);

    // Use mutation testing (advanced)
    let mut tester = MutationTester::new(data.clone());

    // Use snapshot testing (advanced)
    let result = process(&amp;data)?;
    assert_matches!(result, "expected_output");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-scenarios"><a class="header" href="#real-world-scenarios">Real-World Scenarios</a></h2>
<h3 id="scenario-1-json-parser"><a class="header" href="#scenario-1-json-parser">Scenario 1: JSON Parser</a></h3>
<ul>
<li><strong>Core</strong>: Basic tests with fixtures</li>
<li><strong>Property-Based</strong>: Test parsing properties (round-trip)</li>
<li><strong>Mutation</strong>: Validate test quality</li>
<li><strong>Snapshot</strong>: Compare against golden files</li>
</ul>
<h3 id="scenario-2-cli-tool"><a class="header" href="#scenario-2-cli-tool">Scenario 2: CLI Tool</a></h3>
<ul>
<li><strong>Core</strong>: Basic command tests</li>
<li><strong>CLI Testing</strong>: Full CLI integration</li>
<li><strong>Snapshot</strong>: Compare output with golden files</li>
<li><strong>Property-Based</strong>: Random argument generation</li>
</ul>
<h3 id="scenario-3-concurrent-system"><a class="header" href="#scenario-3-concurrent-system">Scenario 3: Concurrent System</a></h3>
<ul>
<li><strong>Core</strong>: Basic thread tests</li>
<li><strong>Concurrency</strong>: Deterministic testing with loom</li>
<li><strong>Property-Based</strong>: Test invariants across threads</li>
<li><strong>Mutation</strong>: Validate synchronization correctness</li>
</ul>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>Enable features for advanced techniques:</p>
<pre><code class="language-toml">[dev-dependencies]
chicago-tdd-tools = { version = "1.3", features = [
    "property-testing",      # Property-based testing
    "mutation-testing",      # Mutation testing
    "snapshot-testing",      # Snapshot testing
    "cli-testing",           # CLI testing
    "concurrency-testing",   # Concurrency testing
    "testing-extras",        # All of above (most common)
    "testing-full",          # All testing features
] }
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>Advanced techniques can be slower:</p>
<div class="table-wrapper"><table><thead><tr><th>Technique</th><th>Speed</th><th>Trade-off</th></tr></thead><tbody>
<tr><td>Unit tests</td><td>Fast (ms)</td><td>Limited scenarios</td></tr>
<tr><td>Property-based</td><td>Medium (seconds)</td><td>Comprehensive coverage</td></tr>
<tr><td>Mutation</td><td>Slow (minutes)</td><td>High confidence</td></tr>
<tr><td>Snapshot</td><td>Fast (ms)</td><td>Brittle to changes</td></tr>
<tr><td>Concurrency</td><td>Slow (seconds)</td><td>Deterministic</td></tr>
</tbody></table>
</div>
<p><strong>Recommendation</strong>:</p>
<ul>
<li>Use core patterns for 80% of tests (fast feedback)</li>
<li>Use advanced techniques for critical paths (high confidence)</li>
</ul>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>‚ùå <strong>Over-using advanced techniques</strong></p>
<ul>
<li>Use property-based for properties, not all tests</li>
<li>Use mutation occasionally, not always</li>
</ul>
<p>‚ùå <strong>Ignoring performance</strong></p>
<ul>
<li>Property-based with 10,000 cases is overkill</li>
<li>Limit mutation test scope</li>
</ul>
<p>‚ùå <strong>Replacing core patterns</strong></p>
<ul>
<li>Advanced techniques complement, not replace, core patterns</li>
<li>Still need AAA pattern and error paths</li>
</ul>
<p>‚úÖ <strong>Best practices</strong>:</p>
<ul>
<li>Use core patterns as foundation</li>
<li>Add advanced techniques strategically</li>
<li>Balance confidence with speed</li>
</ul>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<ul>
<li><a href="advanced/property-testing.html">Property-Based Testing</a></li>
<li><a href="advanced/mutation-testing.html">Mutation Testing</a></li>
<li><a href="advanced/snapshot-testing.html">Snapshot Testing</a></li>
<li><a href="advanced/cli-testing.html">CLI Testing</a></li>
<li><a href="advanced/concurrency-testing.html">Concurrency Testing</a></li>
</ul>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>üëâ <strong>Start with <a href="advanced/property-testing.html">Property-Based Testing</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-based-testing-1"><a class="header" href="#property-based-testing-1">Property-Based Testing</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Generate random test data to verify properties</p>
</blockquote>
<p>Property-based testing generates random test data and verifies that properties hold for all inputs.</p>
<h2 id="what-is-a-property"><a class="header" href="#what-is-a-property">What is a Property?</a></h2>
<p>A <strong>property</strong> is a logical assertion that should hold for all valid inputs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: Addition is commutative
// For all a, b: a + b == b + a

// Property: Parsing and formatting is round-trip safe
// For all x: parse(format(x)) == x

// Property: Sorted list has no inversions
// For all lists: list[i] &lt;= list[i+1]
<span class="boring">}</span></code></pre></pre>
<h2 id="property-based-vs-example-based"><a class="header" href="#property-based-vs-example-based">Property-Based vs. Example-Based</a></h2>
<h3 id="example-based-traditional"><a class="header" href="#example-based-traditional">Example-Based (Traditional)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_addition_examples, {
    assert_eq!(2 + 3, 5);
    assert_eq!(0 + 5, 5);
    assert_eq!(10 + 0, 10);
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Limitation</strong>: Only tests specific examples. What about <code>u32::MAX + 1</code>?</p>
<h3 id="property-based"><a class="header" href="#property-based">Property-Based</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_addition_property, {
    let strategy = ProptestStrategy::new().with_cases(1000);
    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| {
        a + b == b + a  // Checks for 1000 random pairs
    });
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Advantage</strong>: Tests 1000 random cases automatically.</p>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<h3 id="basic-property-test"><a class="header" href="#basic-property-test">Basic Property Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::property::*;
use proptest::prelude::*;

test!(test_parsing_property, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;u32&gt;(), |num| {
        let formatted = format!("{}", num);
        let parsed: u32 = formatted.parse().unwrap();
        num == parsed  // Property: round-trip works
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="using-generators"><a class="header" href="#using-generators">Using Generators</a></h3>
<p>Generate specific types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_string_properties, {
    let strategy = ProptestStrategy::new().with_cases(100);

    // Test with strings of 1-100 characters
    strategy.test("[a-zA-Z0-9]{1,100}", |s| {
        // Property: non-empty string remains non-empty
        !s.is_empty()
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-properties-to-test"><a class="header" href="#common-properties-to-test">Common Properties to Test</a></h2>
<h3 id="1-commutativity"><a class="header" href="#1-commutativity">1. Commutativity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a + b == b + a
strategy.test(any::&lt;(i32, i32)&gt;(), |(a, b)| {
    a + b == b + a
});
<span class="boring">}</span></code></pre></pre>
<h3 id="2-associativity"><a class="header" href="#2-associativity">2. Associativity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: (a + b) + c == a + (b + c)
strategy.test(any::&lt;(i32, i32, i32)&gt;(), |(a, b, c)| {
    (a + b) + c == a + (b + c)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="3-distributivity"><a class="header" href="#3-distributivity">3. Distributivity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a * (b + c) == (a * b) + (a * c)
strategy.test(any::&lt;(i32, i32, i32)&gt;(), |(a, b, c)| {
    a * (b + c) == (a * b) + (a * c)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="4-identity"><a class="header" href="#4-identity">4. Identity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a + 0 == a
strategy.test(any::&lt;i32&gt;(), |a| {
    a + 0 == a
});
<span class="boring">}</span></code></pre></pre>
<h3 id="5-inverse"><a class="header" href="#5-inverse">5. Inverse</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a - a == 0
strategy.test(any::&lt;i32&gt;(), |a| {
    a - a == 0
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-json-parsing"><a class="header" href="#real-world-example-json-parsing">Real-World Example: JSON Parsing</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_json_parsing_properties, {
    let strategy = ProptestStrategy::new().with_cases(500);

    strategy.test(any::&lt;(String, i32, bool)&gt;(), |(name, age, active)| {
        // Create JSON
        let json = format!(
            r#"{{"name":"{}","age":{},"active":{}}}"#,
            name, age, active
        );

        // Parse it
        let parsed: Result&lt;MyData, _&gt; = serde_json::from_str(&amp;json);

        // Property: Valid input parses successfully
        parsed.is_ok()
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-string-validation"><a class="header" href="#real-world-example-string-validation">Real-World Example: String Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_email_validation, {
    let strategy = ProptestStrategy::new().with_cases(200);

    // Test valid emails
    strategy.test(
        r"[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}",
        |email| {
            // Property: Valid email passes validation
            validate_email(email).is_ok()
        }
    );
});
<span class="boring">}</span></code></pre></pre>
<h2 id="shrinking"><a class="header" href="#shrinking">Shrinking</a></h2>
<p>When a property fails, shrinking finds the minimal failing case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_shrinking, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;Vec&lt;i32&gt;&gt;(), |vec| {
        // Property fails for some input
        vec.len() &lt; 10  // This might fail for vec![1,2,3,...,100]

        // Shrinking finds minimal failure: vec with length &gt;= 10
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-strategies"><a class="header" href="#combining-strategies">Combining Strategies</a></h2>
<p>Test multiple values together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_combined_strategy, {
    let strategy = ProptestStrategy::new().with_cases(100);

    // Test with tuple of (String, u32, bool)
    strategy.test(
        (any::&lt;String&gt;(), 1u32..100u32, any::&lt;bool&gt;()),
        |(name, age, active)| {
            // Test with all three values
            !name.is_empty() &amp;&amp; age &gt; 0
        }
    );
});
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="number-of-cases"><a class="header" href="#number-of-cases">Number of Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test with 100 random cases
let strategy = ProptestStrategy::new().with_cases(100);

// Test with 1000 cases (slower, more thorough)
let strategy = ProptestStrategy::new().with_cases(1000);

// Test with 10 cases (faster, less thorough)
let strategy = ProptestStrategy::new().with_cases(10);
<span class="boring">}</span></code></pre></pre>
<h3 id="random-seed"><a class="header" href="#random-seed">Random Seed</a></h3>
<p>For reproducible tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut generator = PropertyTestGenerator::&lt;100, 5&gt;::new()
    .with_seed(42);  // Use specific seed

let data = generator.generate_test_data();
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-property-based-testing"><a class="header" href="#when-to-use-property-based-testing">When to Use Property-Based Testing</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>Mathematical properties (commutativity, associativity)</li>
<li>Round-trip properties (serialize/deserialize)</li>
<li>Parsing and formatting</li>
<li>List operations (sort, filter, map)</li>
<li>State machine transitions</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Specific business logic (use example tests)</li>
<li>Performance testing (use benchmarks)</li>
<li>Complex setup (use fixtures)</li>
</ul>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test actual properties (not specific values)</li>
<li>Use meaningful generators</li>
<li>Start with 100-500 cases</li>
<li>Check edge cases manually</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Replace example tests (both have value)</li>
<li>Use excessive cases (slows down tests)</li>
<li>Ignore failed cases</li>
<li>Only use randomly generated data</li>
</ul>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<ul>
<li>100 cases: ~100ms per property</li>
<li>1000 cases: ~1s per property</li>
<li>10,000 cases: ~10s per property</li>
</ul>
<p><strong>Recommendation</strong>: Start with 100-500 cases. Use more for critical code.</p>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="property-fails-intermittently"><a class="header" href="#property-fails-intermittently">Property Fails Intermittently</a></h3>
<p>Use shrinking output to find minimal case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_debug_failure, {
    let strategy = ProptestStrategy::new().with_cases(1000);
    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| {
        // If fails: check shrunk output
        // Example: shrunk to (0, 0) or (u32::MAX, 0)
        (a as u64) + (b as u64) &lt; u64::MAX
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="property-too-strict"><a class="header" href="#property-too-strict">Property Too Strict</a></h3>
<p>Relax constraints:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Too strict: a * b == b * a (fails due to overflow)
// Better: a.checked_mul(b) == b.checked_mul(a)
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<p>Learn mutation testing: <a href="advanced/mutation-testing.html">Mutation Testing</a></p>
<hr />
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Property-based testing:</p>
<ul>
<li>‚úÖ Tests properties for all inputs</li>
<li>‚úÖ Finds edge cases automatically</li>
<li>‚úÖ Includes shrinking to find minimal failures</li>
<li>‚úÖ Great for algorithms and parsing</li>
</ul>
<p>Use with fixtures and data builders for comprehensive testing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutation-testing-1"><a class="header" href="#mutation-testing-1">Mutation Testing</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Validate test quality by introducing mutations</p>
</blockquote>
<p>Mutation testing validates test quality by introducing mutations (changes) to code and verifying tests catch them.</p>
<h2 id="quick-reference-mutation-testing-api"><a class="header" href="#quick-reference-mutation-testing-api">Quick Reference: Mutation Testing API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th><th>Key Methods</th></tr></thead><tbody>
<tr><td><code>MutationTester::new()</code></td><td>Create a tester for data</td><td><code>apply_mutation()</code>, <code>test_mutation_detection()</code></td></tr>
<tr><td><code>MutationOperator::RemoveKey()</code></td><td>Remove data key</td><td>Parameter: key to remove</td></tr>
<tr><td><code>MutationOperator::AddKey()</code></td><td>Add new key-value</td><td>Parameters: key, value</td></tr>
<tr><td><code>MutationOperator::ChangeValue()</code></td><td>Change existing value</td><td>Parameters: key, new_value</td></tr>
<tr><td><code>MutationOperator::SwapValues()</code></td><td>Swap two values</td><td>Parameters: key1, key2</td></tr>
<tr><td><code>MutationOperator::ToggleBoolean()</code></td><td>Flip bool true‚Üîfalse</td><td>Parameter: key</td></tr>
<tr><td><code>MutationOperator::NumericDelta()</code></td><td>Adjust numeric by delta</td><td>Parameters: key, delta_value</td></tr>
<tr><td><code>MutationOperator::StringCase()</code></td><td>Change string case</td><td>Parameters: key, CaseMode</td></tr>
<tr><td><code>MutationScore::calculate()</code></td><td>Compute score</td><td>Parameters: caught, total</td></tr>
<tr><td><code>SpanStatus</code> enum</td><td>Mutation test results</td><td>Variants: Ok, Error, Unknown</td></tr>
</tbody></table>
</div>
<h2 id="why-mutation-testing"><a class="header" href="#why-mutation-testing">Why Mutation Testing?</a></h2>
<p>High code coverage doesn't guarantee good tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangerous_function(x: u32) -&gt; u32 {
    if x &gt; 0 {
        return x * 2;  // Intentional bug: should be x * 3
    }
    0
}

test!(test_bad_coverage, {
    // This test gives 100% code coverage
    assert_eq!(dangerous_function(5), 10);  // This passes even with bug!
    // But tests don't verify the result is CORRECT

    // Bad test - doesn't verify behavior
    assert!(dangerous_function(5) &gt; 0);  // Passes even if returns 99
});
<span class="boring">}</span></code></pre></pre>
<p>Mutation testing fixes this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_mutation, {
    // Arrange
    let mut tester = MutationTester::new(dangerous_function);

    // Apply mutation: change * 2 to * 3
    tester.apply_mutation(MutationOperator::ChangeValue(...));

    // Act: Test catches the mutation
    let caught = tester.test_mutation_detection(|func| {
        func(5) == 10  // This will fail with mutation
    });

    // Assert: Mutation was caught
    assert!(caught);  // ‚úÖ Good test catches mutation
});
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-mutation-testing"><a class="header" href="#basic-mutation-testing">Basic Mutation Testing</a></h2>
<h3 id="creating-a-mutation-tester"><a class="header" href="#creating-a-mutation-tester">Creating a Mutation Tester</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::mutation::*;
use std::collections::HashMap;

test!(test_mutation_basic, {
    let mut data = HashMap::new();
    data.insert("key1".to_string(), "value1".to_string());

    // Create tester
    let mut tester = MutationTester::new(data);

    // Apply mutation: remove a key
    tester.apply_mutation(MutationOperator::RemoveKey("key1".to_string()));

    // Test detects the mutation
    let caught = tester.test_mutation_detection(|data| {
        !data.is_empty()  // Should fail with mutation
    });

    assert!(caught);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-operators"><a class="header" href="#mutation-operators">Mutation Operators</a></h2>
<h3 id="removekey"><a class="header" href="#removekey">RemoveKey</a></h3>
<p>Remove a key from the data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::RemoveKey("key".to_string()));
<span class="boring">}</span></code></pre></pre>
<h3 id="addkey"><a class="header" href="#addkey">AddKey</a></h3>
<p>Add a new key:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::AddKey(
    "new_key".to_string(),
    "new_value".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="changevalue"><a class="header" href="#changevalue">ChangeValue</a></h3>
<p>Change a value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::ChangeValue(
    "key".to_string(),
    "different_value".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="swapvalues"><a class="header" href="#swapvalues">SwapValues</a></h3>
<p>Swap values between two keys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::SwapValues(
    "key1".to_string(),
    "key2".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="toggleboolean"><a class="header" href="#toggleboolean">ToggleBoolean</a></h3>
<p>Toggle a boolean value (flip true/false):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::ToggleBoolean(
    "is_active".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="numericdelta"><a class="header" href="#numericdelta">NumericDelta</a></h3>
<p>Change a numeric value by a delta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::NumericDelta(
    "count".to_string(),
    10  // Add 10 to the value
));
<span class="boring">}</span></code></pre></pre>
<h3 id="stringcase"><a class="header" href="#stringcase">StringCase</a></h3>
<p>Change string case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::mutation::CaseMode;

tester.apply_mutation(MutationOperator::StringCase(
    "name".to_string(),
    CaseMode::Upper  // or Lower, Mixed
));
<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-score"><a class="header" href="#mutation-score">Mutation Score</a></h2>
<p>Calculate how many mutations your tests catch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_mutation_score, {
    let mut data = HashMap::new();
    data.insert("key1".to_string(), "value1".to_string());
    data.insert("key2".to_string(), "value2".to_string());

    let mut tester = MutationTester::new(data);

    // Apply 3 mutations
    let mut caught = 0;

    // Mutation 1: Remove key1
    tester.apply_mutation(MutationOperator::RemoveKey("key1".to_string()));
    if tester.test_mutation_detection(|d| d.contains_key("key1")) {
        caught += 1;
    }

    // Mutation 2: Remove key2
    tester.apply_mutation(MutationOperator::RemoveKey("key2".to_string()));
    if tester.test_mutation_detection(|d| d.contains_key("key2")) {
        caught += 1;
    }

    // Mutation 3: Add key3
    tester.apply_mutation(MutationOperator::AddKey("key3".to_string(), "value3".to_string()));
    if tester.test_mutation_detection(|d| d.len() == 2) {
        caught += 1;
    }

    // Calculate score
    let score = MutationScore::calculate(caught, 3);
    assert!(score.is_acceptable());  // &gt;= 80%

    alert_info!("Mutation score: {}%", score.score());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-user-service"><a class="header" href="#real-world-example-user-service">Real-World Example: User Service</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_service_mutations, {
    let user = User {
        id: 123,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };

    let mut tester = MutationTester::new(user);
    let mut caught = 0;
    let mut total = 0;

    // Test 1: Mutation removes user ID
    total += 1;
    tester.apply_mutation(MutationOperator::ChangeValue(
        "id".to_string(),
        "0".to_string()
    ));
    if tester.test_mutation_detection(|u| u.id &gt; 0) {
        caught += 1;
    }

    // Test 2: Mutation changes name
    total += 1;
    tester.apply_mutation(MutationOperator::ChangeValue(
        "name".to_string(),
        "Bob".to_string()
    ));
    if tester.test_mutation_detection(|u| u.name == "Alice") {
        caught += 1;
    }

    // Test 3: Mutation changes email
    total += 1;
    tester.apply_mutation(MutationOperator::ChangeValue(
        "email".to_string(),
        "bob@example.com".to_string()
    ));
    if tester.test_mutation_detection(|u| u.email == "alice@example.com") {
        caught += 1;
    }

    let score = MutationScore::calculate(caught, total);
    alert_info!("User service mutation score: {}%", score.score());
    assert!(score.is_acceptable());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="interpreting-results"><a class="header" href="#interpreting-results">Interpreting Results</a></h2>
<h3 id="high-mutation-score-80"><a class="header" href="#high-mutation-score-80">High Mutation Score (&gt;80%)</a></h3>
<p>‚úÖ <strong>Good</strong>: Tests are catching mutations</p>
<pre><code>Mutation Score: 95%
- 95 out of 100 mutations caught
- Tests are effective
- High confidence in code quality
</code></pre>
<h3 id="low-mutation-score-80"><a class="header" href="#low-mutation-score-80">Low Mutation Score (&lt;80%)</a></h3>
<p>‚ö†Ô∏è <strong>Warning</strong>: Some mutations slip through</p>
<pre><code>Mutation Score: 60%
- Only 60 out of 100 mutations caught
- 40 mutations go undetected
- May have weak tests or untested branches
</code></pre>
<h3 id="mutations-caught-vs-missed"><a class="header" href="#mutations-caught-vs-missed">Mutations Caught vs. Missed</a></h3>
<pre><code>Mutation "Remove key1" ‚Üí CAUGHT (test failed)
Mutation "Change value" ‚Üí MISSED (test still passed!)
</code></pre>
<p>When mutations are missed, improve tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: Weak test
assert!(data.contains_key("key1"));

// After: Strong test
assert_eq!(data.get("key1").unwrap(), "expected_value");
<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-testing-workflow"><a class="header" href="#mutation-testing-workflow">Mutation Testing Workflow</a></h2>
<ol>
<li><strong>Write tests</strong> (core patterns)</li>
<li><strong>Measure coverage</strong> (80%+ code coverage)</li>
<li><strong>Run mutation tests</strong> (catch mutations)</li>
<li><strong>Improve weak tests</strong> (missing mutations)</li>
<li><strong>Reach 80%+ mutation score</strong></li>
</ol>
<h2 id="when-to-use-mutation-testing"><a class="header" href="#when-to-use-mutation-testing">When to Use Mutation Testing</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>Validating test suite quality</li>
<li>Critical code paths</li>
<li>Security-sensitive code</li>
<li>Core algorithms</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Every test (slow)</li>
<li>Simple tests</li>
<li>Learning phase</li>
<li>Every build</li>
</ul>
<p><strong>Recommendation</strong>: Use mutation testing:</p>
<ul>
<li>During development (spot check)</li>
<li>For critical code (ensure quality)</li>
<li>Occasionally in CI (weekly)</li>
<li>Not every build (too slow)</li>
</ul>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<ul>
<li>Small mutation set: 1-10 mutations (seconds)</li>
<li>Medium set: 10-100 mutations (minutes)</li>
<li>Large set: 100+ mutations (hours)</li>
</ul>
<p><strong>Recommendation</strong>: Limit to 20-50 mutations for regular testing.</p>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Focus on critical code</li>
<li>Test both success and error paths</li>
<li>Improve tests that miss mutations</li>
<li>Calculate mutation score</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Run mutation tests on every commit (slow)</li>
<li>Expect 100% mutation score (impossible)</li>
<li>Ignore missed mutations</li>
<li>Over-optimize for mutation score</li>
</ul>
<h2 id="common-mutations-to-check"><a class="header" href="#common-mutations-to-check">Common Mutations to Check</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mutation</th><th>What to Test</th></tr></thead><tbody>
<tr><td>RemoveKey</td><td>Verify required keys exist</td></tr>
<tr><td>AddKey</td><td>Verify exact set of keys</td></tr>
<tr><td>ChangeValue</td><td>Verify exact value, not just type</td></tr>
<tr><td>SwapValues</td><td>Verify values aren't accidentally swapped</td></tr>
<tr><td>ToggleBoolean</td><td>Verify both true and false cases</td></tr>
<tr><td>NumericDelta</td><td>Test boundary values and edge cases</td></tr>
<tr><td>StringCase</td><td>Verify case-sensitive comparisons</td></tr>
</tbody></table>
</div>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="mutation-not-caught"><a class="header" href="#mutation-not-caught">Mutation Not Caught</a></h3>
<p>Your test is too weak:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Weak - passes even with mutation
assert!(user.id &gt; 0);

// ‚úÖ Strong - catches changes
assert_eq!(user.id, 123);
<span class="boring">}</span></code></pre></pre>
<h3 id="mutation-score-unrealistic"><a class="header" href="#mutation-score-unrealistic">Mutation Score Unrealistic</a></h3>
<p>Adjust your mutations to match actual bugs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only test realistic mutations
tester.apply_mutation(MutationOperator::ChangeValue(...));

// Skip mutations that don't matter
// (e.g., changing comments, unused variables)
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<p>Learn snapshot testing: <a href="advanced/snapshot-testing.html">Snapshot Testing</a></p>
<hr />
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>Mutation testing:</p>
<ul>
<li>‚úÖ Validates test quality</li>
<li>‚úÖ Catches weak tests</li>
<li>‚úÖ Increases confidence</li>
<li>‚úÖ Target 80%+ score</li>
</ul>
<p>Use for critical code to ensure maximum quality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snapshot-testing-1"><a class="header" href="#snapshot-testing-1">Snapshot Testing</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Detect unintended changes with golden file comparisons</p>
</blockquote>
<p>Snapshot testing captures output on the first run and compares it on subsequent runs to detect unintended changes.</p>
<h2 id="why-snapshot-testing"><a class="header" href="#why-snapshot-testing">Why Snapshot Testing?</a></h2>
<p>Perfect for testing output that's complex but stable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Hard to maintain
let report = generate_report();
assert_eq!(report, "Employee Report\nAlice: ...\nBob: ...\n");  // 100 lines!

// ‚úÖ Easy to maintain with snapshots
assert_matches!(report, "employee_report");  // Stored in file
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<h3 id="first-run-create-snapshot"><a class="header" href="#first-run-create-snapshot">First Run: Create Snapshot</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_report, {
    let report = generate_report();
    assert_matches!(report, "report");  // Creates report.snap
    // report.snap contains the generated report
});
<span class="boring">}</span></code></pre></pre>
<h3 id="subsequent-runs-compare"><a class="header" href="#subsequent-runs-compare">Subsequent Runs: Compare</a></h3>
<p>If output changes:</p>
<ul>
<li>Old: <code>Employee Report\nAlice: 50000\n</code></li>
<li>New: <code>Employee Report\nAlice: 60000\n</code>  (salary changed)</li>
</ul>
<p>Test shows a <strong>diff</strong>:</p>
<pre><code>- Alice: 50000
+ Alice: 60000
</code></pre>
<p>You review and decide:</p>
<ul>
<li>‚úÖ Accept change (intentional update)</li>
<li>‚ùå Reject change (bug introduced)</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="string-snapshots"><a class="header" href="#string-snapshots">String Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_string_snapshot, {
    let output = "Hello, World!";
    assert_matches!(output, "greeting");
});
<span class="boring">}</span></code></pre></pre>
<p>File <code>greeting.snap</code> contains: <code>Hello, World!</code></p>
<h3 id="json-snapshots"><a class="header" href="#json-snapshots">JSON Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_json_snapshot, {
    let data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("age", "30")
        .build_json()?;

    assert_json_matches!(data, "user_data");
});
<span class="boring">}</span></code></pre></pre>
<p>File <code>user_data.snap</code> contains JSON:</p>
<pre><code class="language-json">{
  "name": "Alice",
  "age": "30"
}
</code></pre>
<h3 id="debug-snapshots"><a class="header" href="#debug-snapshots">Debug Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_debug_snapshot, {
    let user = User { id: 123, name: "Alice".to_string() };
    assert_debug_matches!(user, "user_debug");
});
<span class="boring">}</span></code></pre></pre>
<p>File <code>user_debug.snap</code> contains:</p>
<pre><code>User {
    id: 123,
    name: "Alice",
}
</code></pre>
<h2 id="real-world-example-api-response"><a class="header" href="#real-world-example-api-response">Real-World Example: API Response</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_api_response_snapshot, {
    let client = ApiClient::new();
    let response = client.get_users()?;

    // Snapshot the API response
    assert_json_matches!(response, "api_users_response");

    // If API adds fields, you'll see a diff
    // Review and accept if intentional
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-report-generation"><a class="header" href="#real-world-example-report-generation">Real-World Example: Report Generation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_report_snapshot, {
    let data = vec![
        Employee { name: "Alice".to_string(), salary: 50000 },
        Employee { name: "Bob".to_string(), salary: 60000 },
    ];

    let report = generate_report(&amp;data)?;

    // Snapshot the entire report
    assert_matches!(report, "employee_report");

    // Changes to formatting or content show up immediately
});
<span class="boring">}</span></code></pre></pre>
<h2 id="workflow-accepting-changes"><a class="header" href="#workflow-accepting-changes">Workflow: Accepting Changes</a></h2>
<p>When you intentionally change output:</p>
<h3 id="step-1-run-tests"><a class="header" href="#step-1-run-tests">Step 1: Run Tests</a></h3>
<pre><code class="language-bash">cargo test --features snapshot-testing
# Tests fail with diff if snapshot changed
</code></pre>
<h3 id="step-2-review-diff"><a class="header" href="#step-2-review-diff">Step 2: Review Diff</a></h3>
<pre><code>- Alice: 50000
+ Alice: 60000
</code></pre>
<h3 id="step-3-accept-or-reject"><a class="header" href="#step-3-accept-or-reject">Step 3: Accept or Reject</a></h3>
<pre><code class="language-bash"># Review snapshot changes
cargo insta review

# Or programmatically
insta::assert_snapshot!(output);  // Accepts in CI if --accept-all
</code></pre>
<h3 id="step-4-commit-changes"><a class="header" href="#step-4-commit-changes">Step 4: Commit Changes</a></h3>
<pre><code class="language-bash">git add snapshot.snap
git commit -m "Update snapshot for salary changes"
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="snapshot-paths"><a class="header" href="#snapshot-paths">Snapshot Paths</a></h3>
<p>Control where snapshots are stored:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_custom_path() {
    let settings = insta::Settings::clone_current();
    settings.set_snapshot_dir("tests/snapshots");
    settings.bind(|| {
        insta::assert_snapshot!("my_test", "output");
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshot-cleanup"><a class="header" href="#snapshot-cleanup">Snapshot Cleanup</a></h3>
<p>Remove old snapshots:</p>
<pre><code class="language-bash"># Remove unused snapshots
insta::cleanup_unused_snapshots!();
</code></pre>
<h2 id="snapshot-comparisons"><a class="header" href="#snapshot-comparisons">Snapshot Comparisons</a></h2>
<h3 id="inline-snapshots"><a class="header" href="#inline-snapshots">Inline Snapshots</a></h3>
<p>Store snapshot in test file (useful for small outputs):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_inline_snapshot, {
    let result = simple_function();
    insta::assert_snapshot!("simple_function", @"expected output");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="file-snapshots"><a class="header" href="#file-snapshots">File Snapshots</a></h3>
<p>Store snapshot in separate file (better for large outputs):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_file_snapshot, {
    let result = large_report();
    assert_matches!(result, "large_report");  // Stored in file
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use for stable, complex output</li>
<li>Review diffs carefully</li>
<li>Commit snapshot changes</li>
<li>Version control snapshots</li>
<li>Update when intentional changes occur</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use for simple outputs (too much overhead)</li>
<li>Use for non-deterministic output (timestamps, random data)</li>
<li>Blindly accept all changes</li>
<li>Skip reviewing diffs</li>
<li>Use for performance data (it changes)</li>
</ul>
<h2 id="when-to-use-snapshots"><a class="header" href="#when-to-use-snapshots">When to Use Snapshots</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>API responses</li>
<li>Generated reports</li>
<li>Formatted output</li>
<li>Complex data structures</li>
<li>UI/HTML output</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Simple assertions (<code>assert_eq!</code>)</li>
<li>Non-deterministic output</li>
<li>Performance metrics</li>
<li>Timestamps</li>
</ul>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Snapshots are fast:</p>
<ul>
<li>First run: Create snapshot (~1ms)</li>
<li>Subsequent runs: Compare (~1ms)</li>
</ul>
<p>No performance overhead.</p>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="snapshot-not-updating"><a class="header" href="#snapshot-not-updating">Snapshot Not Updating</a></h3>
<p>Check file permissions:</p>
<pre><code class="language-bash">ls -la tests/snapshots/
# Should be readable/writable
</code></pre>
<h3 id="snapshot-too-long"><a class="header" href="#snapshot-too-long">Snapshot Too Long</a></h3>
<p>Break into multiple snapshots:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå One large snapshot
assert_matches!(entire_report, "report");

// ‚úÖ Multiple focused snapshots
assert_matches!(report.header, "report_header");
assert_matches!(report.body, "report_body");
assert_matches!(report.footer, "report_footer");
<span class="boring">}</span></code></pre></pre>
<h3 id="non-deterministic-output"><a class="header" href="#non-deterministic-output">Non-Deterministic Output</a></h3>
<p>Normalize data before snapshotting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Timestamps change every run
let output = format!("Time: {}", now());
assert_matches!(output, "output");

// ‚úÖ Normalize timestamps
let output = "Time: [TIMESTAMP]";
assert_matches!(output, "output");
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-with-other-techniques"><a class="header" href="#combining-with-other-techniques">Combining with Other Techniques</a></h2>
<h3 id="snapshots--property-based-testing"><a class="header" href="#snapshots--property-based-testing">Snapshots + Property-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_snapshot_property, {
    let strategy = ProptestStrategy::new().with_cases(10);

    strategy.test(any::&lt;u32&gt;(), |num| {
        let formatted = format!("{}", num);
        let parsed: u32 = formatted.parse().unwrap();

        // Snapshot the first case
        if num == 1 {
            assert_matches!(formatted, "formatted_number");
        }

        num == parsed
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshots--fixtures"><a class="header" href="#snapshots--fixtures">Snapshots + Fixtures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_snapshot_fixture, {
    let fixture = TestFixture::new()?;
    let report = generate_report(&amp;fixture)?;
    assert_matches!(report, "fixture_report");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<p>Learn CLI testing: <a href="advanced/cli-testing.html">CLI Testing</a></p>
<hr />
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Snapshot testing:</p>
<ul>
<li>‚úÖ Captures complex output</li>
<li>‚úÖ Detects unintended changes</li>
<li>‚úÖ Easy to review diffs</li>
<li>‚úÖ Great for regression detection</li>
</ul>
<p>Perfect for generated output and API responses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-testing-1"><a class="header" href="#cli-testing-1">CLI Testing</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Test command-line interfaces with golden files</p>
</blockquote>
<p>Test command-line interfaces using golden files (<code>.trycmd</code>) to verify commands work correctly.</p>
<h2 id="why-cli-testing"><a class="header" href="#why-cli-testing">Why CLI Testing?</a></h2>
<p>CLIs are complex because they involve:</p>
<ul>
<li>Argument parsing</li>
<li>Environment variables</li>
<li>Output formatting</li>
<li>Exit codes</li>
<li>Error messages</li>
</ul>
<p>Golden file testing captures all of this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Golden file testing
test!(test_cli, {
    let output = run_command("myapp", vec!["list", "--verbose"]);
    assert_matches!(output, "cli_list_verbose");  // .trycmd file
});
<span class="boring">}</span></code></pre></pre>
<p>The <code>.trycmd</code> file contains:</p>
<pre><code>$ myapp list --verbose
stdout: Item 1
        Item 2
exit-code: 0
</code></pre>
<h2 id="basic-cli-testing"><a class="header" href="#basic-cli-testing">Basic CLI Testing</a></h2>
<h3 id="creating-a-test-command"><a class="header" href="#creating-a-test-command">Creating a Test Command</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::cli::*;

test!(test_cli_basic, {
    let output = CliTest::new("myapp", vec!["help"])
        .run()?;

    assert!(output.contains("Usage:"));
    assert!(output.contains("Options:"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-with-arguments"><a class="header" href="#testing-with-arguments">Testing with Arguments</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_with_args, {
    let output = CliTest::new("myapp", vec![
        "process",
        "--input", "data.txt",
        "--output", "result.txt",
        "--verbose"
    ]).run()?;

    assert!(output.contains("Processing"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-environment-variables"><a class="header" href="#testing-environment-variables">Testing Environment Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_with_env, {
    let output = CliTest::new("myapp", vec!["list"])
        .env("LOG_LEVEL", "DEBUG")
        .env("TIMEOUT", "30")
        .run()?;

    assert!(output.contains("DEBUG"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="golden-file-format-trycmd"><a class="header" href="#golden-file-format-trycmd">Golden File Format (.trycmd)</a></h2>
<p>Golden files store expected output:</p>
<pre><code>$ myapp list
Item 1
Item 2
Item 3

$ myapp list --filter active
Item 1
Item 3
</code></pre>
<h3 id="command-line"><a class="header" href="#command-line">Command Line</a></h3>
<pre><code>$ myapp [args]
</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><code>stdout:
Actual command output
Goes here

stderr:
Error output if applicable
</code></pre>
<h3 id="exit-code"><a class="header" href="#exit-code">Exit Code</a></h3>
<pre><code>exit-code: 0  (Success)
exit-code: 1  (Failure)
</code></pre>
<h2 id="real-world-example-file-tool"><a class="header" href="#real-world-example-file-tool">Real-World Example: File Tool</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_file_commands, {
    // List files
    let list_output = CliTest::new("filetool", vec!["list"])
        .run()?;
    assert!(list_output.contains("data.txt"));

    // Copy file
    let copy_output = CliTest::new("filetool", vec![
        "copy",
        "source.txt",
        "dest.txt"
    ]).run()?;
    assert!(copy_output.contains("Copied"));

    // Delete file
    let del_output = CliTest::new("filetool", vec![
        "delete",
        "old.txt"
    ]).run()?;
    assert!(del_output.contains("Deleted"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-configuration-tool"><a class="header" href="#real-world-example-configuration-tool">Real-World Example: Configuration Tool</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_config_commands, {
    // Get config
    let output = CliTest::new("config", vec!["get", "database.host"])
        .env("CONFIG_PATH", "./config.toml")
        .run()?;
    assert!(output.contains("localhost"));

    // Set config
    let output = CliTest::new("config", vec!["set", "database.port", "5433"])
        .env("CONFIG_PATH", "./config.toml")
        .run()?;
    assert!(output.contains("Updated"));

    // List all config
    let output = CliTest::new("config", vec!["list"])
        .run()?;
    assert!(output.contains("database.host"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-testing"><a class="header" href="#error-testing">Error Testing</a></h2>
<h3 id="command-failures"><a class="header" href="#command-failures">Command Failures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_errors, {
    // Wrong arguments
    let output = CliTest::new("myapp", vec!["invalid-command"])
        .run();

    assert!(output.is_err());  // Command failed
});
<span class="boring">}</span></code></pre></pre>
<h3 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_exit_codes, {
    // Success
    let result = CliTest::new("myapp", vec!["list"]).run()?;
    assert_eq!(result.exit_code, 0);

    // Failure
    let result = CliTest::new("myapp", vec!["error"]).run()?;
    assert_ne!(result.exit_code, 0);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="assertion-helpers"><a class="header" href="#assertion-helpers">Assertion Helpers</a></h2>
<h3 id="contains"><a class="header" href="#contains">Contains</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_contains, {
    let output = CliTest::new("myapp", vec!["help"]).run()?;
    assert!(output.contains("Usage:"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="matches-pattern"><a class="header" href="#matches-pattern">Matches Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_pattern, {
    let output = CliTest::new("myapp", vec!["version"]).run()?;
    assert!(output.contains("v1."));  // Matches v1.0, v1.1, etc.
});
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshot"><a class="header" href="#snapshot">Snapshot</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_snapshot, {
    let output = CliTest::new("myapp", vec!["help"]).run()?;
    assert_matches!(output, "myapp_help");  // Golden file
});
<span class="boring">}</span></code></pre></pre>
<h2 id="comprehensive-cli-test"><a class="header" href="#comprehensive-cli-test">Comprehensive CLI Test</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_comprehensive, {
    // Test 1: Help works
    let help = CliTest::new("mytool", vec!["help"]).run()?;
    assert!(help.contains("Usage:"));

    // Test 2: List works
    let list = CliTest::new("mytool", vec!["list"]).run()?;
    assert!(list.contains("Item"));

    // Test 3: Filter works
    let filtered = CliTest::new("mytool", vec![
        "list",
        "--filter", "active"
    ]).run()?;
    assert!(filtered.contains("Item 1"));

    // Test 4: Sort works
    let sorted = CliTest::new("mytool", vec![
        "list",
        "--sort", "name"
    ]).run()?;
    let lines: Vec&lt;_&gt; = sorted.lines().collect();
    assert!(lines.len() &gt;= 2);

    // Test 5: Output format
    let json = CliTest::new("mytool", vec![
        "list",
        "--format", "json"
    ]).run()?;
    assert!(json.contains("{"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test all major commands</li>
<li>Test error cases</li>
<li>Test environment variables</li>
<li>Test output format</li>
<li>Use golden files for complex output</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Hard-code full output (use snapshots)</li>
<li>Test implementation details</li>
<li>Ignore error exit codes</li>
<li>Use shell pipes in tests</li>
<li>Test external commands</li>
</ul>
<h2 id="when-to-use-cli-testing"><a class="header" href="#when-to-use-cli-testing">When to Use CLI Testing</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>CLI applications</li>
<li>Command subcommands</li>
<li>Argument parsing</li>
<li>Output formatting</li>
<li>Error messages</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Library functions (use unit tests)</li>
<li>Web services (use integration tests)</li>
<li>Complex pipelines (too fragile)</li>
</ul>
<h2 id="combining-with-other-techniques-1"><a class="header" href="#combining-with-other-techniques-1">Combining with Other Techniques</a></h2>
<h3 id="cli--snapshots"><a class="header" href="#cli--snapshots">CLI + Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_snapshot, {
    let output = CliTest::new("myapp", vec!["help"]).run()?;
    assert_matches!(output, "help_output");  // Snapshot
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cli--properties"><a class="header" href="#cli--properties">CLI + Properties</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_properties, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;String&gt;(), |cmd| {
        let output = CliTest::new("myapp", vec![&amp;cmd]).run();
        // Property: Command doesn't crash
        true  // If crashes, test fails
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="test-fails-with-different-output"><a class="header" href="#test-fails-with-different-output">Test Fails with Different Output</a></h3>
<p>Check for:</p>
<ul>
<li>Timestamps (use <code>[TIMESTAMP]</code>)</li>
<li>UUIDs (use <code>[UUID]</code>)</li>
<li>Paths (use relative paths)</li>
</ul>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command Not Found</a></h3>
<p>Ensure binary is built:</p>
<pre><code class="language-bash">cargo build --bin myapp
# Then tests can run it
</code></pre>
<h3 id="flaky-tests"><a class="header" href="#flaky-tests">Flaky Tests</a></h3>
<p>Normalize output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let output = CliTest::new("myapp", vec!["status"]).run()?;
let normalized = output.replace("2024-11-15", "[DATE]");
assert!(normalized.contains("Started on [DATE]"));
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<p>Learn concurrency testing: <a href="advanced/concurrency-testing.html">Concurrency Testing</a></p>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>CLI testing:</p>
<ul>
<li>‚úÖ Tests command-line interfaces</li>
<li>‚úÖ Uses golden files</li>
<li>‚úÖ Detects output changes</li>
<li>‚úÖ Verifies exit codes</li>
</ul>
<p>Perfect for CLI applications and scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-testing-1"><a class="header" href="#concurrency-testing-1">Concurrency Testing</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Test thread safety with deterministic thread ordering</p>
</blockquote>
<p>Test thread-safe code with deterministic thread ordering using loom.</p>
<h2 id="why-concurrency-testing"><a class="header" href="#why-concurrency-testing">Why Concurrency Testing?</a></h2>
<p>Normal tests run threads in random order - race conditions may not appear:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå This might pass or fail randomly
test!(test_race_condition, {
    let data = Arc::new(Mutex::new(0));
    let data_clone = data.clone();

    thread::spawn(move || {
        *data_clone.lock().unwrap() += 1;
    });

    thread::sleep(Duration::from_millis(1));
    let result = *data.lock().unwrap();
    assert_eq!(result, 1);  // Might fail if thread hasn't run yet
});
<span class="boring">}</span></code></pre></pre>
<p>Loom testing explores <strong>all possible interleavings</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ This tests all possible thread orderings
test!(test_with_loom, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));
        let data_clone = data.clone();

        thread::spawn(move || {
            *data_clone.lock().unwrap() += 1;
        });

        let result = *data.lock().unwrap();
        assert_eq!(result, 1);  // Tests all interleavings
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-loom-testing"><a class="header" href="#basic-loom-testing">Basic Loom Testing</a></h2>
<h3 id="simple-loom-model"><a class="header" href="#simple-loom-model">Simple Loom Model</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::concurrency::*;
use std::sync::{Arc, Mutex};

test!(test_basic_loom, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));
        let value = *data.lock().unwrap();
        assert_eq!(value, 0);
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="two-threads"><a class="header" href="#two-threads">Two Threads</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_two_threads, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));

        let data_clone = data.clone();
        thread::spawn(move || {
            *data_clone.lock().unwrap() += 1;
        });

        let result = *data.lock().unwrap();
        // Loom tests both possible interleavings:
        // 1. Main thread reads first (0)
        // 2. Worker thread increments first (1)
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-counter"><a class="header" href="#real-world-example-counter">Real-World Example: Counter</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_concurrent_counter, {
    loom::model(|| {
        let counter = Arc::new(Mutex::new(0));

        let mut handles = vec![];

        // Spawn 3 threads
        for _ in 0..3 {
            let counter = counter.clone();
            let handle = thread::spawn(move || {
                *counter.lock().unwrap() += 1;
            });
            handles.push(handle);
        }

        // Wait for all threads
        for handle in handles {
            handle.join().unwrap();
        }

        // All threads should have incremented
        assert_eq!(*counter.lock().unwrap(), 3);
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-channel-communication"><a class="header" href="#real-world-example-channel-communication">Real-World Example: Channel Communication</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_channel_communication, {
    loom::model(|| {
        let (tx, rx) = std::sync::mpsc::channel();

        thread::spawn(move || {
            tx.send(42).unwrap();
        });

        let value = rx.recv().unwrap();
        assert_eq!(value, 42);
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-concurrency-patterns"><a class="header" href="#common-concurrency-patterns">Common Concurrency Patterns</a></h2>
<h3 id="mutex-protection"><a class="header" href="#mutex-protection">Mutex Protection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_mutex_safety, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(vec![]));

        let data_clone = data.clone();
        thread::spawn(move || {
            data_clone.lock().unwrap().push(1);
        });

        data.lock().unwrap().push(2);
        let result = data.lock().unwrap();
        assert_eq!(result.len(), 2);
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="rwlock-reader-writer-lock"><a class="header" href="#rwlock-reader-writer-lock">RwLock (Reader-Writer Lock)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_rwlock, {
    loom::model(|| {
        let data = Arc::new(RwLock::new(0));

        let data_clone = data.clone();
        thread::spawn(move || {
            *data_clone.write().unwrap() = 42;
        });

        let value = *data.read().unwrap();
        assert_eq!(value, 42);
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="atomic-operations"><a class="header" href="#atomic-operations">Atomic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_atomic, {
    loom::model(|| {
        use std::sync::atomic::{AtomicU32, Ordering};

        let counter = Arc::new(AtomicU32::new(0));

        let counter_clone = counter.clone();
        thread::spawn(move || {
            counter_clone.fetch_add(1, Ordering::SeqCst);
        });

        let value = counter.load(Ordering::SeqCst);
        // Value might be 0 or 1 depending on scheduling
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="detecting-race-conditions"><a class="header" href="#detecting-race-conditions">Detecting Race Conditions</a></h2>
<h3 id="race-condition-example"><a class="header" href="#race-condition-example">Race Condition Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_detects_race_condition, {
    loom::model(|| {
        let data = Arc::new(Cell::new(0));  // ‚ùå Not thread-safe!

        let data_clone = data.clone();
        thread::spawn(move || {
            data_clone.set(data_clone.get() + 1);
        });

        // This will fail with loom!
        // Cell doesn't provide synchronization
    });
});
<span class="boring">}</span></code></pre></pre>
<p>Loom detects this because <code>Cell</code> isn't thread-safe.</p>
<h3 id="use-mutex-instead"><a class="header" href="#use-mutex-instead">Use Mutex Instead</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_thread_safe, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));  // ‚úÖ Thread-safe

        let data_clone = data.clone();
        thread::spawn(move || {
            *data_clone.lock().unwrap() += 1;
        });

        let result = *data.lock().unwrap();
        // Now safe for all interleavings
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-for-deadlocks"><a class="header" href="#testing-for-deadlocks">Testing for Deadlocks</a></h2>
<p>Loom can detect potential deadlocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_deadlock_detection, {
    loom::model(|| {
        let lock1 = Arc::new(Mutex::new(0));
        let lock2 = Arc::new(Mutex::new(0));

        let (lock1_clone, lock2_clone) = (lock1.clone(), lock2.clone());
        thread::spawn(move || {
            // Thread 1: Lock in order lock1, lock2
            let _g1 = lock1_clone.lock().unwrap();
            let _g2 = lock2_clone.lock().unwrap();
        });

        // Main thread: Lock in opposite order lock2, lock1
        // Loom will explore both interleavings
        // Can detect potential deadlock!
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test small, focused scenarios</li>
<li>Use appropriate synchronization primitives</li>
<li>Test with few threads (2-3 typical)</li>
<li>Verify all possible interleavings</li>
<li>Use Loom for critical concurrent code</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Test large thread pools (explodes combinations)</li>
<li>Mix blocking I/O with Loom (I/O not deterministic)</li>
<li>Over-test (Loom is slow, only use for critical code)</li>
<li>Assume one test covers all cases</li>
</ul>
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<p>Loom explores all interleavings - it's <strong>slow</strong>:</p>
<ul>
<li>Simple model (2 threads): 10ms - 100ms</li>
<li>Complex model (3 threads): 100ms - 1s</li>
<li>Many threads: Can be very slow</li>
</ul>
<p><strong>Recommendation</strong>:</p>
<ul>
<li>Only use Loom for critical synchronization</li>
<li>Test with 2-3 threads, not more</li>
<li>Use normal tests for non-concurrent code</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Loom only works with:</p>
<ul>
<li>Loom-aware primitives (<code>loom::sync</code>)</li>
<li>Thread creation (<code>loom::thread</code>)</li>
<li>Standard Rust types it instruments</li>
</ul>
<p>Cannot test:</p>
<ul>
<li>Real time (time is controlled)</li>
<li>System I/O (returns dummy values)</li>
<li>External libraries (unless they use loom)</li>
</ul>
<h2 id="combining-with-other-techniques-2"><a class="header" href="#combining-with-other-techniques-2">Combining with Other Techniques</a></h2>
<h3 id="concurrency--property-based"><a class="header" href="#concurrency--property-based">Concurrency + Property-Based</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_concurrent_property, {
    loom::model(|| {
        let counter = Arc::new(Mutex::new(0));

        for i in 0..5 {
            let counter = counter.clone();
            thread::spawn(move || {
                *counter.lock().unwrap() += i;
            });
        }

        // Verify invariant holds
        let sum: u32 = (0..5).sum();
        assert!(*counter.lock().unwrap() &lt;= sum);
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-integration-example-1"><a class="header" href="#real-world-integration-example-1">Real-World Integration Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_thread_pool_safety, {
    loom::model(|| {
        let task_queue = Arc::new(Mutex::new(vec![]));
        let result_queue = Arc::new(Mutex::new(vec![]));

        // Producer
        {
            let queue = task_queue.clone();
            thread::spawn(move || {
                queue.lock().unwrap().push("task1");
            });
        }

        // Consumer
        {
            let task_queue = task_queue.clone();
            let result_queue = result_queue.clone();
            thread::spawn(move || {
                if let Some(task) = task_queue.lock().unwrap().pop() {
                    result_queue.lock().unwrap().push(format!("done: {}", task));
                }
            });
        }

        // Verify result eventually
        // (Loom explores all orderings)
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="too-many-interleavings"><a class="header" href="#too-many-interleavings">"Too many interleavings"</a></h3>
<p>Reduce complexity:</p>
<ul>
<li>Use fewer threads</li>
<li>Smaller critical sections</li>
<li>Simpler synchronization patterns</li>
</ul>
<h3 id="this-synchronization-is-not-supported"><a class="header" href="#this-synchronization-is-not-supported">"This synchronization is not supported"</a></h3>
<p>Use only Loom-supported primitives:</p>
<ul>
<li><code>loom::sync::Mutex</code></li>
<li><code>loom::sync::RwLock</code></li>
<li><code>std::sync::atomic</code></li>
<li><code>std::sync::mpsc</code></li>
</ul>
<h3 id="test-still-hangsdeadlocks"><a class="header" href="#test-still-hangsdeadlocks">Test Still Hangs/Deadlocks</a></h3>
<p>Loom doesn't catch all deadlocks. Use timeouts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[timeout = "5s"]  // Add timeout
fn test_with_timeout() {
    loom::model(|| {
        // Test code
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<p>Learn the "Go the Extra Mile" pattern: <a href="advanced/../guides/extra-mile.html">Go the Extra Mile</a></p>
<hr />
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>Concurrency testing with Loom:</p>
<ul>
<li>‚úÖ Tests all possible thread interleavings</li>
<li>‚úÖ Detects race conditions</li>
<li>‚úÖ Verifies synchronization correctness</li>
<li>‚úÖ Finds potential deadlocks</li>
</ul>
<p>Use for critical concurrent code to ensure thread safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-go-the-extra-mile-pattern"><a class="header" href="#the-go-the-extra-mile-pattern">The "Go the Extra Mile" Pattern</a></h1>
<blockquote>
<p>üìñ <strong>EXPLANATION</strong> | Learn the three-idea framework for design decisions</p>
</blockquote>
<p>The "Go the Extra Mile" pattern demonstrates progressive enhancement from simple solutions to maximum-value solutions.</p>
<h2 id="the-three-ideas-framework"><a class="header" href="#the-three-ideas-framework">The Three Ideas Framework</a></h2>
<h3 id="1st-idea-solve-the-problem"><a class="header" href="#1st-idea-solve-the-problem">1st Idea: Solve the Problem</a></h3>
<p>Minimal scope, just solves the immediate need:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1st Idea: Parse u32 only
pub fn parse_u32(input: &amp;str) -&gt; Result&lt;u32, String&gt; {
    input.parse().map_err(|e| format!("Parse error: {e}"))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Single type (<code>u32</code> only)</li>
<li>No telemetry</li>
<li>No validation</li>
<li>Solves the problem ‚úì</li>
</ul>
<h3 id="2nd-idea-8020-sweet-spot"><a class="header" href="#2nd-idea-8020-sweet-spot">2nd Idea: 80/20 Sweet Spot</a></h3>
<p>Generic version with significant value added:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2nd Idea: Generic parser
pub fn parse_number&lt;T: FromStr&gt;(input: &amp;str) -&gt; Result&lt;T, String&gt;
where
    T::Err: Display,
{
    input.parse().map_err(|e| format!("Parse error: {e}"))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Works for all number types (<code>u32</code>, <code>i32</code>, <code>f64</code>, etc.)</li>
<li>Minimal additional effort</li>
<li>80% more value</li>
<li>20% more work</li>
</ul>
<p><strong>When to use</strong>: Most of the time (best cost/benefit ratio)</p>
<h3 id="3rd-idea-maximum-value"><a class="header" href="#3rd-idea-maximum-value">3rd Idea: Maximum Value</a></h3>
<p>Full-featured solution with complete correctness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd Idea: Type-validated with OTEL instrumentation
pub struct ValidatedNumber&lt;T&gt; {
    value: T,
    span: Span,  // OTEL instrumentation
}

impl&lt;T: FromStr&gt; ValidatedNumber&lt;T&gt; {
    pub fn parse(input: &amp;str, span_name: &amp;str) -&gt; Result&lt;Self, String&gt; {
        // Type-level validation prevents errors
        // OTEL spans provide observability
        // Weaver validation ensures compliance
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Type-level validation (prevents entire classes of errors)</li>
<li>OTEL instrumentation (observability)</li>
<li>Weaver validation (schema compliance)</li>
<li>Maximum value</li>
<li>Significant additional effort</li>
</ul>
<p><strong>When to use</strong>: For critical code where correctness is paramount</p>
<h2 id="decision-framework"><a class="header" href="#decision-framework">Decision Framework</a></h2>
<pre><code>Does the code need:
‚îú‚îÄ Basic functionality only?
‚îÇ  ‚îî‚îÄ 1st Idea ‚úì
‚îú‚îÄ Works for multiple types + some observability?
‚îÇ  ‚îî‚îÄ 2nd Idea ‚úì (usually best choice)
‚îî‚îÄ Type safety + full observability + validation?
   ‚îî‚îÄ 3rd Idea ‚úì (for critical paths)
</code></pre>
<h2 id="real-world-example-configuration-loader"><a class="header" href="#real-world-example-configuration-loader">Real-World Example: Configuration Loader</a></h2>
<h3 id="1st-idea-load-from-env"><a class="header" href="#1st-idea-load-from-env">1st Idea: Load from ENV</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_config() -&gt; Result&lt;Config, String&gt; {
    let host = std::env::var("DB_HOST")
        .map_err(|e| format!("Missing DB_HOST: {e}"))?;
    let port = std::env::var("DB_PORT")
        .map_err(|e| format!("Missing DB_PORT: {e}"))?
        .parse::&lt;u16&gt;()
        .map_err(|e| format!("Invalid port: {e}"))?;

    Ok(Config { host, port })
}
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Works
‚ùå Only ENV, no file support, no validation</p>
<h3 id="2nd-idea-env--file-support"><a class="header" href="#2nd-idea-env--file-support">2nd Idea: ENV + File Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_config(source: &amp;str) -&gt; Result&lt;Config, String&gt; {
    match source {
        "env" =&gt; load_from_env(),
        "file" =&gt; load_from_file(),
        _ =&gt; Err("Invalid source".to_string()),
    }
}

fn load_from_env() -&gt; Result&lt;Config, String&gt; { /* ... */ }
fn load_from_file() -&gt; Result&lt;Config, String&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Works for multiple sources
‚úÖ 80% more value (supports files, ENV)
‚úì Best choice for most cases</p>
<h3 id="3rd-idea-type-safe-with-validation--otel"><a class="header" href="#3rd-idea-type-safe-with-validation--otel">3rd Idea: Type-Safe with Validation + OTEL</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidatedConfig {
    config: Config,
    span: Span,  // OTEL span
}

impl ValidatedConfig {
    pub fn load(source: &amp;str, span_name: &amp;str) -&gt; Result&lt;Self, String&gt; {
        let start = SystemTime::now();

        // Load config
        let config = load_config(source)?;

        // Validate
        validate_config(&amp;config)?;

        // Create OTEL span
        let mut span = create_span(span_name);
        span.attributes.insert("source".to_string(), source.to_string());

        let end = SystemTime::now();
        span.complete(end.duration_since(start).ok()?)?;

        Ok(Self { config, span })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Type-safe configuration
‚úÖ OTEL instrumentation
‚úÖ Validation enforcement
‚úì For mission-critical systems</p>
<h2 id="applying-the-pattern-step-by-step"><a class="header" href="#applying-the-pattern-step-by-step">Applying the Pattern: Step by Step</a></h2>
<h3 id="step-1-start-simple"><a class="header" href="#step-1-start-simple">Step 1: Start Simple</a></h3>
<p>Write the simplest thing that works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_user(id: u32) -&gt; Result&lt;User, String&gt; {
    // Query database
    let user = query_db(id)?;
    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-consider-8020"><a class="header" href="#step-2-consider-8020">Step 2: Consider 80/20</a></h3>
<p>Does adding a feature provide disproportionate value?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2nd Idea: Support both ID and email lookup
pub fn get_user(identifier: &amp;str) -&gt; Result&lt;User, String&gt; {
    if let Ok(id) = identifier.parse::&lt;u32&gt;() {
        query_db_by_id(id)
    } else {
        query_db_by_email(identifier)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Cost: +10 lines
Value: 80% more functionality</p>
<h3 id="step-3-evaluate-going-further"><a class="header" href="#step-3-evaluate-going-further">Step 3: Evaluate Going Further</a></h3>
<p>Is maximum value worth the effort?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd Idea: Type-safe, validated, instrumented
pub struct ValidatedUser {
    user: User,
    span: Span,
}

impl ValidatedUser {
    pub fn get(identifier: &amp;str) -&gt; Result&lt;Self, String&gt; {
        // Validation + OTEL + error handling
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Cost: +50 lines
Value: Type safety + observability</p>
<p><strong>Decision</strong>: Only go to 3rd idea if the value justifies the effort.</p>
<h2 id="when-to-stop-at-1st-idea"><a class="header" href="#when-to-stop-at-1st-idea">When to Stop at 1st Idea</a></h2>
<p>‚úÖ For utilities that are:</p>
<ul>
<li>Well-isolated</li>
<li>Simple logic</li>
<li>Low risk</li>
<li>Rarely changed</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1st idea is fine here - simple utility
pub fn format_currency(amount: f64) -&gt; String {
    format!("${:.2}", amount)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-2nd-idea-most-common"><a class="header" href="#when-to-use-2nd-idea-most-common">When to Use 2nd Idea (Most Common)</a></h2>
<p>‚úÖ For code that is:</p>
<ul>
<li>Reused in multiple places</li>
<li>Needs flexibility</li>
<li>Not mission-critical</li>
<li>Has room for improvements</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2nd idea - generic, flexible, good value
pub fn parse&lt;T: FromStr&gt;(input: &amp;str) -&gt; Result&lt;T, String&gt; {
    input.parse().map_err(|e| format!("Parse error: {e}"))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-3rd-idea"><a class="header" href="#when-to-use-3rd-idea">When to Use 3rd Idea</a></h2>
<p>‚úÖ For code that is:</p>
<ul>
<li>Mission-critical (payments, security, core logic)</li>
<li>Needs full observability</li>
<li>Must prevent errors at compile time</li>
<li>Complex enough to benefit from type system</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd idea - type-safe, critical path
pub struct ValidatedPayment {
    amount: PositiveAmount,
    currency: ValidatedCurrency,
    span: Span,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-ideas-in-one-system"><a class="header" href="#combining-ideas-in-one-system">Combining Ideas in One System</a></h2>
<p>A production system uses all three:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1st Idea: Simple utilities
fn format_time(secs: u64) -&gt; String { /* simple */ }

// 2nd Idea: Core operations (most code)
fn parse_config(source: &amp;str) -&gt; Result&lt;Config, String&gt; { /* generic */ }

// 3rd Idea: Mission-critical operations
struct ValidatedPayment { /* type-safe, instrumented */ }
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits-of-this-pattern"><a class="header" href="#benefits-of-this-pattern">Benefits of This Pattern</a></h2>
<ol>
<li><strong>Clear thinking</strong>: Forces you to consider scope and value</li>
<li><strong>Cost-benefit</strong>: Justified effort for each level</li>
<li><strong>Flexibility</strong>: Easy to upgrade later</li>
<li><strong>Clarity</strong>: Team understands why certain code is complex</li>
</ol>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<p>‚ùå <strong>Always using 3rd idea</strong></p>
<ul>
<li>Over-engineered simple code</li>
<li>Too much complexity</li>
<li>Slower development</li>
</ul>
<p>‚úÖ <strong>Use appropriate idea level</strong></p>
<p>‚ùå <strong>Stuck at 1st idea</strong></p>
<ul>
<li>Limited by narrow scope</li>
<li>Duplicate code</li>
<li>Poor reusability</li>
</ul>
<p>‚úÖ <strong>Identify when 2nd idea helps</strong></p>
<p>‚ùå <strong>Skipping evaluation</strong></p>
<ul>
<li>Random complexity levels</li>
<li>Inconsistent codebase</li>
</ul>
<p>‚úÖ <strong>Evaluate intentionally</strong></p>
<h2 id="practical-checklist"><a class="header" href="#practical-checklist">Practical Checklist</a></h2>
<p>For each piece of code, ask:</p>
<ol>
<li>
<p><strong>Does 1st idea solve the problem?</strong></p>
<ul>
<li>If no ‚Üí Can't proceed</li>
<li>If yes ‚Üí Consider 2nd idea</li>
</ul>
</li>
<li>
<p><strong>Would 2nd idea add 80% value with 20% effort?</strong></p>
<ul>
<li>If no ‚Üí Stop at 1st idea</li>
<li>If yes ‚Üí Consider 2nd idea</li>
</ul>
</li>
<li>
<p><strong>Does 3rd idea add critical value?</strong></p>
<ul>
<li>If mission-critical ‚Üí Use 3rd idea</li>
<li>If improved but not critical ‚Üí Use 2nd idea</li>
<li>If over-engineering ‚Üí Use 1st or 2nd idea</li>
</ul>
</li>
</ol>
<h2 id="real-world-example-web-service"><a class="header" href="#real-world-example-web-service">Real-World Example: Web Service</a></h2>
<h3 id="get-user-endpoint"><a class="header" href="#get-user-endpoint">GET User Endpoint</a></h3>
<p>1st Idea (minimal):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_user(id: u32) -&gt; Result&lt;User, String&gt; {
    query_database(id)
}
<span class="boring">}</span></code></pre></pre>
<p>2nd Idea (flexible, instrumented):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_user(id: u32) -&gt; Result&lt;(User, Span), String&gt; {
    let span = create_span("get_user");
    let user = query_database(id)?;
    Ok((user, span))
}
<span class="boring">}</span></code></pre></pre>
<p>3rd Idea (type-safe, fully instrumented):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidatedUserResponse {
    user: ValidatedUser,
    span: Span,
}

impl ValidatedUserResponse {
    pub fn get(id: ValidUserId) -&gt; Result&lt;Self, String&gt; {
        // Type-safe, instrumented, validated
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Recommendation</strong>: Use 2nd idea for most endpoints. Only use 3rd for sensitive data (auth, payments).</p>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li><a href="guides/observability.html">Observability &amp; Quality</a> - Implement 2nd and 3rd ideas</li>
<li><a href="guides/real-world.html">Real-World Applications</a> - See complete examples</li>
</ul>
<hr />
<h2 id="summary-11"><a class="header" href="#summary-11">Summary</a></h2>
<p>The "Go the Extra Mile" pattern:</p>
<p><strong>1st Idea</strong>: Minimal, solves the problem
<strong>2nd Idea</strong>: 80% more value, 20% more effort (usually best)
<strong>3rd Idea</strong>: Maximum value, significant effort (for critical paths)</p>
<p>Use this framework to make intentional design decisions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observability--quality"><a class="header" href="#observability--quality">Observability &amp; Quality</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Add observability and measure quality</p>
</blockquote>
<p>Chicago TDD Tools provides comprehensive observability and quality measurement capabilities.</p>
<h2 id="quick-reference-observability-api"><a class="header" href="#quick-reference-observability-api">Quick Reference: Observability API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Purpose</th><th>Key Methods/Fields</th></tr></thead><tbody>
<tr><td><code>Span::new_active()</code></td><td>Create an OTEL span</td><td>Parameters: context, name, start_time, attributes, events, status</td></tr>
<tr><td><code>Span.attributes</code></td><td>Store span metadata</td><td><code>.insert(key, value)</code></td></tr>
<tr><td><code>Span.complete()</code></td><td>Finish span timing</td><td>Parameter: end_time</td></tr>
<tr><td><code>Span.status</code></td><td>Set result status</td><td>Variants: Ok, Error, Unknown</td></tr>
<tr><td><code>Span.validate()</code></td><td>Verify span correctness</td><td>Returns: <code>Result&lt;(), Error&gt;</code></td></tr>
<tr><td><code>Metric</code> struct</td><td>Track measurements</td><td>Fields: name, value, timestamp_ms, attributes</td></tr>
<tr><td><code>MetricValue</code> enum</td><td>Metric types</td><td>Variants: Counter, Gauge, Histogram</td></tr>
<tr><td><code>MetricValidator::new()</code></td><td>Validate metrics</td><td><code>.validate(&amp;metric)</code></td></tr>
<tr><td><code>WeaverValidator::check_weaver_available()</code></td><td>Check Weaver CLI</td><td>Returns: <code>Result&lt;(), Error&gt;</code></td></tr>
<tr><td><code>SpanValidator::new()</code></td><td>Validate span format</td><td><code>.validate(&amp;span)</code></td></tr>
</tbody></table>
</div>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Observability helps you understand what your code is doing:</p>
<ul>
<li><strong>OTEL Instrumentation</strong>: Track operations with spans and metrics</li>
<li><strong>Weaver Validation</strong>: Ensure telemetry matches semantic conventions</li>
<li><strong>Coverage Measurement</strong>: Verify test coverage</li>
<li><strong>Performance Tracking</strong>: Measure operation timing</li>
</ul>
<h2 id="otel-spans"><a class="header" href="#otel-spans">OTEL Spans</a></h2>
<p>OTEL (OpenTelemetry) spans track operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::otel::*;

test!(test_with_span, {
    let start_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    // Create a span
    let mut span = Span::new_active(
        SpanContext::root(TraceId(123), SpanId(456), 1),
        "parse_operation",
        start_time,
        BTreeMap::new(),
        Vec::new(),
        SpanStatus::Unset,
    );

    // Add attributes
    span.attributes.insert("input".to_string(), "42".to_string());

    // Do work
    let result = "42".parse::&lt;u32&gt;()?;

    // Complete span
    let end_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    span.complete(end_time)?;
    span.status = SpanStatus::Ok;

    // Span is now complete with timing
    assert_ok!(&amp;span.validate());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="otel-metrics"><a class="header" href="#otel-metrics">OTEL Metrics</a></h2>
<p>Track measurements over time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::otel::*;

test!(test_with_metric, {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    let mut metric = Metric {
        name: "requests_total".to_string(),
        value: MetricValue::Counter(42),
        timestamp_ms: timestamp,
        attributes: BTreeMap::new(),
    };

    metric.attributes.insert("endpoint".to_string(), "/api/users".to_string());
    metric.attributes.insert("status".to_string(), "success".to_string());

    // Validate metric
    let validator = MetricValidator::new();
    assert_ok!(&amp;validator.validate(&amp;metric));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="weaver-live-check"><a class="header" href="#weaver-live-check">Weaver Live-Check</a></h2>
<p>Validate telemetry against semantic conventions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_weaver_validation, {
    // Check if Weaver is available
    match WeaverValidator::check_weaver_available() {
        Ok(()) =&gt; {
            // Weaver is available
            // Can validate OTEL spans against semantic conventions
            alert_success!("Weaver available");
        }
        Err(e) =&gt; {
            alert_info!("Weaver not available: {}", e);
            alert_info!("Install with: cargo make weaver-bootstrap");
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="coverage-measurement"><a class="header" href="#coverage-measurement">Coverage Measurement</a></h2>
<p>Measure test coverage:</p>
<pre><code class="language-bash"># Run coverage
cargo make coverage

# Generate report
cargo make coverage-report
</code></pre>
<p>Coverage shows:</p>
<ul>
<li>Code coverage percentage</li>
<li>Covered lines</li>
<li>Uncovered lines</li>
<li>Branch coverage</li>
</ul>
<p><strong>Target</strong>: 80%+ coverage for critical code</p>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="otel-spans-1"><a class="header" href="#otel-spans-1">OTEL Spans</a></h3>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Add meaningful attributes</li>
<li>Track timing</li>
<li>Mark errors with SpanStatus</li>
<li>Propagate context between services</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Create spans for every operation (too noisy)</li>
<li>Include sensitive data in attributes</li>
<li>Forget to complete spans</li>
</ul>
<h3 id="weaver-validation"><a class="header" href="#weaver-validation">Weaver Validation</a></h3>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use semantic conventions</li>
<li>Validate telemetry early</li>
<li>Document telemetry schema</li>
<li>Keep conventions up-to-date</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use custom attribute names</li>
<li>Skip validation</li>
<li>Ignore schema mismatches</li>
</ul>
<h3 id="coverage"><a class="header" href="#coverage">Coverage</a></h3>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Aim for 80%+ coverage</li>
<li>Focus on critical paths</li>
<li>Test error paths (often uncovered)</li>
<li>Review coverage reports</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Obsess over 100% coverage</li>
<li>Ignore untested lines</li>
<li>Only focus on coverage number</li>
</ul>
<h2 id="combining-observability-with-testing"><a class="header" href="#combining-observability-with-testing">Combining Observability with Testing</a></h2>
<h3 id="otel--unit-tests"><a class="header" href="#otel--unit-tests">OTEL + Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_otel, {
    let span = create_test_span("my_operation");

    // Do work
    let result = my_function()?;

    // Verify behavior AND telemetry
    assert_ok!(&amp;result);
    span.validate()?;
    assert_eq!(span.status, SpanStatus::Ok);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics--property-based-testing"><a class="header" href="#metrics--property-based-testing">Metrics + Property-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_metrics, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;u32&gt;(), |num| {
        let timestamp = SystemTime::now()...;
        let mut metric = Metric {
            name: "parsing_attempts".to_string(),
            value: MetricValue::Counter(1),
            timestamp_ms: timestamp,
            attributes: BTreeMap::new(),
        };

        // Validate metric
        let validator = MetricValidator::new();
        validator.validate(&amp;metric).is_ok()
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-1"><a class="header" href="#real-world-example-1">Real-World Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_api_with_observability, {
    // Span for entire operation
    let mut operation_span = Span::new_active(
        SpanContext::root(TraceId(1), SpanId(1), 1),
        "api_request",
        start_time,
        BTreeMap::new(),
        Vec::new(),
        SpanStatus::Unset,
    );

    // Make API call
    let result = api_client.get_user(123)?;

    // Record metric
    let mut metric = Metric {
        name: "api_requests_total".to_string(),
        value: MetricValue::Counter(1),
        timestamp_ms: current_time,
        attributes: {
            let mut m = BTreeMap::new();
            m.insert("endpoint".to_string(), "/users".to_string());
            m.insert("status".to_string(), "success".to_string());
            m
        },
    };

    // Validate everything
    let span_validator = SpanValidator::new();
    assert_ok!(&amp;span_validator.validate(&amp;operation_span));

    let metric_validator = MetricValidator::new();
    assert_ok!(&amp;metric_validator.validate(&amp;metric));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="observability-checklist"><a class="header" href="#observability-checklist">Observability Checklist</a></h2>
<p>For production code:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Operations tracked with OTEL spans</li>
<li><input disabled="" type="checkbox"/>
Meaningful attributes on spans</li>
<li><input disabled="" type="checkbox"/>
Metrics for important measurements</li>
<li><input disabled="" type="checkbox"/>
Error cases marked in telemetry</li>
<li><input disabled="" type="checkbox"/>
Telemetry validates against conventions</li>
<li><input disabled="" type="checkbox"/>
80%+ test coverage</li>
<li><input disabled="" type="checkbox"/>
Error paths covered</li>
<li><input disabled="" type="checkbox"/>
Boundary conditions tested</li>
</ul>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<p>See how to combine observability with real applications: <a href="guides/real-world.html">Real-World Applications</a></p>
<hr />
<h2 id="summary-12"><a class="header" href="#summary-12">Summary</a></h2>
<p>Observability provides:</p>
<ul>
<li>‚úÖ OTEL spans for operation tracking</li>
<li>‚úÖ Metrics for measurements</li>
<li>‚úÖ Weaver validation for compliance</li>
<li>‚úÖ Coverage for test quality</li>
</ul>
<p>Combined with testing for complete confidence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otel-instrumentation"><a class="header" href="#otel-instrumentation">OTEL Instrumentation</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Add OpenTelemetry observability to code</p>
</blockquote>
<p>OpenTelemetry instrumentation provides observability into your operations.</p>
<h2 id="creating-spans"><a class="header" href="#creating-spans">Creating Spans</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::otel::*;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::BTreeMap;

test!(test_span_creation, {
    let start_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    let mut span = Span::new_active(
        SpanContext::root(TraceId(12345), SpanId(67890), 1),
        "parse_user_data",
        start_time,
        BTreeMap::new(),
        Vec::new(),
        SpanStatus::Unset,
    );

    // Add attributes
    span.attributes.insert("user_id".to_string(), "123".to_string());
    span.attributes.insert("operation".to_string(), "parse".to_string());

    // Complete span
    let end_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    span.complete(end_time)?;
    span.status = SpanStatus::Ok;

    assert_eq!(span.status, SpanStatus::Ok);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="span-status"><a class="header" href="#span-status">Span Status</a></h2>
<p>Mark success or error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Success
span.status = SpanStatus::Ok;

// Error
span.status = SpanStatus::Error;

// Unset
span.status = SpanStatus::Unset;
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-metrics"><a class="header" href="#creating-metrics">Creating Metrics</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_metric_creation, {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    let mut metric = Metric {
        name: "parsing_operations_total".to_string(),
        value: MetricValue::Counter(1),
        timestamp_ms: timestamp,
        attributes: BTreeMap::new(),
    };

    metric.attributes.insert("type".to_string(), "user".to_string());
    metric.attributes.insert("success".to_string(), "true".to_string());

    // Metric is ready to send to observability backend
    assert_eq!(metric.name, "parsing_operations_total");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="span-validation"><a class="header" href="#span-validation">Span Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_span_validation, {
    let span = create_valid_span()?;
    let validator = SpanValidator::new();
    
    assert_ok!(&amp;validator.validate(&amp;span));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use consistent span names</li>
<li>Add meaningful attributes</li>
<li>Track operation timing</li>
<li>Mark errors explicitly</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Include sensitive data in attributes</li>
<li>Create excessive spans</li>
<li>Forget timing information</li>
</ul>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<p><strong>Learn more:</strong></p>
<ul>
<li><a href="guides/weaver.html">Weaver Validation</a> - Validate telemetry against semantic conventions</li>
<li><a href="guides/observability.html">Observability &amp; Quality</a> - Full observability framework</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Observability patterns</li>
</ul>
<p><strong>Ready to instrument?</strong></p>
<ul>
<li>Add spans to your critical code paths</li>
<li>Include meaningful attributes for debugging</li>
<li>Validate spans with <code>SpanValidator</code></li>
<li>Combine with Weaver for compliance checking</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weaver-live-check-validation"><a class="header" href="#weaver-live-check-validation">Weaver Live-Check Validation</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Validate telemetry against semantic conventions</p>
</blockquote>
<p>Weaver validates telemetry against semantic conventions.</p>
<h2 id="what-is-weaver"><a class="header" href="#what-is-weaver">What is Weaver?</a></h2>
<p>Weaver ensures your OTEL telemetry complies with OpenTelemetry semantic conventions - the industry standard for attribute names and structure.</p>
<h2 id="checking-weaver-availability"><a class="header" href="#checking-weaver-availability">Checking Weaver Availability</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::observability::weaver::WeaverValidator;

test!(test_weaver_check, {
    match WeaverValidator::check_weaver_available() {
        Ok(()) =&gt; {
            alert_success!("Weaver is available");
            // Can validate telemetry
        }
        Err(e) =&gt; {
            alert_info!("Weaver not available: {}", e);
            // Install with: cargo make weaver-bootstrap
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="installing-weaver"><a class="header" href="#installing-weaver">Installing Weaver</a></h2>
<pre><code class="language-bash"># Bootstrap Weaver
cargo make weaver-bootstrap

# Run smoke test
cargo make weaver-smoke
</code></pre>
<h2 id="semantic-conventions"><a class="header" href="#semantic-conventions">Semantic Conventions</a></h2>
<p>Weaver checks that your attributes follow conventions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Correct - follows semantic conventions
let mut span = create_span("http.request");
span.attributes.insert("http.method".to_string(), "GET".to_string());
span.attributes.insert("http.target".to_string(), "/api/users".to_string());
span.attributes.insert("http.status_code".to_string(), "200".to_string());

// ‚ùå Wrong - custom attributes
span.attributes.insert("method".to_string(), "GET".to_string());
span.attributes.insert("endpoint".to_string(), "/api/users".to_string());
<span class="boring">}</span></code></pre></pre>
<h2 id="common-conventions"><a class="header" href="#common-conventions">Common Conventions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Format</th><th>Example</th></tr></thead><tbody>
<tr><td><code>http.method</code></td><td>HTTP method</td><td>GET, POST, PUT</td></tr>
<tr><td><code>http.status_code</code></td><td>Integer</td><td>200, 404, 500</td></tr>
<tr><td><code>http.target</code></td><td>Path</td><td>/api/users</td></tr>
<tr><td><code>db.system</code></td><td>Database type</td><td>mysql, postgresql</td></tr>
<tr><td><code>db.operation</code></td><td>SQL operation</td><td>SELECT, INSERT</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Follow semantic conventions</li>
<li>Validate with Weaver</li>
<li>Document telemetry schema</li>
<li>Keep conventions up-to-date</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use custom attribute names</li>
<li>Ignore Weaver validation</li>
<li>Duplicate information in attributes</li>
</ul>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="weaver-binary-not-found"><a class="header" href="#weaver-binary-not-found">Weaver Binary Not Found</a></h3>
<p>Install Weaver:</p>
<pre><code class="language-bash">cargo make weaver-bootstrap
</code></pre>
<h3 id="validation-fails"><a class="header" href="#validation-fails">Validation Fails</a></h3>
<p>Check attribute names against conventions:</p>
<pre><code class="language-bash"># See Weaver registry
cargo make weaver-smoke
</code></pre>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<p>Combine observability with testing: <a href="guides/observability.html">Observability &amp; Quality</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage--performance"><a class="header" href="#coverage--performance">Coverage &amp; Performance</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Measure test coverage and performance</p>
</blockquote>
<p>Measure test coverage and performance metrics.</p>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<p>Coverage shows which code is executed by tests:</p>
<pre><code class="language-bash"># Generate coverage report
cargo make coverage

# View coverage report
cargo make coverage-report
</code></pre>
<h3 id="coverage-metrics"><a class="header" href="#coverage-metrics">Coverage Metrics</a></h3>
<ul>
<li><strong>Line Coverage</strong>: % of lines executed</li>
<li><strong>Branch Coverage</strong>: % of branches executed</li>
<li><strong>Function Coverage</strong>: % of functions executed</li>
</ul>
<h3 id="target-coverage"><a class="header" href="#target-coverage">Target Coverage</a></h3>
<ul>
<li><strong>Minimum</strong>: 70% (warning level)</li>
<li><strong>Target</strong>: 80%+ (good)</li>
<li><strong>Excellent</strong>: 90%+ (very thorough)</li>
</ul>
<p>‚ùå Don't obsess over 100% (often impossible/impractical)</p>
<h3 id="improving-coverage"><a class="header" href="#improving-coverage">Improving Coverage</a></h3>
<p>Focus on uncovered lines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Uncovered error path
if let Err(e) = operation() {
    // This might not be tested
    log_error(e);
}

// ‚úÖ Test the error path too
test!(test_error_handling, {
    let result = risky_operation();
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p>Measure operation timing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(performance_test, {
    let start = std::time::Instant::now();

    // Code to benchmark
    for _ in 0..1000 {
        let _result = parse_number("42");
    }

    let elapsed = start.elapsed();
    println!("Time for 1000 parses: {:?}", elapsed);

    // Assert performance target
    assert!(elapsed.as_millis() &lt; 100);  // &lt; 100ms
});
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Target</th><th>Too Slow</th></tr></thead><tbody>
<tr><td>Parse number</td><td>&lt;1Œºs</td><td>&gt;10Œºs</td></tr>
<tr><td>Database query</td><td>&lt;10ms</td><td>&gt;100ms</td></tr>
<tr><td>API call</td><td>&lt;100ms</td><td>&gt;1s</td></tr>
<tr><td>Test execution</td><td>&lt;10ms</td><td>&gt;100ms</td></tr>
</tbody></table>
</div>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<pre><code class="language-bash"># Run performance tests
cargo make test-timings

# Profile with cargo flamegraph (if installed)
cargo flamegraph --test performance_tests
</code></pre>
<h2 id="combining-coverage-and-performance"><a class="header" href="#combining-coverage-and-performance">Combining Coverage and Performance</a></h2>
<p>Track both:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(comprehensive_test, {
    let start = std::time::Instant::now();

    // Success path (covered)
    let ok = parse_number("42");
    assert_ok!(&amp;ok);

    // Error path (covered)
    let err = parse_number("invalid");
    assert_err!(&amp;err);

    // Performance assertion
    let elapsed = start.elapsed();
    assert!(elapsed.as_millis() &lt; 10);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<p>‚úÖ <strong>Coverage:</strong></p>
<ul>
<li>Aim for 80%+ overall</li>
<li>Focus on critical paths</li>
<li>Test error cases</li>
<li>Review uncovered lines</li>
</ul>
<p>‚ùå <strong>Coverage:</strong></p>
<ul>
<li>Don't chase 100%</li>
<li>Don't test generated code</li>
<li>Don't test trivial code</li>
</ul>
<p>‚úÖ <strong>Performance:</strong></p>
<ul>
<li>Set realistic targets</li>
<li>Measure on target hardware</li>
<li>Profile before optimizing</li>
<li>Test under load</li>
</ul>
<p>‚ùå <strong>Performance:</strong></p>
<ul>
<li>Optimize prematurely</li>
<li>Ignore benchmarks</li>
<li>Assume fast</li>
<li>Measure on dev machine only</li>
</ul>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<p><strong>Learn more:</strong></p>
<ul>
<li><a href="guides/../advanced/mutation-testing.html">Mutation Testing</a> - Validate test quality beyond coverage</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Quality assurance patterns</li>
<li><a href="guides/observability.html">Observability</a> - Track real-world metrics</li>
</ul>
<p><strong>Ready to measure?</strong></p>
<ul>
<li>Run <code>cargo make coverage</code> to see current coverage</li>
<li>Identify uncovered error paths</li>
<li>Add tests for critical code paths</li>
<li>Set performance baselines with <code>cargo make test-timings</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-world-applications"><a class="header" href="#real-world-applications">Real-World Applications</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | See complete examples of Chicago TDD Tools in action</p>
</blockquote>
<p>See complete examples of Chicago TDD Tools in action.</p>
<h2 id="cli-application-example"><a class="header" href="#cli-application-example">CLI Application Example</a></h2>
<p>The playground includes a complete CLI tool with multiple commands.</p>
<h3 id="running-the-playground"><a class="header" href="#running-the-playground">Running the Playground</a></h3>
<pre><code class="language-bash"># Build the playground
cargo build --release -p playground

# Run CLI help
./target/release/playground help

# Run specific commands
./target/release/playground test --help
./target/release/playground quality --help
./target/release/playground obs --help
</code></pre>
<h3 id="playground-structure"><a class="header" href="#playground-structure">Playground Structure</a></h3>
<pre><code>playground/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs          # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs           # Library exports
‚îÇ   ‚îî‚îÄ‚îÄ cli/             # Subcommands
‚îÇ       ‚îú‚îÄ‚îÄ test.rs      # Testing commands
‚îÇ       ‚îú‚îÄ‚îÄ quality.rs   # Quality commands
‚îÇ       ‚îú‚îÄ‚îÄ obs.rs       # Observability commands
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ tests/               # Integration tests
    ‚îú‚îÄ‚îÄ core_tests.rs
    ‚îú‚îÄ‚îÄ testing_tests.rs
    ‚îî‚îÄ‚îÄ integration_tests.rs
</code></pre>
<h3 id="example-commands"><a class="header" href="#example-commands">Example Commands</a></h3>
<pre><code class="language-bash"># Test fixtures
playground test fixtures

# Run mutation tests
playground quality mutation

# Check OTEL compliance
playground obs validate

# Generate coverage
playground quality coverage
</code></pre>
<h2 id="example-based-learning"><a class="header" href="#example-based-learning">Example-Based Learning</a></h2>
<h3 id="example-basic_testrs"><a class="header" href="#example-basic_testrs">Example: basic_test.rs</a></h3>
<p>Demonstrates core patterns:</p>
<ul>
<li>Fixture creation</li>
<li>Data builders</li>
<li>Assertions</li>
<li>Error handling</li>
</ul>
<pre><code class="language-bash">cargo run --example basic_test
</code></pre>
<h3 id="example-property_testingrs"><a class="header" href="#example-property_testingrs">Example: property_testing.rs</a></h3>
<p>Property-based testing:</p>
<ul>
<li>Random data generation</li>
<li>Property verification</li>
<li>Shrinking failed cases</li>
</ul>
<pre><code class="language-bash">cargo run --example property_testing --features property-testing
</code></pre>
<h3 id="example-go_extra_milers"><a class="header" href="#example-go_extra_milers">Example: go_extra_mile.rs</a></h3>
<p>Progressive enhancement:</p>
<ul>
<li>1st idea (basic)</li>
<li>2nd idea (generic)</li>
<li>3rd idea (validated)</li>
</ul>
<pre><code class="language-bash">cargo run --example go_extra_mile --features otel,weaver
</code></pre>
<h2 id="integration-testing-patterns"><a class="header" href="#integration-testing-patterns">Integration Testing Patterns</a></h2>
<h3 id="with-docker-containers"><a class="header" href="#with-docker-containers">With Docker Containers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_docker_db, {
    // Requires Docker to be running
    let fixture = TestFixture::new()?;

    // Fixture provides Docker container support
    // (when testcontainers feature enabled)

    // Run test against real database
    let result = query_database(&amp;fixture)?;
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo make test-integration
</code></pre>
<h2 id="testing-workflows"><a class="header" href="#testing-workflows">Testing Workflows</a></h2>
<h3 id="quick-feedback-loop-5-seconds"><a class="header" href="#quick-feedback-loop-5-seconds">Quick Feedback Loop (5 seconds)</a></h3>
<pre><code class="language-bash"># Format + check + unit tests
cargo make pre-commit

# Then fix issues
</code></pre>
<h3 id="comprehensive-testing-1-2-minutes"><a class="header" href="#comprehensive-testing-1-2-minutes">Comprehensive Testing (1-2 minutes)</a></h3>
<pre><code class="language-bash"># Format + lint + all tests
cargo make test-all

# Includes integration tests (requires Docker)
</code></pre>
<h3 id="release-validation-5-10-minutes"><a class="header" href="#release-validation-5-10-minutes">Release Validation (5-10 minutes)</a></h3>
<pre><code class="language-bash"># Full validation before release
cargo make release-validate

# Includes:
# - All tests
# - Coverage
# - Mutation testing
# - Documentation
</code></pre>
<h2 id="architecture-patterns"><a class="header" href="#architecture-patterns">Architecture Patterns</a></h2>
<h3 id="fixture-based-setup"><a class="header" href="#fixture-based-setup">Fixture-Based Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_fixture, {
    // Arrange: Create isolated fixture
    let fixture = TestFixture::new()?;

    // Act: Use fixture in test
    let result = process(&amp;fixture)?;

    // Assert: Verify behavior
    assert_ok!(&amp;result);

    // Cleanup: Automatic (fixture dropped)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="builder-driven-test-data"><a class="header" href="#builder-driven-test-data">Builder-Driven Test Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_builders, {
    let user = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    let result = create_user(&amp;user)?;
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="property-based-coverage"><a class="header" href="#property-based-coverage">Property-Based Coverage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_property, {
    let strategy = ProptestStrategy::new().with_cases(1000);

    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| {
        a + b == b + a  // Commutativity
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-user-service"><a class="header" href="#complete-example-user-service">Complete Example: User Service</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(complete_user_service_test, {
    // Setup
    let fixture = TestFixture::new()?;

    // Create user with builder
    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act: Create
    let create_result = create_user(&amp;user_data)?;
    assert_ok!(&amp;create_result);
    let user = create_result.unwrap();

    // Act: Read
    let read_result = get_user(user.id)?;
    assert_ok!(&amp;read_result);
    assert_eq!(read_result.unwrap().name, "Alice");

    // Act: Update
    let mut updated = user.clone();
    updated.email = "alice.new@example.com".to_string();
    let update_result = update_user(&amp;updated)?;
    assert_ok!(&amp;update_result);

    // Act: Delete
    let delete_result = delete_user(user.id)?;
    assert_ok!(&amp;delete_result);

    // Verify deleted
    let read_result = get_user(user.id);
    assert_err!(&amp;read_result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-from-examples"><a class="header" href="#best-practices-from-examples">Best Practices from Examples</a></h2>
<p>‚úÖ <strong>From examples:</strong></p>
<ul>
<li>Clear Arrange-Act-Assert structure</li>
<li>Comprehensive error testing</li>
<li>Progressive complexity</li>
<li>Reusable patterns</li>
</ul>
<p>‚úÖ <strong>From playground:</strong></p>
<ul>
<li>Multiple testing techniques</li>
<li>Integration with Docker</li>
<li>CLI testing patterns</li>
<li>Quality metrics</li>
</ul>
<h2 id="next-steps-21"><a class="header" href="#next-steps-21">Next Steps</a></h2>
<p>Apply what you've learned:</p>
<ol>
<li>Start with <a href="guides/../core/README.html">Core Patterns</a></li>
<li>Add <a href="guides/../advanced/README.html">Advanced Techniques</a></li>
<li>Implement <a href="guides/observability.html">Observability</a></li>
<li>Follow <a href="guides/best-practices.html">Best Practices</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-cli-application"><a class="header" href="#building-a-cli-application">Building a CLI Application</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | Complete example of testing a CLI application</p>
</blockquote>
<p>Complete example of testing a CLI application with Chicago TDD Tools.</p>
<h2 id="project-structure-2"><a class="header" href="#project-structure-2">Project Structure</a></h2>
<pre><code>myapp/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs         # CLI entry point
‚îÇ   ‚îî‚îÄ‚îÄ commands/
‚îÇ       ‚îú‚îÄ‚îÄ list.rs     # List command
‚îÇ       ‚îú‚îÄ‚îÄ add.rs      # Add command
‚îÇ       ‚îî‚îÄ‚îÄ delete.rs   # Delete command
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ cli_tests.rs    # CLI integration tests
    ‚îî‚îÄ‚îÄ commands_tests.rs
</code></pre>
<h2 id="testing-cli-commands"><a class="header" href="#testing-cli-commands">Testing CLI Commands</a></h2>
<h3 id="example-list-command-test"><a class="header" href="#example-list-command-test">Example: List Command Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_list_command, {
    let output = CliTest::new("myapp", vec!["list"])
        .run()?;

    assert!(output.contains("Item"));
    assert!(output.exit_code == 0);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-add-command-test"><a class="header" href="#example-add-command-test">Example: Add Command Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_add_command, {
    let output = CliTest::new("myapp", vec![
        "add",
        "--name", "New Item",
        "--priority", "high"
    ]).run()?;

    assert!(output.contains("Added"));
    assert!(output.exit_code == 0);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-error-handling"><a class="header" href="#example-error-handling">Example: Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_invalid_command, {
    let result = CliTest::new("myapp", vec!["invalid"])
        .run();

    assert!(result.is_err());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-for-cli-testing"><a class="header" href="#best-practices-for-cli-testing">Best Practices for CLI Testing</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test all commands</li>
<li>Test argument combinations</li>
<li>Test error cases</li>
<li>Use snapshots for complex output</li>
<li>Test environment variables</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Hard-code full output</li>
<li>Test shell integration</li>
<li>Test external tools</li>
</ul>
<p>See: <a href="guides/../advanced/cli-testing.html">CLI Testing</a></p>
<h2 id="next-steps-22"><a class="header" href="#next-steps-22">Next Steps</a></h2>
<p><strong>Learn more:</strong></p>
<ul>
<li><a href="guides/../advanced/cli-testing.html">CLI Testing Guide</a> - Deep dive into trycmd patterns</li>
<li><a href="guides/best-practices.html">Best Practices</a> - CLI testing best practices</li>
<li><a href="guides/web-service.html">Web Service Testing</a> - Compare with testing web services</li>
</ul>
<p><strong>Ready to test?</strong></p>
<ul>
<li>Set up a new project with Chicago TDD Tools</li>
<li>Start with a simple command</li>
<li>Add tests as you build features</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-a-web-service"><a class="header" href="#testing-a-web-service">Testing a Web Service</a></h1>
<blockquote>
<p>üéì <strong>TUTORIAL</strong> | Complete example of testing a web service</p>
</blockquote>
<p>Complete example of testing a web service with Chicago TDD Tools.</p>
<h2 id="project-structure-3"><a class="header" href="#project-structure-3">Project Structure</a></h2>
<pre><code>myservice/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.rs
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ integration_tests.rs
    ‚îî‚îÄ‚îÄ api_tests.rs
</code></pre>
<h2 id="testing-endpoints"><a class="header" href="#testing-endpoints">Testing Endpoints</a></h2>
<h3 id="example-get-users"><a class="header" href="#example-get-users">Example: GET /users</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_get_users, {
    let client = TestClient::new()?;

    // Act
    let response = client.get("/users")?;

    // Assert
    assert_eq!(response.status, 200);
    let users: Vec&lt;User&gt; = response.json()?;
    assert!(!users.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-post-users"><a class="header" href="#example-post-users">Example: POST /users</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_create_user, {
    let client = TestClient::new()?;

    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act
    let response = client.post("/users", &amp;user_data)?;

    // Assert
    assert_eq!(response.status, 201);  // Created
    assert_ok!(&amp;response.json::&lt;User&gt;());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-error-cases"><a class="header" href="#example-error-cases">Example: Error Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_create_user_validation_error, {
    let client = TestClient::new()?;

    let invalid_data = TestDataBuilder::new()
        .with_var("email", "not_an_email")
        .build_json()?;

    // Act
    let response = client.post("/users", &amp;invalid_data)?;

    // Assert
    assert_eq!(response.status, 400);  // Bad request
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-real-database"><a class="header" href="#testing-with-real-database">Testing with Real Database</a></h2>
<p>Use integration tests with fixtures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_database, {
    let fixture = TestFixture::new()?;

    // Fixture provides database connection
    let db = fixture.db_connection();

    // Create user in database
    let user = db.create_user("Alice", "alice@example.com")?;

    // Test retrieval
    let retrieved = db.get_user(user.id)?;
    assert_eq!(retrieved.name, "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-authentication"><a class="header" href="#testing-authentication">Testing Authentication</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_auth_required, {
    let client = TestClient::new()?;

    // No authentication
    let response = client.get("/protected")?;
    assert_eq!(response.status, 401);  // Unauthorized

    // With authentication
    let token = client.login("alice", "password")?;
    let response = client.get_with_auth("/protected", &amp;token)?;
    assert_eq!(response.status, 200);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test with real database (in tests)</li>
<li>Test all HTTP methods (GET, POST, PUT, DELETE)</li>
<li>Test error cases (400, 401, 404, 500)</li>
<li>Test response structure</li>
<li>Use fixtures for isolation</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Mock the entire HTTP layer</li>
<li>Test framework code</li>
<li>Hard-code full responses</li>
</ul>
<h2 id="testing-workflow"><a class="header" href="#testing-workflow">Testing Workflow</a></h2>
<pre><code class="language-bash"># 1. Unit tests (fast)
cargo make test-unit

# 2. Integration tests (requires database)
cargo make test-integration

# 3. Full CI simulation
cargo make ci-local
</code></pre>
<p>See: <a href="guides/../advanced/README.html">Advanced Techniques</a></p>
<h2 id="next-steps-23"><a class="header" href="#next-steps-23">Next Steps</a></h2>
<p><strong>Learn more:</strong></p>
<ul>
<li><a href="guides/integration-docker.html">Integration Testing with Docker</a> - Test with real services</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Web service testing patterns</li>
<li><a href="guides/cli-application.html">CLI Application Testing</a> - Compare with CLI testing</li>
<li><a href="guides/observability.html">Observability</a> - Add OTEL instrumentation</li>
</ul>
<p><strong>Ready to build?</strong></p>
<ul>
<li>Create a simple REST API</li>
<li>Test each endpoint (GET, POST, PUT, DELETE)</li>
<li>Test error cases and authentication</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-testing-with-docker"><a class="header" href="#integration-testing-with-docker">Integration Testing with Docker</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Test with real services using Docker</p>
</blockquote>
<p>Test with real services using Docker containers.</p>
<h2 id="why-docker-for-testing"><a class="header" href="#why-docker-for-testing">Why Docker for Testing?</a></h2>
<p>Docker provides:</p>
<ul>
<li>Real service instances (not mocks)</li>
<li>Isolated test environment</li>
<li>Reproducible results</li>
<li>Easy cleanup</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<pre><code class="language-bash"># Ensure Docker is running
docker --version

# Enable testcontainers feature
[dev-dependencies]
chicago-tdd-tools = { version = "1.3", features = ["testcontainers"] }
</code></pre>
<h2 id="docker-compose-for-tests"><a class="header" href="#docker-compose-for-tests">Docker Compose for Tests</a></h2>
<p>Create <code>docker-compose.test.yml</code>:</p>
<pre><code class="language-yaml">version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: test_db
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
</code></pre>
<p>Run tests:</p>
<pre><code class="language-bash"># Start services
docker-compose -f docker-compose.test.yml up -d

# Run tests
cargo make test-integration

# Stop services
docker-compose -f docker-compose.test.yml down
</code></pre>
<h2 id="testing-with-database"><a class="header" href="#testing-with-database">Testing with Database</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_postgres, {
    // Fixture provides database connection
    let fixture = TestFixture::new()?;

    // Create test user
    fixture.db().create_user("alice", "alice@example.com")?;

    // Query database
    let user = fixture.db().get_user_by_email("alice@example.com")?;
    assert_eq!(user.name, "alice");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-redis"><a class="header" href="#testing-with-redis">Testing with Redis</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_redis, {
    let fixture = TestFixture::new()?;

    // Use Redis from fixture
    let cache = fixture.redis();

    // Set value
    cache.set("key", "value")?;

    // Get value
    let value = cache.get("key")?;
    assert_eq!(value, "value");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-integration-test"><a class="header" href="#complete-integration-test">Complete Integration Test</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(complete_integration_test, {
    let fixture = TestFixture::new()?;
    let db = fixture.db();
    let cache = fixture.redis();

    // 1. Create user in database
    let user = db.create_user("alice", "alice@example.com")?;

    // 2. Cache user
    cache.set(&amp;format!("user:{}", user.id), &amp;user.to_json())?;

    // 3. Verify database
    let retrieved = db.get_user(user.id)?;
    assert_eq!(retrieved.email, "alice@example.com");

    // 4. Verify cache
    let cached = cache.get(&amp;format!("user:{}", user.id))?;
    assert!(!cached.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-docker-failures"><a class="header" href="#handling-docker-failures">Handling Docker Failures</a></h2>
<p>If Docker is unavailable:</p>
<pre><code class="language-bash"># Skip integration tests
WEAVER_ALLOW_SKIP=1 cargo make test-unit

# Or just run unit tests
cargo test --lib
</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<p>Docker containers have overhead:</p>
<ul>
<li>Slow: 30-60 seconds per test</li>
<li>Solution: Batch related tests</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_db_operations_batch, {
    let fixture = TestFixture::new()?;

    // Test 1: Create
    let user = fixture.db().create_user("alice", "alice@example.com")?;
    assert_ok!(&amp;user);

    // Test 2: Read
    let retrieved = fixture.db().get_user(user.id)?;
    assert_ok!(&amp;retrieved);

    // Test 3: Update
    fixture.db().update_user(user.id, "new_email@example.com")?;
    let updated = fixture.db().get_user(user.id)?;
    assert_eq!(updated.email, "new_email@example.com");

    // Test 4: Delete
    fixture.db().delete_user(user.id)?;
    let result = fixture.db().get_user(user.id);
    assert_err!(&amp;result);

    // One test, multiple operations, one fixture overhead
});
<span class="boring">}</span></code></pre></pre>
<h2 id="cicd-pipeline"><a class="header" href="#cicd-pipeline">CI/CD Pipeline</a></h2>
<h3 id="github-actions-example"><a class="header" href="#github-actions-example">GitHub Actions Example</a></h3>
<pre><code class="language-yaml">name: Integration Tests

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: password
        options: --health-cmd pg_isready

    steps:
      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
      - run: cargo make test-integration
</code></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use Docker for real services</li>
<li>Batch related tests</li>
<li>Use fixtures for isolation</li>
<li>Clean up after tests</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Mock Docker services</li>
<li>Share containers between tests</li>
<li>Run Docker tests in CI for every commit</li>
<li>Forget about cleanup</li>
</ul>
<h2 id="troubleshooting-8"><a class="header" href="#troubleshooting-8">Troubleshooting</a></h2>
<h3 id="docker-daemon-not-running"><a class="header" href="#docker-daemon-not-running">"Docker daemon not running"</a></h3>
<p>Start Docker:</p>
<pre><code class="language-bash"># macOS
open /Applications/Docker.app

# Linux
sudo systemctl start docker

# Windows
Start Docker Desktop
</code></pre>
<h3 id="port-already-in-use"><a class="header" href="#port-already-in-use">"Port already in use"</a></h3>
<p>Check ports:</p>
<pre><code class="language-bash">docker ps  # See running containers
docker stop &lt;container&gt;
</code></pre>
<h3 id="tests-timeout"><a class="header" href="#tests-timeout">Tests Timeout</a></h3>
<p>Increase timeout:</p>
<pre><code class="language-bash">cargo test --lib -- --test-threads=1  # Sequential
</code></pre>
<h2 id="next-steps-24"><a class="header" href="#next-steps-24">Next Steps</a></h2>
<p>See: <a href="guides/best-practices.html">Best Practices</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices--migration"><a class="header" href="#best-practices--migration">Best Practices &amp; Migration</a></h1>
<blockquote>
<p>üîß <strong>HOW-TO</strong> | üìö <strong>REFERENCE</strong> | Proven patterns and migration strategies</p>
</blockquote>
<p>Proven patterns and migration strategies for Chicago TDD.</p>
<h2 id="testing-best-practices"><a class="header" href="#testing-best-practices">Testing Best Practices</a></h2>
<h3 id="1-write-tests-first-tdd"><a class="header" href="#1-write-tests-first-tdd">1. Write Tests First (TDD)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Write failing test
test!(test_parse_positive_number, {
    let result = parse_number("42");
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});

// 2. Implement minimal code
pub fn parse_number(input: &amp;str) -&gt; Result&lt;u32, String&gt; {
    input.parse().map_err(|e| format!("Parse failed: {e}"))
}

// 3. Refactor (improve design, remove duplication)
// 4. Test passes ‚úì
<span class="boring">}</span></code></pre></pre>
<h3 id="2-test-both-paths"><a class="header" href="#2-test-both-paths">2. Test Both Paths</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_complete_behavior, {
    // Success path
    assert_ok!(&amp;parse_number("42"));

    // Error path
    assert_err!(&amp;parse_number("invalid"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="3-focus-on-error-cases"><a class="header" href="#3-focus-on-error-cases">3. Focus on Error Cases</a></h3>
<p>80% of bugs hide in error paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_cases, {
    // Test invalid input
    assert_err!(&amp;parse_number(""));
    assert_err!(&amp;parse_number("not_a_number"));
    assert_err!(&amp;parse_number("-1"));  // If negative not allowed

    // Test boundaries
    assert_ok!(&amp;parse_number("0"));
    assert_ok!(&amp;parse_number("4294967295"));  // u32::MAX
});
<span class="boring">}</span></code></pre></pre>
<h3 id="4-keep-tests-focused"><a class="header" href="#4-keep-tests-focused">4. Keep Tests Focused</a></h3>
<p>One test per behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Focused
test!(test_parse_valid_number, {
    let result = parse_number("42");
    assert_ok!(&amp;result);
});

test!(test_parse_invalid_number, {
    let result = parse_number("invalid");
    assert_err!(&amp;result);
});

// ‚ùå Too many behaviors
test!(test_parsing, {
    // Tests both valid and invalid
    // Hard to know what failed
});
<span class="boring">}</span></code></pre></pre>
<h3 id="5-use-descriptive-names"><a class="header" href="#5-use-descriptive-names">5. Use Descriptive Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Clear intent
test!(test_parse_handles_negative_numbers_gracefully, { /* */ });

// ‚ùå Vague
test!(test_parse, { /* */ });
<span class="boring">}</span></code></pre></pre>
<h2 id="organization-best-practices"><a class="header" href="#organization-best-practices">Organization Best Practices</a></h2>
<h3 id="1-mirror-source-structure"><a class="header" href="#1-mirror-source-structure">1. Mirror Source Structure</a></h3>
<pre><code>src/
‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îî‚îÄ‚îÄ service.rs
‚îî‚îÄ‚îÄ orders/
    ‚îî‚îÄ‚îÄ service.rs

tests/
‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îî‚îÄ‚îÄ service_tests.rs
‚îî‚îÄ‚îÄ orders/
    ‚îî‚îÄ‚îÄ service_tests.rs
</code></pre>
<h3 id="2-shared-utilities"><a class="header" href="#2-shared-utilities">2. Shared Utilities</a></h3>
<pre><code>tests/
‚îú‚îÄ‚îÄ common.rs           # Shared utilities
‚îú‚îÄ‚îÄ users_tests.rs
‚îî‚îÄ‚îÄ orders_tests.rs
</code></pre>
<p>In <code>common.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_test_user() -&gt; Result&lt;User, String&gt; {
    TestDataBuilder::new()
        .with_var("name", "Test User")
        .build_json()?
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-fixture-factory-pattern"><a class="header" href="#3-fixture-factory-pattern">3. Fixture Factory Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_database_fixture() -&gt; Result&lt;TestFixture, String&gt; {
    let fixture = TestFixture::new()?;
    // Additional setup
    Ok(fixture)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-best-practices"><a class="header" href="#performance-best-practices">Performance Best Practices</a></h2>
<h3 id="1-isolate-slow-tests"><a class="header" href="#1-isolate-slow-tests">1. Isolate Slow Tests</a></h3>
<p>Mark slow tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ignore]  // Run with --ignored flag
test!(slow_integration_test, {
    // Takes 10 seconds
});
<span class="boring">}</span></code></pre></pre>
<p>Run separately:</p>
<pre><code class="language-bash">cargo test --ignored  # Only slow tests
</code></pre>
<h3 id="2-parallel-execution"><a class="header" href="#2-parallel-execution">2. Parallel Execution</a></h3>
<p>Tests run in parallel by default:</p>
<pre><code class="language-bash">cargo test -- --test-threads=4  # 4 threads (default: CPU count)
cargo test -- --test-threads=1  # Sequential (slow, for debugging)
</code></pre>
<h3 id="3-cache-expensive-operations"><a class="header" href="#3-cache-expensive-operations">3. Cache Expensive Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_expensive_setup, {
    // Reuse expensive setup
    lazy_static::lazy_static! {
        static ref EXPENSIVE_DATA: Data = { /* expensive */ };
    }

    // Use cached data
    assert_ok!(&amp;process(&amp;EXPENSIVE_DATA));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-from-traditional-testing"><a class="header" href="#migration-from-traditional-testing">Migration from Traditional Testing</a></h2>
<h3 id="from-no-tests--to-core-tests"><a class="header" href="#from-no-tests--to-core-tests">From: No Tests ‚Üí To: Core Tests</a></h3>
<ol>
<li>Start with core patterns (fixtures, builders, assertions)</li>
<li>Test public APIs</li>
<li>Focus on error cases</li>
<li>Gradually increase coverage</li>
</ol>
<h3 id="from-mocks--to-real-dependencies"><a class="header" href="#from-mocks--to-real-dependencies">From: Mocks ‚Üí To: Real Dependencies</a></h3>
<ol>
<li>Replace mocks with real implementations</li>
<li>Use fixtures for isolation</li>
<li>Only mock external services (APIs, DBs)</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: Mock-heavy
let mock_db = MockDatabase::new();
let result = process(&amp;mock_db);

// After: Real implementations
let fixture = TestFixture::new()?;
let result = process(&amp;fixture)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="from-global-state--to-fixtures"><a class="header" href="#from-global-state--to-fixtures">From: Global State ‚Üí To: Fixtures</a></h3>
<ol>
<li>Remove global state</li>
<li>Create fixtures for test isolation</li>
<li>Pass fixtures as parameters</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: Global
static mut TEST_DATA: Option&lt;Data&gt; = None;

// After: Fixture-based
test!(test_with_data, {
    let fixture = TestFixture::new()?;
    // Use fixture
});
<span class="boring">}</span></code></pre></pre>
<h3 id="from-100-coverage--to-80--error-paths"><a class="header" href="#from-100-coverage--to-80--error-paths">From: 100% Coverage ‚Üí To: 80% + Error Paths</a></h3>
<ol>
<li>Stop obsessing over coverage</li>
<li>Focus on critical paths</li>
<li>Test error cases thoroughly</li>
</ol>
<h2 id="common-pitfalls--solutions"><a class="header" href="#common-pitfalls--solutions">Common Pitfalls &amp; Solutions</a></h2>
<h3 id="pitfall-1-tests-coupled-to-implementation"><a class="header" href="#pitfall-1-tests-coupled-to-implementation">Pitfall 1: Tests Coupled to Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Brittle - depends on internal structure
test!(test_struct_format, {
    let user = create_user();
    assert_eq!(format!("{:?}", user), "User { id: 123, ... }");
});

// ‚úÖ Robust - tests behavior
test!(test_user_creation, {
    let user = create_user();
    assert_eq!(user.id, 123);
    assert_eq!(user.name, "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-2-flaky-tests"><a class="header" href="#pitfall-2-flaky-tests">Pitfall 2: Flaky Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Flaky - depends on time
test!(test_timing_dependent, {
    let start = Instant::now();
    operation();
    assert!(start.elapsed() &lt; Duration::from_secs(1));  // Unreliable
});

// ‚úÖ Reliable - deterministic
test!(test_result_correct, {
    let result = operation();
    assert_eq!(result, expected);  // Same result every time
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-3-test-interdependencies"><a class="header" href="#pitfall-3-test-interdependencies">Pitfall 3: Test Interdependencies</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Tests depend on order
test!(test_1_setup, { /* setup */ });
test!(test_2_use_setup_from_1, { /* depends on test_1 */ });

// ‚úÖ Each test is independent
test!(test_setup, {
    let fixture = TestFixture::new()?;
    // setup complete
});

test!(test_use, {
    let fixture = TestFixture::new()?;
    // independent
});
<span class="boring">}</span></code></pre></pre>
<h2 id="quality-checklist"><a class="header" href="#quality-checklist">Quality Checklist</a></h2>
<p>For each test, verify:</p>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>AAA Pattern</strong>: Arrange, Act, Assert clearly separated</li>
<li><input disabled="" type="checkbox"/>
<strong>Isolation</strong>: No dependencies on other tests</li>
<li><input disabled="" type="checkbox"/>
<strong>Error Paths</strong>: Tests both success and failure</li>
<li><input disabled="" type="checkbox"/>
<strong>Clear Name</strong>: Describes what's being tested</li>
<li><input disabled="" type="checkbox"/>
<strong>One Assertion</strong>: Focused on one behavior</li>
<li><input disabled="" type="checkbox"/>
<strong>Deterministic</strong>: Same result every run</li>
<li><input disabled="" type="checkbox"/>
<strong>Fast</strong>: &lt;100ms per test (unless integration)</li>
</ul>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="pre-commit"><a class="header" href="#pre-commit">Pre-Commit</a></h3>
<pre><code class="language-bash">cargo make pre-commit  # Format + lint + unit tests
</code></pre>
<h3 id="before-push"><a class="header" href="#before-push">Before Push</a></h3>
<pre><code class="language-bash">cargo make ci-local    # Simulate full CI pipeline
</code></pre>
<h3 id="in-ci"><a class="header" href="#in-ci">In CI</a></h3>
<pre><code class="language-bash">cargo make test-all    # All tests including integration
</code></pre>
<h2 id="graduation-path"><a class="header" href="#graduation-path">Graduation Path</a></h2>
<pre><code>Learning
  ‚Üì
Core Patterns (fixtures, builders, assertions)
  ‚Üì
Error Path Testing
  ‚Üì
Advanced Techniques (properties, mutations, snapshots)
  ‚Üì
Observability (OTEL, Weaver)
  ‚Üì
Expert
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="guides/../core/README.html">Core Patterns</a></li>
<li><a href="guides/../advanced/README.html">Advanced Techniques</a></li>
<li><a href="guides/real-world.html">Real-World Examples</a></li>
<li><a href="guides/../../cookbook/README.html">Pattern Cookbook</a></li>
<li><a href="https://docs.rs/chicago-tdd-tools/">API Reference</a></li>
</ul>
<h2 id="next-steps-25"><a class="header" href="#next-steps-25">Next Steps</a></h2>
<ol>
<li>Pick a project to refactor</li>
<li>Start with core patterns</li>
<li>Add tests incrementally</li>
<li>Build confidence with error paths</li>
<li>Add advanced techniques where beneficial</li>
</ol>
<hr />
<p><strong>Chicago TDD Tools</strong>: Testing with confidence, errors prevented at compile time.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
