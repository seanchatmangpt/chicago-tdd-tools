<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chicago TDD Tools - Application Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Practical applications and real-world usage patterns">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chicago TDD Tools - Application Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chicago-tdd-tools---application-guide"><a class="header" href="#chicago-tdd-tools---application-guide">Chicago TDD Tools - Application Guide</a></h1>
<p>Welcome to the practical application guide for Chicago TDD Tools! This guide focuses on <strong>real-world usage patterns</strong> and practical techniques for testing Rust applications.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>This guide covers:</p>
<ul>
<li><strong>Core Patterns</strong>: Fixtures, data builders, assertions, and error path testing</li>
<li><strong>Advanced Techniques</strong>: Property-based testing, mutation testing, snapshot testing, CLI testing, and concurrency testing</li>
<li><strong>Progressive Enhancement</strong>: The "Go the Extra Mile" pattern for designing increasingly valuable solutions</li>
<li><strong>Observability</strong>: OTEL instrumentation and Weaver live-check validation</li>
<li><strong>Real-World Applications</strong>: Complete examples of testing CLI tools, web services, and integration scenarios</li>
<li><strong>Best Practices</strong>: Proven patterns and migration strategies</li>
</ul>
<h2 id="who-this-guide-is-for"><a class="header" href="#who-this-guide-is-for">Who This Guide Is For</a></h2>
<ul>
<li>Developers writing Rust applications and want comprehensive testing</li>
<li>Teams adopting Chicago-style (Classicist) TDD practices</li>
<li>Engineers improving test quality and catching bugs earlier</li>
<li>Anyone learning advanced testing techniques in Rust</li>
</ul>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to Use This Guide</a></h2>
<ol>
<li><strong>Start with the Introduction</strong> to understand Chicago TDD principles</li>
<li><strong>Learn Core Patterns</strong> for everyday testing scenarios</li>
<li><strong>Explore Advanced Techniques</strong> for specific testing challenges</li>
<li><strong>Study Real-World Applications</strong> to see complete examples</li>
<li><strong>Apply Best Practices</strong> to improve your testing approach</li>
</ol>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="../cookbook/README.html">Pattern Cookbook</a> - Alexander-style patterns reference</li>
<li><a href="https://docs.rs/chicago-tdd-tools/">API Reference</a> - Complete API documentation</li>
<li><a href="https://github.com/seanchatmangpt/chicago-tdd-tools">GitHub Repository</a></li>
</ul>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="chicago-style-tdd-classicist"><a class="header" href="#chicago-style-tdd-classicist">Chicago-Style TDD (Classicist)</a></h3>
<p>Chicago TDD emphasizes:</p>
<ul>
<li><strong>Type Safety</strong>: Use Rust's type system to prevent errors at compile time</li>
<li><strong>Real Dependencies</strong>: Test with actual implementations, not mocks</li>
<li><strong>Error Prevention</strong>: Poka-yoke design prevents mistakes before they happen</li>
<li><strong>Quality by Default</strong>: Quality is the default, not an afterthought</li>
</ul>
<h3 id="the-8020-principle"><a class="header" href="#the-8020-principle">The 80/20 Principle</a></h3>
<p>The "second idea" typically provides 80% more value with only 20% more effort. Learn when to:</p>
<ul>
<li>Keep it simple (1st idea)</li>
<li>Apply the sweet spot (2nd idea)</li>
<li>Go all-in (3rd idea)</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="install-chicago-tdd-tools"><a class="header" href="#install-chicago-tdd-tools">Install Chicago TDD Tools</a></h3>
<pre><code class="language-toml">[dev-dependencies]
chicago-tdd-tools = { version = "1.3", features = ["testing-extras"] }
</code></pre>
<h3 id="run-examples"><a class="header" href="#run-examples">Run Examples</a></h3>
<pre><code class="language-bash"># Run basic example
cargo run --example basic_test

# Run property-based testing
cargo run --example property_testing --features property-testing

# Run mutation testing
cargo run --example mutation_testing

# Run all examples
cargo run --example go_extra_mile
</code></pre>
<h3 id="build-this-guide"><a class="header" href="#build-this-guide">Build This Guide</a></h3>
<pre><code class="language-bash"># Install mdbook if you haven't already
cargo install mdbook

# Build and serve the guide
cd application-guide
mdbook serve
</code></pre>
<p>Then visit <code>http://localhost:3000</code> in your browser.</p>
<h2 id="example-basic-test-structure"><a class="header" href="#example-basic-test-structure">Example: Basic Test Structure</a></h2>
<p>All tests follow the <strong>AAA Pattern</strong> (Arrange-Act-Assert):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(my_test, {
    // Arrange: Set up test data
    let input = 5;

    // Act: Execute the code under test
    let result = input * 2;

    // Assert: Verify the result
    assert_eq!(result, 10);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="introduction.html">Introduction</a> - Chicago TDD philosophy and principles</li>
<li><a href="core/README.html">Core Testing Patterns</a> - Everyday testing with fixtures and builders</li>
<li><a href="advanced/README.html">Advanced Techniques</a> - Specialized testing for complex scenarios</li>
<li><a href="guides/extra-mile.html">Go the Extra Mile</a> - Progressive enhancement pattern</li>
<li><a href="guides/observability.html">Observability &amp; Quality</a> - Telemetry and quality assurance</li>
<li><a href="guides/real-world.html">Real-World Applications</a> - Complete practical examples</li>
<li><a href="guides/best-practices.html">Best Practices</a> - Proven patterns and patterns to avoid</li>
</ol>
<h2 id="featured-examples"><a class="header" href="#featured-examples">Featured Examples</a></h2>
<h3 id="from-examples-directory"><a class="header" href="#from-examples-directory">From Examples Directory</a></h3>
<ul>
<li><strong>basic_test.rs</strong> - Getting started with fixtures and data builders</li>
<li><strong>property_testing.rs</strong> - Property-based testing with proptest</li>
<li><strong>mutation_testing.rs</strong> - Validating test quality</li>
<li><strong>go_extra_mile.rs</strong> - Progressive enhancement patterns</li>
<li><strong>cli_testing.rs</strong> - Testing command-line interfaces</li>
<li><strong>snapshot_testing.rs</strong> - Golden file testing</li>
<li><strong>concurrency_testing.rs</strong> - Thread-safe testing with loom</li>
</ul>
<h3 id="from-playground"><a class="header" href="#from-playground">From Playground</a></h3>
<ul>
<li><strong>CLI tool</strong> with comprehensive sub-commands</li>
<li><strong>Integration tests</strong> with Docker containers</li>
<li><strong>Quality validation</strong> with coverage and performance metrics</li>
<li><strong>OTEL/Weaver</strong> observability examples</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>üëâ <strong>Start here</strong>: <a href="introduction.html">Introduction</a></p>
<h2 id="community--support"><a class="header" href="#community--support">Community &amp; Support</a></h2>
<ul>
<li>GitHub Issues: Report bugs or request features</li>
<li>Discussions: Share ideas and patterns with the community</li>
<li>Pattern Cookbook: Contribute Alexander-style patterns</li>
</ul>
<hr />
<p><strong>Chicago TDD Tools</strong> - Testing with confidence, errors prevented at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-chicago-tdd-philosophy"><a class="header" href="#introduction-chicago-tdd-philosophy">Introduction: Chicago TDD Philosophy</a></h1>
<h2 id="what-is-chicago-style-tdd"><a class="header" href="#what-is-chicago-style-tdd">What is Chicago-Style TDD?</a></h2>
<p>Chicago-style TDD (also called "Classicist" TDD) is a testing approach that emphasizes:</p>
<ol>
<li><strong>Type Safety First</strong> - Use Rust's type system to prevent entire categories of errors</li>
<li><strong>Real Dependencies</strong> - Test with actual implementations, not mocks</li>
<li><strong>Error Prevention</strong> - Mistakes are prevented at compile time, not caught at runtime</li>
<li><strong>Quality by Default</strong> - Quality is the default state; prevention beats detection</li>
</ol>
<p>This contrasts with London-style TDD, which uses mocks and message-passing verification.</p>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<h3 id="1-poka-yoke-design"><a class="header" href="#1-poka-yoke-design">1. Poka-Yoke Design</a></h3>
<p>"Poka-yoke" (fool-proofing) means designing systems to prevent mistakes before they happen.</p>
<p><strong>Example</strong>: Instead of writing a test to catch <code>panic!()</code> usage, the compiler enforces that production code never panics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Compiler error (blocked by clippy `unwrap_used` deny)
let value = result.unwrap();

// ‚úÖ Compiler accepts - proper error handling
let value = result?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-type-level-correctness"><a class="header" href="#2-type-level-correctness">2. Type-Level Correctness</a></h3>
<p>Use Rust's type system as the primary design tool. If it compiles, correctness follows.</p>
<p><strong>Example</strong>: A validated number type that proves its value is valid:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidatedNumber&lt;T&gt; {
    value: T,  // Can only be constructed via parse()
}

impl&lt;T: FromStr&gt; ValidatedNumber&lt;T&gt; {
    pub fn parse(input: &amp;str) -&gt; Result&lt;Self, String&gt; {
        // Validation logic here
        input.parse().map(|value| Self { value })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-real-collaborators"><a class="header" href="#3-real-collaborators">3. Real Collaborators</a></h3>
<p>Test with actual dependencies, not mocks. This catches integration bugs and makes refactoring safer.</p>
<p><strong>Why?</strong> Mocks can hide bugs at integration boundaries. Real implementations reveal actual behavior.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Chicago-style: Use the real implementation
let fixture = TestFixture::new()?;  // Real setup
let result = actual_function(&amp;fixture)?;  // Real code

// London-style: Would use a mock instead
// let fixture = MockFixture::new();
<span class="boring">}</span></code></pre></pre>
<h3 id="4-the-8020-principle"><a class="header" href="#4-the-8020-principle">4. The 80/20 Principle</a></h3>
<p>When designing solutions, consider three ideas:</p>
<ul>
<li><strong>1st Idea</strong>: Solve the immediate problem (narrow scope, simple)</li>
<li><strong>2nd Idea</strong>: 80% more value with 20% more effort (sweet spot, usually best)</li>
<li><strong>3rd Idea</strong>: Maximum value, but evaluate carefully (maximum scope, most complex)</li>
</ul>
<p>Example: Number parsing</p>
<ul>
<li>1st Idea: Parse <code>u32</code> only</li>
<li>2nd Idea: Generic parser works for all number types</li>
<li>3rd Idea: Type-validated parser with OTEL instrumentation and Weaver validation</li>
</ul>
<p>Choose the 2nd idea most of the time. Only go to 3rd idea when type safety is critical.</p>
<h2 id="why-chicago-tdd-for-rust"><a class="header" href="#why-chicago-tdd-for-rust">Why Chicago TDD for Rust?</a></h2>
<p>Rust's type system makes Chicago-style TDD especially powerful:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Benefit</th></tr></thead><tbody>
<tr><td><strong>Compile-time guarantees</strong></td><td>Many bugs prevented before testing</td></tr>
<tr><td><strong>Ownership system</strong></td><td>Resource cleanup guaranteed</td></tr>
<tr><td><strong>Result type</strong></td><td>Explicit error handling (no surprises)</td></tr>
<tr><td><strong>Trait system</strong></td><td>Generic code with real implementations</td></tr>
<tr><td><strong>Macros</strong></td><td>Test framework enforcement at compile time</td></tr>
</tbody></table>
</div>
<h2 id="common-misconceptions"><a class="header" href="#common-misconceptions">Common Misconceptions</a></h2>
<h3 id="mocks-are-required"><a class="header" href="#mocks-are-required">"Mocks are Required"</a></h3>
<p>‚ùå <strong>False</strong> in Chicago TDD. Use real dependencies when possible.</p>
<p>Use mocks only for:</p>
<ul>
<li>External services (APIs, databases)</li>
<li>Expensive operations (file I/O, network)</li>
<li>Non-deterministic behavior (time, random numbers)</li>
</ul>
<h3 id="tests-should-only-test-public-apis"><a class="header" href="#tests-should-only-test-public-apis">"Tests Should Only Test Public APIs"</a></h3>
<p>‚ùå <strong>Partially true</strong>. Chicago TDD tests the behavior, not the interface.</p>
<p>Test internal functions if they:</p>
<ul>
<li>Have complex logic</li>
<li>Are hard to test through public APIs</li>
<li>Need boundary condition verification</li>
</ul>
<h3 id="100-coverage-means-bug-free-code"><a class="header" href="#100-coverage-means-bug-free-code">"100% Coverage Means Bug-Free Code"</a></h3>
<p>‚ùå <strong>False</strong>. Coverage measures code execution, not correctness.</p>
<p>Focus on:</p>
<ul>
<li>Error paths (the real bugs are here)</li>
<li>Boundary conditions</li>
<li>State transitions</li>
</ul>
<p><strong>Example</strong>: 100% coverage of a sorting function doesn't guarantee it handles duplicates correctly.</p>
<h2 id="testing-with-chicago-tdd-tools"><a class="header" href="#testing-with-chicago-tdd-tools">Testing with Chicago TDD Tools</a></h2>
<p>Chicago TDD Tools provides:</p>
<ul>
<li><strong>Type-level AAA enforcement</strong>: Arrange-Act-Assert structure at compile time</li>
<li><strong>Data builders</strong>: Fluent API for complex test data</li>
<li><strong>Fixture management</strong>: Test isolation and cleanup</li>
<li><strong>Assertion helpers</strong>: Clear, readable assertions</li>
<li><strong>Advanced techniques</strong>: Property-based, mutation, snapshot testing</li>
<li><strong>Observability</strong>: OTEL and Weaver integration</li>
</ul>
<p>All with zero-cost abstractions and compile-time error prevention.</p>
<h2 id="the-testing-pyramid"><a class="header" href="#the-testing-pyramid">The Testing Pyramid</a></h2>
<p>Chicago TDD follows a testing pyramid:</p>
<pre><code>        ‚ñ≥ (Few)
       /|\
      / | \    E2E Tests (slow, fragile)
     /  |  \
    /____|____\
    |    |    |    Integration Tests (medium speed)
    |____|____|
    |         |    Unit Tests (fast, many)
    |_________|
    ‚ñΩ (Many)
</code></pre>
<p><strong>Unit Tests</strong> (bottom): Fast, isolated, test one function</p>
<p><strong>Integration Tests</strong> (middle): Medium speed, test multiple components together</p>
<p><strong>E2E Tests</strong> (top): Slow, test the entire system</p>
<p>Chicago TDD emphasizes unit tests and integration tests. E2E tests are less important if unit+integration tests are comprehensive.</p>
<h2 id="aaa-pattern"><a class="header" href="#aaa-pattern">AAA Pattern</a></h2>
<p>Every test follows Arrange-Act-Assert:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_parsing, {
    // Arrange: Set up test data
    let input = "42";

    // Act: Execute the code under test
    let result = input.parse::&lt;u32&gt;();

    // Assert: Verify the result
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});
<span class="boring">}</span></code></pre></pre>
<p>This pattern ensures tests are:</p>
<ul>
<li><strong>Clear</strong>: Anyone can see what's being tested</li>
<li><strong>Complete</strong>: Setup, execution, and verification are separate</li>
<li><strong>Correct</strong>: Focused on one behavior per test</li>
</ul>
<h2 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h2>
<h3 id="parallel-tests"><a class="header" href="#parallel-tests">Parallel Tests</a></h3>
<p>By default, tests run in parallel. Ensure each test is independent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test1, {
    // Use unique data: TestFixture::new()?
    // Don't rely on global state
    // Don't use file/network resources shared with other tests
});
<span class="boring">}</span></code></pre></pre>
<h3 id="fixture-isolation"><a class="header" href="#fixture-isolation">Fixture Isolation</a></h3>
<p>Each fixture is independent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_fixture, {
    let fixture1 = TestFixture::new()?;
    let fixture2 = TestFixture::new()?;
    // fixture1 and fixture2 are completely independent
    // Automatic cleanup when they drop
});
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-topics-preview"><a class="header" href="#advanced-topics-preview">Advanced Topics Preview</a></h2>
<p>Chicago TDD Tools provides techniques for:</p>
<ol>
<li><strong>Property-Based Testing</strong>: Generate random test data and verify properties hold</li>
<li><strong>Mutation Testing</strong>: Validate test quality by introducing mutations</li>
<li><strong>Snapshot Testing</strong>: Golden files to detect unintended changes</li>
<li><strong>CLI Testing</strong>: Test command-line interfaces with trycmd</li>
<li><strong>Concurrency Testing</strong>: Deterministic thread testing with loom</li>
<li><strong>Observability</strong>: OTEL instrumentation and Weaver validation</li>
</ol>
<p>We'll explore all of these in later sections.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>The best way to learn is by doing. Here's the recommended learning path:</p>
<ol>
<li><strong><a href="core/README.html">Core Patterns</a></strong> - Master fixtures, data builders, and assertions</li>
<li><strong><a href="core/error-paths.html">Error Path Testing</a></strong> - Learn where bugs hide</li>
<li><strong><a href="advanced/README.html">Advanced Techniques</a></strong> - Pick techniques for your use case</li>
<li><strong><a href="guides/real-world.html">Real-World Applications</a></strong> - See complete examples</li>
<li><strong><a href="guides/best-practices.html">Best Practices</a></strong> - Avoid common pitfalls</li>
</ol>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<p>‚úÖ Chicago TDD emphasizes <strong>type safety</strong> and <strong>error prevention</strong></p>
<p>‚úÖ Use <strong>real dependencies</strong>, not mocks</p>
<p>‚úÖ Follow the <strong>80/20 principle</strong> when designing solutions</p>
<p>‚úÖ Every test follows <strong>Arrange-Act-Assert</strong></p>
<p>‚úÖ Focus on <strong>error paths</strong> (where bugs hide)</p>
<p>‚ùå Don't rely on 100% coverage (it's not enough)</p>
<p>‚ùå Don't use mocks for everything</p>
<p>‚ùå Don't skip boundary condition testing</p>
<hr />
<p><strong>Next</strong>: <a href="core/README.html">Core Testing Patterns</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-testing-patterns"><a class="header" href="#core-testing-patterns">Core Testing Patterns</a></h1>
<p>Welcome to the core testing patterns section! Here you'll learn the everyday patterns you'll use in almost every test.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Core patterns include:</p>
<ol>
<li><strong>Fixtures</strong> - Isolated test state and setup</li>
<li><strong>Data Builders</strong> - Fluent API for constructing test data</li>
<li><strong>Assertions</strong> - Clear, readable verification of results</li>
<li><strong>Error Paths</strong> - Testing failure scenarios</li>
</ol>
<p>These patterns form the foundation of all testing in Chicago TDD Tools.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Here's a complete test using core patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_user_creation, {
    // Arrange: Set up with fixtures and builders
    let fixture = TestFixture::new()?;
    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act: Execute the code under test
    let result = create_user(&amp;user_data)?;

    // Assert: Verify with assertions
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().name, "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="test-isolation"><a class="header" href="#test-isolation">Test Isolation</a></h3>
<p>Each test must be independent:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test1, {
    let fixture = TestFixture::new()?;  // Fresh fixture
    // test1 uses fixture1
});

test!(test2, {
    let fixture = TestFixture::new()?;  // Different fixture
    // test2 uses fixture2
    // Both tests can run in parallel with no interference
});
<span class="boring">}</span></code></pre></pre>
<h3 id="data-construction"><a class="header" href="#data-construction">Data Construction</a></h3>
<p>Build complex test data with fluent builders:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let order = TestDataBuilder::new()
    .with_var("order_id", "ORD-001")
    .with_order_data("ORD-001", "100.50")
    .build_json()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="clear-assertions"><a class="header" href="#clear-assertions">Clear Assertions</a></h3>
<p>Use assertion helpers for readability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_ok!(&amp;result);           // Checks is_ok()
assert_err!(&amp;result);          // Checks is_err()
assert_eq!(value, expected);   // Equality check
<span class="boring">}</span></code></pre></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="core/fixtures.html">Getting Started with Fixtures</a> - Fixture lifecycle and setup</li>
<li><a href="core/data-builders.html">Building Test Data</a> - Data builders and fluent API</li>
<li><a href="core/assertions.html">Assertions &amp; Verification</a> - Assertion helpers and patterns</li>
<li><a href="core/error-paths.html">Error Path Testing</a> - Testing failure scenarios</li>
</ul>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="pattern-arrange-act-assert"><a class="header" href="#pattern-arrange-act-assert">Pattern: Arrange-Act-Assert</a></h3>
<p>Every test follows this structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_example, {
    // Arrange: Set up test state
    let fixture = TestFixture::new()?;
    let data = TestDataBuilder::new()...build_json()?;

    // Act: Execute code under test
    let result = function_under_test(&amp;data)?;

    // Assert: Verify behavior
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().field, expected_value);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-error-path-testing"><a class="header" href="#pattern-error-path-testing">Pattern: Error Path Testing</a></h3>
<p>Always test both success and failure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_error_path, {
    // Success path
    let ok_result = parse_number("42");
    assert_ok!(&amp;ok_result);

    // Error path
    let err_result = parse_number("not_a_number");
    assert_err!(&amp;err_result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-boundary-conditions"><a class="header" href="#pattern-boundary-conditions">Pattern: Boundary Conditions</a></h3>
<p>Test edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundaries, {
    // Minimum value
    assert_ok!(&amp;function(0));

    // Maximum value
    assert_ok!(&amp;function(u32::MAX));

    // Off-by-one
    assert_ok!(&amp;function(1));
    assert_ok!(&amp;function(u32::MAX - 1));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-core-patterns"><a class="header" href="#when-to-use-core-patterns">When to Use Core Patterns</a></h2>
<p>Use core patterns for:</p>
<ul>
<li>‚úÖ Testing individual functions</li>
<li>‚úÖ Testing pure logic</li>
<li>‚úÖ Testing with simple setup</li>
<li>‚úÖ Most of your test suite (80%+)</li>
</ul>
<p>For complex scenarios, see:</p>
<ul>
<li><a href="core/../advanced/property-testing.html">Property-Based Testing</a> - Random test data</li>
<li><a href="core/../advanced/snapshot-testing.html">Snapshot Testing</a> - Golden files</li>
<li><a href="core/../advanced/cli-testing.html">CLI Testing</a> - Command-line interfaces</li>
</ul>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>üëâ <strong>Start with <a href="core/fixtures.html">Fixtures</a></strong></p>
<p>Then learn:</p>
<ol>
<li><a href="core/data-builders.html">Data Builders</a> - Construct test data</li>
<li><a href="core/assertions.html">Assertions</a> - Verify results</li>
<li><a href="core/error-paths.html">Error Paths</a> - Test failures</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-fixtures"><a class="header" href="#getting-started-with-fixtures">Getting Started with Fixtures</a></h1>
<p>Fixtures are isolated test environments that provide controlled setup and automatic cleanup.</p>
<h2 id="what-is-a-fixture"><a class="header" href="#what-is-a-fixture">What is a Fixture?</a></h2>
<p>A fixture is a test object that:</p>
<ul>
<li>Provides fresh, isolated state for each test</li>
<li>Handles setup automatically</li>
<li>Cleans up resources when the test ends</li>
<li>Prevents state leakage between tests</li>
</ul>
<h2 id="creating-a-fixture"><a class="header" href="#creating-a-fixture">Creating a Fixture</a></h2>
<h3 id="basic-fixture-creation"><a class="header" href="#basic-fixture-creation">Basic Fixture Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_with_fixture, {
    // Create a fresh fixture
    let fixture = TestFixture::new()?;

    // Fixtures provide isolation and utilities
    // Store metadata for the test
    fixture.set_metadata("test_id".to_string(), "123".to_string());

    // Retrieve metadata
    let test_id = fixture.get_metadata("test_id");
    assert_eq!(test_id, Some(&amp;"123".to_string()));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Fixtures return <code>Result</code> - always handle the error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_error_handling, {
    // ‚úÖ Handle the Result properly
    match TestFixture::new() {
        Ok(fixture) =&gt; {
            // Use fixture
            fixture.set_metadata("key".to_string(), "value".to_string());
        }
        Err(e) =&gt; {
            alert_critical!("Fixture creation failed: {}", e);
            return Err(e.into());
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<p>Or use the <code>?</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_with_question_mark, {
    let fixture = TestFixture::new()?;  // Propagates error
    fixture.set_metadata("test_data".to_string(), "setup_complete".to_string());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="fixture-features"><a class="header" href="#fixture-features">Fixture Features</a></h2>
<p>The <code>TestFixture</code> provides utilities for tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_features, {
    let mut fixture = TestFixture::new()?;

    // Store and retrieve metadata
    fixture.set_metadata("user_id".to_string(), "42".to_string());
    assert_eq!(
        fixture.get_metadata("user_id"),
        Some(&amp;"42".to_string())
    );

    // Capture snapshots of test state
    let mut state = HashMap::new();
    state.insert("status".to_string(), "initialized".to_string());
    fixture.capture_snapshot(state);

    // Retrieve snapshots
    let snapshots = fixture.snapshots();
    assert!(!snapshots.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="fixture-lifecycle"><a class="header" href="#fixture-lifecycle">Fixture Lifecycle</a></h2>
<h3 id="setup-phase"><a class="header" href="#setup-phase">Setup Phase</a></h3>
<p>Setup happens when <code>TestFixture::new()</code> is called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_setup, {
    // This is the setup phase
    let fixture = TestFixture::new()?;
    // Fixture is fully initialized here
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cleanup-phase"><a class="header" href="#cleanup-phase">Cleanup Phase</a></h3>
<p>Cleanup happens automatically when the fixture is dropped (at the end of the test):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cleanup, {
    let fixture = TestFixture::new()?;
    // Use fixture

    // When this scope ends, fixture is dropped and cleaned up
    // No explicit cleanup needed!
});
<span class="boring">}</span></code></pre></pre>
<h2 id="test-isolation-1"><a class="header" href="#test-isolation-1">Test Isolation</a></h2>
<p>Each test gets a fresh fixture:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_isolation_1, {
    let fixture1 = TestFixture::new()?;
    fixture1.set_metadata("test".to_string(), "isolation_1".to_string());
    // Uses fixture1
});

test!(test_isolation_2, {
    let fixture2 = TestFixture::new()?;
    fixture2.set_metadata("test".to_string(), "isolation_2".to_string());
    // Uses fixture2
    // fixture1 and fixture2 are completely independent
});
<span class="boring">}</span></code></pre></pre>
<p>Both tests can run in parallel with no interference.</p>
<h2 id="advanced-multiple-fixtures"><a class="header" href="#advanced-multiple-fixtures">Advanced: Multiple Fixtures</a></h2>
<p>Create multiple fixtures in one test:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_multiple_fixtures, {
    let fixture1 = TestFixture::new()?;
    let fixture2 = TestFixture::new()?;

    // Both fixtures exist independently
    fixture1.set_metadata("fixture".to_string(), "first".to_string());
    fixture2.set_metadata("fixture".to_string(), "second".to_string());

    assert_eq!(fixture1.get_metadata("fixture"), Some(&amp;"first".to_string()));
    assert_eq!(fixture2.get_metadata("fixture"), Some(&amp;"second".to_string()));

    // Both are cleaned up when the test ends
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example"><a class="header" href="#real-world-example">Real-World Example</a></h2>
<h3 id="scenario-testing-a-user-service"><a class="header" href="#scenario-testing-a-user-service">Scenario: Testing a User Service</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_service, {
    // Arrange: Set up fixture with data
    let mut fixture = TestFixture::new()?;
    fixture.set_metadata("user_id".to_string(), "123".to_string());

    // Act: Perform test operations
    // Use fixture metadata for test coordination
    let user_id = fixture.get_metadata("user_id");

    // Assert: Verify
    assert_eq!(user_id, Some(&amp;"123".to_string()));

    // Cleanup: Automatic! No explicit cleanup needed.
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="pattern-reusable-fixture-setup"><a class="header" href="#pattern-reusable-fixture-setup">Pattern: Reusable Fixture Setup</a></h3>
<p>Create a helper function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_user_fixture() -&gt; Result&lt;TestFixture, Box&lt;dyn std::error::Error&gt;&gt; {
    let fixture = TestFixture::new()?;
    // Additional setup here if needed
    Ok(fixture)
}

test!(test_with_helper, {
    let fixture = setup_user_fixture()?;
    // Use configured fixture
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-nested-fixtures"><a class="header" href="#pattern-nested-fixtures">Pattern: Nested Fixtures</a></h3>
<p>Fixtures can use other fixtures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_nested, {
    let outer = TestFixture::new()?;
    let inner = TestFixture::new()?;
    // Both are available
    // Inner is cleaned up first (LIFO order)
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="failed-to-create-fixture"><a class="header" href="#failed-to-create-fixture">"Failed to create fixture"</a></h3>
<p>This usually means an environment issue:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_fixture_error, {
    match TestFixture::new() {
        Ok(fixture) =&gt; {
            // Successfully created
        }
        Err(e) =&gt; {
            // Check your environment configuration
            alert_critical!("Environment issue: {}", e);
            return Err(e.into());
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="tests-running-sequentially"><a class="header" href="#tests-running-sequentially">Tests Running Sequentially</a></h3>
<p>Chicago TDD Tools tests run in parallel by default. If you see sequential execution:</p>
<ol>
<li>Check for shared state (file I/O, network)</li>
<li>Ensure each test has its own fixture</li>
<li>Use <code>cargo test -- --test-threads=1</code> to force sequential (for debugging)</li>
</ol>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Create a fresh fixture in each test</li>
<li>Handle the <code>Result</code> with <code>?</code> or <code>match</code></li>
<li>Let fixtures clean up automatically</li>
<li>Use multiple fixtures if needed</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Share fixtures between tests</li>
<li>Manually clean up (let the fixture drop)</li>
<li>Rely on global state</li>
<li>Use <code>unwrap()</code> on fixture creation</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Learn how to use fixtures with data builders: <a href="core/data-builders.html">Building Test Data</a></p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Concept</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Fixture</strong></td><td>Isolated test state</td></tr>
<tr><td><strong>Setup</strong></td><td>Happens in <code>TestFixture::new()</code></td></tr>
<tr><td><strong>Cleanup</strong></td><td>Automatic on drop</td></tr>
<tr><td><strong>Isolation</strong></td><td>Each test gets fresh fixture</td></tr>
<tr><td><strong>Error Handling</strong></td><td>Use <code>?</code> operator or <code>match</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="building-test-data-with-data-builders"><a class="header" href="#building-test-data-with-data-builders">Building Test Data with Data Builders</a></h1>
<p>Data builders provide a fluent API for constructing complex test data structures.</p>
<h2 id="why-data-builders"><a class="header" href="#why-data-builders">Why Data Builders?</a></h2>
<p>Raw test data is hard to read and maintain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Hard to understand what this represents
let mut data = HashMap::new();
data.insert("key1".to_string(), "value1".to_string());
data.insert("key2".to_string(), "value2".to_string());
data.insert("order_id".to_string(), "ORD-001".to_string());
<span class="boring">}</span></code></pre></pre>
<p>Data builders are readable and maintainable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Clear intent - building an order
let data = TestDataBuilder::new()
    .with_var("key1", "value1")
    .with_var("key2", "value2")
    .with_order_data("ORD-001", "100.00")
    .build_json()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-data-builder-usage"><a class="header" href="#basic-data-builder-usage">Basic Data Builder Usage</a></h2>
<h3 id="creating-simple-data"><a class="header" href="#creating-simple-data">Creating Simple Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_data_builder, {
    // Arrange: Build test data
    let builder = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com");

    // Build as JSON
    let json_data = builder.build_json()?;
    assert!(json_data.is_object());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="building-json-data"><a class="header" href="#building-json-data">Building JSON Data</a></h3>
<p>The primary format is JSON:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()?;  // Returns serde_json::Value
<span class="boring">}</span></code></pre></pre>
<p>All test data is built as JSON, which is flexible and works with most applications.</p>
<h2 id="fluent-builder-pattern"><a class="header" href="#fluent-builder-pattern">Fluent Builder Pattern</a></h2>
<p>Builders use method chaining for readability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("user_id", "123")
    .with_var("name", "Bob")
    .with_var("email", "bob@example.com")
    .with_var("status", "active")
    .with_order_data("ORD-001", "250.99")
    .build_json()?;
<span class="boring">}</span></code></pre></pre>
<p>Each method returns <code>Self</code>, allowing unlimited chaining.</p>
<h2 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h2>
<h3 id="basic-variables"><a class="header" href="#basic-variables">Basic Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_var(key, value)           // Add a string variable
<span class="boring">}</span></code></pre></pre>
<h3 id="complex-data"><a class="header" href="#complex-data">Complex Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_order_data(id, amount)    // Add order information
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<p>Always handle the Result from <code>build_*()</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()
{
    Ok(data) =&gt; {
        // Use data
        assert!(data.is_object());
    }
    Err(e) =&gt; {
        alert_critical!("Failed to build data: {}", e);
        return Err(e.into());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Or use <code>?</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("key", "value")
    .build_json()?;  // Propagates error
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-building-user-data"><a class="header" href="#real-world-example-building-user-data">Real-World Example: Building User Data</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_registration, {
    // Build user data
    let user_data = TestDataBuilder::new()
        .with_var("username", "alice_wonder")
        .with_var("email", "alice@example.com")
        .with_var("password", "secure_password_123")
        .with_var("first_name", "Alice")
        .with_var("last_name", "Wonder")
        .with_var("country", "US")
        .build_json()?;

    // Use in test
    let result = register_user(&amp;user_data)?;

    // Verify
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().email, "alice@example.com");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-building-order-data"><a class="header" href="#real-world-example-building-order-data">Real-World Example: Building Order Data</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_order_processing, {
    // Build order
    let order = TestDataBuilder::new()
        .with_order_data("ORD-12345", "499.99")
        .with_var("customer_id", "CUST-001")
        .with_var("shipping_address", "123 Main St")
        .with_var("payment_method", "credit_card")
        .build_json()?;

    // Process order
    let result = process_order(&amp;order)?;

    // Verify
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().status, "processed");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-composition"><a class="header" href="#advanced-composition">Advanced: Composition</a></h2>
<p>Build complex structures by combining builders:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_composition, {
    // Build related data
    let user = TestDataBuilder::new()
        .with_var("user_id", "123")
        .with_var("name", "Alice")
        .build_json()?;

    let order = TestDataBuilder::new()
        .with_order_data("ORD-001", "100.00")
        .with_var("user_id", "123")  // Link to user
        .build_json()?;

    // Both built, ready to use
    assert_eq!(user["user_id"], "123");
    assert_eq!(order["user_id"], "123");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="boundary-conditions-with-builders"><a class="header" href="#boundary-conditions-with-builders">Boundary Conditions with Builders</a></h2>
<p>Test edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_builder_boundaries, {
    // Empty data
    let empty = TestDataBuilder::new().build_json()?;
    assert!(empty.is_object());

    // Minimal data
    let minimal = TestDataBuilder::new()
        .with_var("id", "1")
        .build_json()?;
    assert_eq!(minimal["id"], "1");

    // Maximum data (many fields)
    let mut builder = TestDataBuilder::new();
    for i in 0..1000 {
        builder = builder.with_var(&amp;format!("field_{}", i), &amp;format!("value_{}", i));
    }
    let large = builder.build_json()?;
    assert!(large.is_object());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="accessing-built-data"><a class="header" href="#accessing-built-data">Accessing Built Data</a></h2>
<h3 id="access-as-json"><a class="header" href="#access-as-json">Access as JSON</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = TestDataBuilder::new()
    .with_var("name", "Alice")
    .with_var("age", "30")
    .build_json()?;

// Access fields
assert_eq!(data["name"], "Alice");
assert_eq!(data["age"], "30");
<span class="boring">}</span></code></pre></pre>
<h3 id="serialize-to-struct"><a class="header" href="#serialize-to-struct">Serialize to Struct</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Deserialize)]
struct User {
    name: String,
    age: u32,
}

let data = TestDataBuilder::new()
    .with_var("name", "Alice")
    .with_var("age", "30")
    .build_json()?;

let user: User = serde_json::from_value(data)?;
assert_eq!(user.name, "Alice");
assert_eq!(user.age, 30);
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use descriptive variable names</li>
<li>Chain methods for readability</li>
<li>Handle errors with <code>?</code></li>
<li>Build all data before acting</li>
<li>Use order data for order-specific fields</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use unclear abbreviations</li>
<li>Mix high-level and low-level builders</li>
<li>Build data after acting (arrange first!)</li>
<li>Ignore build errors</li>
</ul>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="pattern-reusable-builder-factory"><a class="header" href="#pattern-reusable-builder-factory">Pattern: Reusable Builder Factory</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_valid_user_data() -&gt; Result&lt;serde_json::Value, String&gt; {
    TestDataBuilder::new()
        .with_var("username", "test_user")
        .with_var("email", "test@example.com")
        .with_var("status", "active")
        .build_json()
}

test!(test_with_factory, {
    let user_data = create_valid_user_data()?;
    // Use pre-built data
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-variation-for-edge-cases"><a class="header" href="#pattern-variation-for-edge-cases">Pattern: Variation for Edge Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_inactive_user_data() -&gt; Result&lt;serde_json::Value, String&gt; {
    TestDataBuilder::new()
        .with_var("username", "inactive_user")
        .with_var("email", "inactive@example.com")
        .with_var("status", "inactive")  // Key difference
        .build_json()
}

test!(test_inactive_user, {
    let user_data = create_inactive_user_data()?;
    // Test inactive user handling
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="failed-to-build-data-invalid-json"><a class="header" href="#failed-to-build-data-invalid-json">"Failed to build data: Invalid JSON"</a></h3>
<p>Check for:</p>
<ul>
<li>Malformed variable values</li>
<li>Type mismatches</li>
<li>Missing required fields</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug by building step-by-step
let builder1 = TestDataBuilder::new().with_var("key1", "value1");
// builder1 is valid

let builder2 = builder1.with_var("key2", "value2");
// builder2 is valid

// etc.
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Learn assertions: <a href="core/assertions.html">Assertions &amp; Verification</a></p>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Fluent API</strong></td><td>Readable data construction</td></tr>
<tr><td><strong>Chaining</strong></td><td><code>.with_var()</code> returns <code>Self</code></td></tr>
<tr><td><strong>Error Handling</strong></td><td><code>build_json()</code> returns <code>Result</code></td></tr>
<tr><td><strong>Composition</strong></td><td>Combine multiple builders</td></tr>
<tr><td><strong>Reusability</strong></td><td>Extract to helper functions</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="assertions--verification"><a class="header" href="#assertions--verification">Assertions &amp; Verification</a></h1>
<p>Assertions verify that code behaves correctly. Chicago TDD Tools provides helpers for clear, readable assertions.</p>
<h2 id="basic-assertions"><a class="header" href="#basic-assertions">Basic Assertions</a></h2>
<h3 id="standard-assertions"><a class="header" href="#standard-assertions">Standard Assertions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_basic_assertions, {
    let result: Result&lt;u32, String&gt; = Ok(42);

    // ‚úÖ Chicago TDD style - clear intent
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);

    // Error result
    let error: Result&lt;u32, String&gt; = Err("failed".to_string());
    assert_err!(&amp;error);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="common-assertion-helpers"><a class="header" href="#common-assertion-helpers">Common Assertion Helpers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Success/Error checks
assert_ok!(&amp;result);           // Verifies Ok(_)
assert_err!(&amp;result);          // Verifies Err(_)

// Equality
assert_eq!(actual, expected);   // Equality check
assert_ne!(actual, expected);   // Inequality check

// Boolean
assert!(condition);             // Checks true
assert!(!condition);            // Checks false
<span class="boring">}</span></code></pre></pre>
<h2 id="numeric-assertions"><a class="header" href="#numeric-assertions">Numeric Assertions</a></h2>
<h3 id="range-checking"><a class="header" href="#range-checking">Range Checking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_numeric_assertions, {
    let value = 42;

    // Standard assertions
    assert_eq!(value, 42);
    assert!(value &gt; 40);
    assert!(value &lt; 50);

    // Chicago TDD helper
    assert_in_range!(value, 40, 50);  // Inclusive range
});
<span class="boring">}</span></code></pre></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating Point</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_floating_point, {
    let value: f64 = 3.14159;
    let expected: f64 = 3.14;

    // ‚úÖ Epsilon comparison (handles rounding errors)
    assert!((value - expected).abs() &lt; 0.01);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="string-assertions"><a class="header" href="#string-assertions">String Assertions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_string_assertions, {
    let text = "Hello, World!";

    // Equality
    assert_eq!(text, "Hello, World!");

    // Containment
    assert!(text.contains("World"));

    // Pattern matching
    assert!(text.starts_with("Hello"));
    assert!(text.ends_with("!"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="collection-assertions"><a class="header" href="#collection-assertions">Collection Assertions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_collection_assertions, {
    let vec = vec![1, 2, 3];

    // Length
    assert_eq!(vec.len(), 3);

    // Containment
    assert!(vec.contains(&amp;2));

    // Empty check
    assert!(!vec.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="optionresult-assertions"><a class="header" href="#optionresult-assertions">Option/Result Assertions</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_option_result_assertions, {
    let some_value: Option&lt;i32&gt; = Some(42);
    let none_value: Option&lt;i32&gt; = None;

    // Option checks
    assert!(some_value.is_some());
    assert!(none_value.is_none());

    // Result checks
    let ok_result: Result&lt;i32, String&gt; = Ok(42);
    let err_result: Result&lt;i32, String&gt; = Err("error".to_string());

    assert!(ok_result.is_ok());
    assert!(err_result.is_err());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h2>
<p>Add context to assertions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_messages, {
    let result = divide(10, 2);
    assert_eq!(result, 5, "Expected division to work correctly");

    let empty = vec![];
    assert!(!empty.is_empty(), "Vector should not be empty after initialization");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-user-creation"><a class="header" href="#real-world-example-user-creation">Real-World Example: User Creation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_creation, {
    // Create user
    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    let result = create_user(&amp;user_data)?;

    // Assert success
    assert_ok!(&amp;result);
    let user = result.unwrap();

    // Assert properties
    assert_eq!(user.name, "Alice");
    assert_eq!(user.email, "alice@example.com");
    assert!(user.id &gt; 0);
    assert!(user.created_at.len() &gt; 0);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-collection-processing"><a class="header" href="#real-world-example-collection-processing">Real-World Example: Collection Processing</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_filter_operations, {
    let numbers = vec![1, 2, 3, 4, 5];

    // Filter evens
    let evens: Vec&lt;_&gt; = numbers
        .iter()
        .filter(|n| n % 2 == 0)
        .cloned()
        .collect();

    // Assertions
    assert_eq!(evens.len(), 2);
    assert!(evens.contains(&amp;2));
    assert!(evens.contains(&amp;4));
    assert!(!evens.contains(&amp;1));  // 1 is odd
});
<span class="boring">}</span></code></pre></pre>
<h2 id="assert-patterns"><a class="header" href="#assert-patterns">Assert Patterns</a></h2>
<h3 id="pattern-positive-case"><a class="header" href="#pattern-positive-case">Pattern: Positive Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_positive, {
    let result = parse_number("42");
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-negative-case"><a class="header" href="#pattern-negative-case">Pattern: Negative Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_negative, {
    let result = parse_number("invalid");
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-boundary-case"><a class="header" href="#pattern-boundary-case">Pattern: Boundary Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundary, {
    // Zero
    assert_ok!(&amp;parse_number("0"));

    // Large value
    assert_ok!(&amp;parse_number("999999"));

    // Negative
    assert_ok!(&amp;parse_number("-42"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="avoiding-common-pitfalls"><a class="header" href="#avoiding-common-pitfalls">Avoiding Common Pitfalls</a></h2>
<h3 id="-dont-use-unwrap-in-assertions"><a class="header" href="#-dont-use-unwrap-in-assertions">‚ùå Don't: Use unwrap() in assertions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad - panics if result is Err
let value = result.unwrap();
assert_eq!(value, 42);
<span class="boring">}</span></code></pre></pre>
<h3 id="-do-check-first"><a class="header" href="#-do-check-first">‚úÖ Do: Check first</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - checks properly
assert_ok!(&amp;result);
if let Ok(value) = result {
    assert_eq!(value, 42);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-dont-assert-implementation-details"><a class="header" href="#-dont-assert-implementation-details">‚ùå Don't: Assert implementation details</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad - depends on internal structure
assert_eq!(user.internal_id, 123);
<span class="boring">}</span></code></pre></pre>
<h3 id="-do-assert-behavior"><a class="header" href="#-do-assert-behavior">‚úÖ Do: Assert behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good - asserts external behavior
assert_eq!(user.name, "Alice");
assert_eq!(user.email, "alice@example.com");
<span class="boring">}</span></code></pre></pre>
<h2 id="assertion-order"><a class="header" href="#assertion-order">Assertion Order</a></h2>
<p>Follow AAA pattern:</p>
<ol>
<li><strong>Arrange</strong> - Build data</li>
<li><strong>Act</strong> - Execute code</li>
<li><strong>Assert</strong> - Verify behavior</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_order, {
    // Arrange
    let input = 5;

    // Act
    let result = multiply_by_two(input);

    // Assert (all together, at the end)
    assert_eq!(result, 10);
    assert!(result &gt; 0);
    assert!(result &lt; 100);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use helper macros (<code>assert_ok!</code>, <code>assert_err!</code>)</li>
<li>Assert one behavior per test</li>
<li>Add context with messages</li>
<li>Check both success and error paths</li>
<li>Use descriptive assertion messages</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use <code>unwrap()</code> in assertions</li>
<li>Mix act and assert</li>
<li>Assert implementation details</li>
<li>Skip error case assertions</li>
<li>Use vague assertion messages</li>
</ul>
<h2 id="common-assertions-reference"><a class="header" href="#common-assertions-reference">Common Assertions Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Code</th></tr></thead><tbody>
<tr><td>Value matches</td><td><code>assert_eq!(actual, expected)</code></td></tr>
<tr><td>Value different</td><td><code>assert_ne!(actual, expected)</code></td></tr>
<tr><td>True condition</td><td><code>assert!(condition)</code></td></tr>
<tr><td>Ok result</td><td><code>assert_ok!(&amp;result)</code></td></tr>
<tr><td>Err result</td><td><code>assert_err!(&amp;result)</code></td></tr>
<tr><td>In range</td><td><code>assert_in_range!(value, min, max)</code></td></tr>
<tr><td>Contains text</td><td><code>assert!(text.contains("substring"))</code></td></tr>
<tr><td>Empty collection</td><td><code>assert!(collection.is_empty())</code></td></tr>
</tbody></table>
</div>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Learn about error paths: <a href="core/error-paths.html">Error Path Testing</a></p>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Chicago TDD emphasizes:</p>
<ul>
<li>Clear assertions with helper macros</li>
<li>Both success and error case verification</li>
<li>AAA pattern (Arrange-Act-Assert)</li>
<li>Behavior verification, not implementation details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-path-testing"><a class="header" href="#error-path-testing">Error Path Testing</a></h1>
<p>Error paths are where 80% of bugs hide. Chicago TDD emphasizes comprehensive error testing.</p>
<h2 id="why-error-paths-matter"><a class="header" href="#why-error-paths-matter">Why Error Paths Matter</a></h2>
<p>Most code focuses on the "happy path" (success). Bugs hide in error cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Happy path is obvious
let parsed = "42".parse::&lt;u32&gt;()?;
assert_eq!(parsed, 42);

// Error path has subtle bugs
// What about "not_a_number"?
// What about negative "-42"?
// What about overflow "99999999999999999999"?
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-both-paths"><a class="header" href="#testing-both-paths">Testing Both Paths</a></h2>
<p>Every function should test both success and failure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_complete_behavior, {
    // Success path
    let ok_result = parse_number::&lt;u32&gt;("42");
    assert_ok!(&amp;ok_result);
    assert_eq!(ok_result.unwrap(), 42);

    // Error path
    let err_result = parse_number::&lt;u32&gt;("invalid");
    assert_err!(&amp;err_result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h2>
<h3 id="1-invalid-input"><a class="header" href="#1-invalid-input">1. Invalid Input</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_invalid_input, {
    let result = validate_email("not_an_email");
    assert_err!(&amp;result);

    let result = validate_email("");
    assert_err!(&amp;result);

    let result = validate_email("@");
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="2-boundary-conditions"><a class="header" href="#2-boundary-conditions">2. Boundary Conditions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundaries, {
    // Minimum
    assert_ok!(&amp;process(0));

    // Just above minimum
    assert_ok!(&amp;process(1));

    // Maximum valid
    assert_ok!(&amp;process(u32::MAX - 1));

    // Just past maximum
    assert_err!(&amp;process(u32::MAX + 1));  // If checked
});
<span class="boring">}</span></code></pre></pre>
<h3 id="3-resource-errors"><a class="header" href="#3-resource-errors">3. Resource Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_resource_errors, {
    // File doesn't exist
    let result = read_file("nonexistent.txt");
    assert_err!(&amp;result);

    // Permission denied
    let result = write_file("/root/restricted.txt", "data");
    assert_err!(&amp;result);

    // Out of memory (hard to test, but consider it)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="4-state-errors"><a class="header" href="#4-state-errors">4. State Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_state_errors, {
    let state = MyStateMachine::new();

    // Valid transition
    assert_ok!(&amp;state.transition_to_active());

    // Invalid transition
    let already_active = MyStateMachine::new().transition_to_active();
    assert_err!(&amp;already_active.transition_to_active());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-messages"><a class="header" href="#error-messages">Error Messages</a></h2>
<p>Test that error messages are helpful:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_messages, {
    let result = parse_number::&lt;u32&gt;("not_a_number");

    match result {
        Err(e) =&gt; {
            // Verify error message is clear
            assert!(e.to_string().contains("parse error"));
            assert!(e.to_string().contains("not_a_number"));
        }
        Ok(_) =&gt; panic!("Should have failed"),
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<p>Test that code recovers from errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_recovery, {
    // First attempt fails
    let result1 = connect_to_database("invalid_url");
    assert_err!(&amp;result1);

    // Code continues and retries with valid URL
    let result2 = connect_to_database("valid_url");
    assert_ok!(&amp;result2);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-form-validation"><a class="header" href="#real-world-example-form-validation">Real-World Example: Form Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_form_validation, {
    let validator = FormValidator::new();

    // Valid case
    let valid = validator.validate(&amp;FormData {
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
        password: "secure_password_123".to_string(),
    });
    assert_ok!(&amp;valid);

    // Missing username
    let missing_username = validator.validate(&amp;FormData {
        username: "".to_string(),
        email: "alice@example.com".to_string(),
        password: "secure_password_123".to_string(),
    });
    assert_err!(&amp;missing_username);

    // Invalid email
    let invalid_email = validator.validate(&amp;FormData {
        username: "alice".to_string(),
        email: "not_an_email".to_string(),
        password: "secure_password_123".to_string(),
    });
    assert_err!(&amp;invalid_email);

    // Weak password
    let weak_password = validator.validate(&amp;FormData {
        username: "alice".to_string(),
        email: "alice@example.com".to_string(),
        password: "123".to_string(),  // Too short
    });
    assert_err!(&amp;weak_password);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-api-endpoint"><a class="header" href="#real-world-example-api-endpoint">Real-World Example: API Endpoint</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_api_error_handling, {
    let client = ApiClient::new();

    // Success
    let result = client.get_user(123);
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap().id, 123);

    // User not found
    let result = client.get_user(999999);
    assert_err!(&amp;result);

    // Invalid ID
    let result = client.get_user(-1);
    assert_err!(&amp;result);

    // Network error (mock or integration test)
    let result = client.get_user(456);  // Server down
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="pattern-check-and-handle"><a class="header" href="#pattern-check-and-handle">Pattern: Check and Handle</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_check_and_handle, {
    let result = risky_operation();

    match result {
        Ok(value) =&gt; {
            assert_eq!(value, expected);
        }
        Err(e) =&gt; {
            // Handle error
            assert!(e.to_string().len() &gt; 0);
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-map-error"><a class="header" href="#pattern-map-error">Pattern: Map Error</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_map_error, {
    let result = risky_operation()
        .map_err(|e| format!("Operation failed: {}", e));

    assert_err!(&amp;result);
    if let Err(e) = result {
        assert!(e.contains("Operation failed"));
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-recover"><a class="header" href="#pattern-recover">Pattern: Recover</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_recovery, {
    let result = risky_operation()
        .or_else(|_| fallback_operation());

    // Should succeed via fallback
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="comprehensive-error-test"><a class="header" href="#comprehensive-error-test">Comprehensive Error Test</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_comprehensive_errors, {
    // Arrange
    let test_cases = vec![
        ("valid_input", true),
        ("", false),
        ("too_long_" /* 100 chars */, false),
        ("special@chars#", false),
        ("123", true),
        ("-123", false),  // Negative not allowed
    ];

    // Act &amp; Assert
    for (input, should_succeed) in test_cases {
        let result = validate_input(input);

        if should_succeed {
            assert_ok!(&amp;result, "Input '{}' should be valid", input);
        } else {
            assert_err!(&amp;result, "Input '{}' should be invalid", input);
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test both success and error paths</li>
<li>Use boundary conditions</li>
<li>Test error messages</li>
<li>Verify error recovery</li>
<li>Document expected errors</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Only test the happy path</li>
<li>Assume error handling is correct</li>
<li>Ignore boundary conditions</li>
<li>Skip error message verification</li>
<li>Test implementation details of errors</li>
</ul>
<h2 id="error-testing-checklist"><a class="header" href="#error-testing-checklist">Error Testing Checklist</a></h2>
<p>For each function, test:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Happy path (normal input)</li>
<li><input disabled="" type="checkbox"/>
Invalid input</li>
<li><input disabled="" type="checkbox"/>
Boundary conditions (min, max, zero, -1)</li>
<li><input disabled="" type="checkbox"/>
Empty/null values</li>
<li><input disabled="" type="checkbox"/>
Resource errors (if applicable)</li>
<li><input disabled="" type="checkbox"/>
State errors (if applicable)</li>
<li><input disabled="" type="checkbox"/>
Error messages are clear</li>
<li><input disabled="" type="checkbox"/>
Error recovery is possible</li>
</ul>
<h2 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common Error Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Scenario</th><th>Test Case</th></tr></thead><tbody>
<tr><td>Missing input</td><td>Empty string, None, empty Vec</td></tr>
<tr><td>Invalid format</td><td>Wrong type, malformed data</td></tr>
<tr><td>Out of range</td><td>Negative when only positive allowed</td></tr>
<tr><td>Resource unavailable</td><td>File not found, connection refused</td></tr>
<tr><td>State violation</td><td>Invalid state transition</td></tr>
<tr><td>Timeout</td><td>Operation takes too long</td></tr>
</tbody></table>
</div>
<h2 id="real-world-integration-example"><a class="header" href="#real-world-integration-example">Real-World Integration Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_database_operations, {
    let db = Database::new();

    // Success: Insert and retrieve
    let user_id = db.insert_user("alice", "alice@example.com");
    let result = db.get_user(user_id);
    assert_ok!(&amp;result);

    // Error: User not found
    let result = db.get_user(999999);
    assert_err!(&amp;result);

    // Error: Duplicate email
    let result = db.insert_user("bob", "alice@example.com");  // Email taken
    assert_err!(&amp;result);

    // Error: Invalid email
    let result = db.insert_user("carol", "not_an_email");
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>Learn advanced techniques: <a href="core/../advanced/README.html">Advanced Testing Techniques</a></p>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>Chicago TDD prioritizes error testing because:</p>
<ul>
<li>Bugs hide in error paths</li>
<li>Error handling is often incorrect</li>
<li>Users encounter errors in real use</li>
</ul>
<p>Always test:</p>
<ul>
<li>‚úÖ Happy path</li>
<li>‚úÖ Error cases</li>
<li>‚úÖ Boundary conditions</li>
<li>‚úÖ Error messages</li>
<li>‚úÖ Recovery</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-testing-techniques"><a class="header" href="#advanced-testing-techniques">Advanced Testing Techniques</a></h1>
<p>Welcome to advanced testing techniques! These specialized methods help you test complex scenarios effectively.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Advanced techniques include:</p>
<ol>
<li><strong>Property-Based Testing</strong> - Generate random data and verify properties</li>
<li><strong>Mutation Testing</strong> - Validate test quality by introducing mutations</li>
<li><strong>Snapshot Testing</strong> - Golden files to detect unintended changes</li>
<li><strong>CLI Testing</strong> - Test command-line interfaces</li>
<li><strong>Concurrency Testing</strong> - Deterministic thread testing</li>
</ol>
<h2 id="when-to-use-advanced-techniques"><a class="header" href="#when-to-use-advanced-techniques">When to Use Advanced Techniques</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Technique</th><th>Best For</th><th>When to Use</th></tr></thead><tbody>
<tr><td><strong>Property-Based</strong></td><td>Mathematical properties, edge cases</td><td>Complex algorithms, parsing</td></tr>
<tr><td><strong>Mutation</strong></td><td>Test quality validation</td><td>Assessing test effectiveness</td></tr>
<tr><td><strong>Snapshot</strong></td><td>Stable output, complex structures</td><td>API responses, generated code</td></tr>
<tr><td><strong>CLI</strong></td><td>Command-line tools</td><td>CLI applications, scripts</td></tr>
<tr><td><strong>Concurrency</strong></td><td>Thread-safe code</td><td>Concurrent systems, race conditions</td></tr>
</tbody></table>
</div>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test that addition is commutative
test!(test_addition_commutative, {
    let strategy = ProptestStrategy::new().with_cases(100);
    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| a + b == b + a);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="mutation-testing"><a class="header" href="#mutation-testing">Mutation Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify tests catch mutations
let mut tester = MutationTester::new(data);
tester.apply_mutation(MutationOperator::ChangeValue(...));
let caught = tester.test_mutation_detection(|data| check_data(data));
assert!(caught);  // Tests should catch the mutation
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Golden file testing
let output = generate_report();
assert_matches!(output, "report");  // Compares with snapshot
<span class="boring">}</span></code></pre></pre>
<h3 id="cli-testing"><a class="header" href="#cli-testing">CLI Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test CLI commands
let output = CliTest::new("myapp", vec!["list", "--verbose"])
    .run()?;
assert!(output.contains("item1"));
<span class="boring">}</span></code></pre></pre>
<h3 id="concurrency-testing"><a class="header" href="#concurrency-testing">Concurrency Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Deterministic thread testing
loom::model(|| {
    let data = Arc::new(Mutex::new(0));
    thread::spawn({
        let data = data.clone();
        move || *data.lock().unwrap() += 1;
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="learning-path"><a class="header" href="#learning-path">Learning Path</a></h2>
<ol>
<li><strong>Start with</strong> <a href="advanced/property-testing.html">Property-Based Testing</a> - Easy to understand, powerful</li>
<li><strong>Then explore</strong> <a href="advanced/mutation-testing.html">Mutation Testing</a> - Validates your tests</li>
<li><strong>Add</strong> <a href="advanced/snapshot-testing.html">Snapshot Testing</a> - For regression detection</li>
<li><strong>Test CLIs with</strong> <a href="advanced/cli-testing.html">CLI Testing</a> - If you have CLI tools</li>
<li><strong>Thread-safe code with</strong> <a href="advanced/concurrency-testing.html">Concurrency Testing</a> - For concurrent systems</li>
</ol>
<h2 id="combining-techniques"><a class="header" href="#combining-techniques">Combining Techniques</a></h2>
<p>You can combine advanced techniques:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(comprehensive_test, {
    // Use fixtures and data builders (core)
    let fixture = TestFixture::new()?;
    let data = TestDataBuilder::new()...build_json()?;

    // Use property-based testing (advanced)
    let strategy = ProptestStrategy::new().with_cases(50);

    // Use mutation testing (advanced)
    let mut tester = MutationTester::new(data.clone());

    // Use snapshot testing (advanced)
    let result = process(&amp;data)?;
    assert_matches!(result, "expected_output");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-scenarios"><a class="header" href="#real-world-scenarios">Real-World Scenarios</a></h2>
<h3 id="scenario-1-json-parser"><a class="header" href="#scenario-1-json-parser">Scenario 1: JSON Parser</a></h3>
<ul>
<li><strong>Core</strong>: Basic tests with fixtures</li>
<li><strong>Property-Based</strong>: Test parsing properties (round-trip)</li>
<li><strong>Mutation</strong>: Validate test quality</li>
<li><strong>Snapshot</strong>: Compare against golden files</li>
</ul>
<h3 id="scenario-2-cli-tool"><a class="header" href="#scenario-2-cli-tool">Scenario 2: CLI Tool</a></h3>
<ul>
<li><strong>Core</strong>: Basic command tests</li>
<li><strong>CLI Testing</strong>: Full CLI integration</li>
<li><strong>Snapshot</strong>: Compare output with golden files</li>
<li><strong>Property-Based</strong>: Random argument generation</li>
</ul>
<h3 id="scenario-3-concurrent-system"><a class="header" href="#scenario-3-concurrent-system">Scenario 3: Concurrent System</a></h3>
<ul>
<li><strong>Core</strong>: Basic thread tests</li>
<li><strong>Concurrency</strong>: Deterministic testing with loom</li>
<li><strong>Property-Based</strong>: Test invariants across threads</li>
<li><strong>Mutation</strong>: Validate synchronization correctness</li>
</ul>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>Enable features for advanced techniques:</p>
<pre><code class="language-toml">[dev-dependencies]
chicago-tdd-tools = { version = "1.3", features = [
    "property-testing",      # Property-based testing
    "mutation-testing",      # Mutation testing
    "snapshot-testing",      # Snapshot testing
    "cli-testing",           # CLI testing
    "concurrency-testing",   # Concurrency testing
    "testing-extras",        # All of above (most common)
    "testing-full",          # All testing features
] }
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<p>Advanced techniques can be slower:</p>
<div class="table-wrapper"><table><thead><tr><th>Technique</th><th>Speed</th><th>Trade-off</th></tr></thead><tbody>
<tr><td>Unit tests</td><td>Fast (ms)</td><td>Limited scenarios</td></tr>
<tr><td>Property-based</td><td>Medium (seconds)</td><td>Comprehensive coverage</td></tr>
<tr><td>Mutation</td><td>Slow (minutes)</td><td>High confidence</td></tr>
<tr><td>Snapshot</td><td>Fast (ms)</td><td>Brittle to changes</td></tr>
<tr><td>Concurrency</td><td>Slow (seconds)</td><td>Deterministic</td></tr>
</tbody></table>
</div>
<p><strong>Recommendation</strong>:</p>
<ul>
<li>Use core patterns for 80% of tests (fast feedback)</li>
<li>Use advanced techniques for critical paths (high confidence)</li>
</ul>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<p>‚ùå <strong>Over-using advanced techniques</strong></p>
<ul>
<li>Use property-based for properties, not all tests</li>
<li>Use mutation occasionally, not always</li>
</ul>
<p>‚ùå <strong>Ignoring performance</strong></p>
<ul>
<li>Property-based with 10,000 cases is overkill</li>
<li>Limit mutation test scope</li>
</ul>
<p>‚ùå <strong>Replacing core patterns</strong></p>
<ul>
<li>Advanced techniques complement, not replace, core patterns</li>
<li>Still need AAA pattern and error paths</li>
</ul>
<p>‚úÖ <strong>Best practices</strong>:</p>
<ul>
<li>Use core patterns as foundation</li>
<li>Add advanced techniques strategically</li>
<li>Balance confidence with speed</li>
</ul>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<ul>
<li><a href="advanced/property-testing.html">Property-Based Testing</a></li>
<li><a href="advanced/mutation-testing.html">Mutation Testing</a></li>
<li><a href="advanced/snapshot-testing.html">Snapshot Testing</a></li>
<li><a href="advanced/cli-testing.html">CLI Testing</a></li>
<li><a href="advanced/concurrency-testing.html">Concurrency Testing</a></li>
</ul>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<p>üëâ <strong>Start with <a href="advanced/property-testing.html">Property-Based Testing</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-based-testing-1"><a class="header" href="#property-based-testing-1">Property-Based Testing</a></h1>
<p>Property-based testing generates random test data and verifies that properties hold for all inputs.</p>
<h2 id="what-is-a-property"><a class="header" href="#what-is-a-property">What is a Property?</a></h2>
<p>A <strong>property</strong> is a logical assertion that should hold for all valid inputs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: Addition is commutative
// For all a, b: a + b == b + a

// Property: Parsing and formatting is round-trip safe
// For all x: parse(format(x)) == x

// Property: Sorted list has no inversions
// For all lists: list[i] &lt;= list[i+1]
<span class="boring">}</span></code></pre></pre>
<h2 id="property-based-vs-example-based"><a class="header" href="#property-based-vs-example-based">Property-Based vs. Example-Based</a></h2>
<h3 id="example-based-traditional"><a class="header" href="#example-based-traditional">Example-Based (Traditional)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_addition_examples, {
    assert_eq!(2 + 3, 5);
    assert_eq!(0 + 5, 5);
    assert_eq!(10 + 0, 10);
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Limitation</strong>: Only tests specific examples. What about <code>u32::MAX + 1</code>?</p>
<h3 id="property-based"><a class="header" href="#property-based">Property-Based</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_addition_property, {
    let strategy = ProptestStrategy::new().with_cases(1000);
    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| {
        a + b == b + a  // Checks for 1000 random pairs
    });
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Advantage</strong>: Tests 1000 random cases automatically.</p>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<h3 id="basic-property-test"><a class="header" href="#basic-property-test">Basic Property Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::property::*;
use proptest::prelude::*;

test!(test_parsing_property, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;u32&gt;(), |num| {
        let formatted = format!("{}", num);
        let parsed: u32 = formatted.parse().unwrap();
        num == parsed  // Property: round-trip works
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="using-generators"><a class="header" href="#using-generators">Using Generators</a></h3>
<p>Generate specific types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_string_properties, {
    let strategy = ProptestStrategy::new().with_cases(100);

    // Test with strings of 1-100 characters
    strategy.test("[a-zA-Z0-9]{1,100}", |s| {
        // Property: non-empty string remains non-empty
        !s.is_empty()
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-properties-to-test"><a class="header" href="#common-properties-to-test">Common Properties to Test</a></h2>
<h3 id="1-commutativity"><a class="header" href="#1-commutativity">1. Commutativity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a + b == b + a
strategy.test(any::&lt;(i32, i32)&gt;(), |(a, b)| {
    a + b == b + a
});
<span class="boring">}</span></code></pre></pre>
<h3 id="2-associativity"><a class="header" href="#2-associativity">2. Associativity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: (a + b) + c == a + (b + c)
strategy.test(any::&lt;(i32, i32, i32)&gt;(), |(a, b, c)| {
    (a + b) + c == a + (b + c)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="3-distributivity"><a class="header" href="#3-distributivity">3. Distributivity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a * (b + c) == (a * b) + (a * c)
strategy.test(any::&lt;(i32, i32, i32)&gt;(), |(a, b, c)| {
    a * (b + c) == (a * b) + (a * c)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="4-identity"><a class="header" href="#4-identity">4. Identity</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a + 0 == a
strategy.test(any::&lt;i32&gt;(), |a| {
    a + 0 == a
});
<span class="boring">}</span></code></pre></pre>
<h3 id="5-inverse"><a class="header" href="#5-inverse">5. Inverse</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Property: a - a == 0
strategy.test(any::&lt;i32&gt;(), |a| {
    a - a == 0
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-json-parsing"><a class="header" href="#real-world-example-json-parsing">Real-World Example: JSON Parsing</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_json_parsing_properties, {
    let strategy = ProptestStrategy::new().with_cases(500);

    strategy.test(any::&lt;(String, i32, bool)&gt;(), |(name, age, active)| {
        // Create JSON
        let json = format!(
            r#"{{"name":"{}","age":{},"active":{}}}"#,
            name, age, active
        );

        // Parse it
        let parsed: Result&lt;MyData, _&gt; = serde_json::from_str(&amp;json);

        // Property: Valid input parses successfully
        parsed.is_ok()
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-string-validation"><a class="header" href="#real-world-example-string-validation">Real-World Example: String Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_email_validation, {
    let strategy = ProptestStrategy::new().with_cases(200);

    // Test valid emails
    strategy.test(
        r"[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,}",
        |email| {
            // Property: Valid email passes validation
            validate_email(email).is_ok()
        }
    );
});
<span class="boring">}</span></code></pre></pre>
<h2 id="shrinking"><a class="header" href="#shrinking">Shrinking</a></h2>
<p>When a property fails, shrinking finds the minimal failing case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_shrinking, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;Vec&lt;i32&gt;&gt;(), |vec| {
        // Property fails for some input
        vec.len() &lt; 10  // This might fail for vec![1,2,3,...,100]

        // Shrinking finds minimal failure: vec with length &gt;= 10
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-strategies"><a class="header" href="#combining-strategies">Combining Strategies</a></h2>
<p>Test multiple values together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_combined_strategy, {
    let strategy = ProptestStrategy::new().with_cases(100);

    // Test with tuple of (String, u32, bool)
    strategy.test(
        (any::&lt;String&gt;(), 1u32..100u32, any::&lt;bool&gt;()),
        |(name, age, active)| {
            // Test with all three values
            !name.is_empty() &amp;&amp; age &gt; 0
        }
    );
});
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="number-of-cases"><a class="header" href="#number-of-cases">Number of Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test with 100 random cases
let strategy = ProptestStrategy::new().with_cases(100);

// Test with 1000 cases (slower, more thorough)
let strategy = ProptestStrategy::new().with_cases(1000);

// Test with 10 cases (faster, less thorough)
let strategy = ProptestStrategy::new().with_cases(10);
<span class="boring">}</span></code></pre></pre>
<h3 id="random-seed"><a class="header" href="#random-seed">Random Seed</a></h3>
<p>For reproducible tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut generator = PropertyTestGenerator::&lt;100, 5&gt;::new()
    .with_seed(42);  // Use specific seed

let data = generator.generate_test_data();
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-property-based-testing"><a class="header" href="#when-to-use-property-based-testing">When to Use Property-Based Testing</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>Mathematical properties (commutativity, associativity)</li>
<li>Round-trip properties (serialize/deserialize)</li>
<li>Parsing and formatting</li>
<li>List operations (sort, filter, map)</li>
<li>State machine transitions</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Specific business logic (use example tests)</li>
<li>Performance testing (use benchmarks)</li>
<li>Complex setup (use fixtures)</li>
</ul>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test actual properties (not specific values)</li>
<li>Use meaningful generators</li>
<li>Start with 100-500 cases</li>
<li>Check edge cases manually</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Replace example tests (both have value)</li>
<li>Use excessive cases (slows down tests)</li>
<li>Ignore failed cases</li>
<li>Only use randomly generated data</li>
</ul>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<ul>
<li>100 cases: ~100ms per property</li>
<li>1000 cases: ~1s per property</li>
<li>10,000 cases: ~10s per property</li>
</ul>
<p><strong>Recommendation</strong>: Start with 100-500 cases. Use more for critical code.</p>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="property-fails-intermittently"><a class="header" href="#property-fails-intermittently">Property Fails Intermittently</a></h3>
<p>Use shrinking output to find minimal case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_debug_failure, {
    let strategy = ProptestStrategy::new().with_cases(1000);
    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| {
        // If fails: check shrunk output
        // Example: shrunk to (0, 0) or (u32::MAX, 0)
        (a as u64) + (b as u64) &lt; u64::MAX
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="property-too-strict"><a class="header" href="#property-too-strict">Property Too Strict</a></h3>
<p>Relax constraints:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Too strict: a * b == b * a (fails due to overflow)
// Better: a.checked_mul(b) == b.checked_mul(a)
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<p>Learn mutation testing: <a href="advanced/mutation-testing.html">Mutation Testing</a></p>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>Property-based testing:</p>
<ul>
<li>‚úÖ Tests properties for all inputs</li>
<li>‚úÖ Finds edge cases automatically</li>
<li>‚úÖ Includes shrinking to find minimal failures</li>
<li>‚úÖ Great for algorithms and parsing</li>
</ul>
<p>Use with fixtures and data builders for comprehensive testing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutation-testing-1"><a class="header" href="#mutation-testing-1">Mutation Testing</a></h1>
<p>Mutation testing validates test quality by introducing mutations (changes) to code and verifying tests catch them.</p>
<h2 id="why-mutation-testing"><a class="header" href="#why-mutation-testing">Why Mutation Testing?</a></h2>
<p>High code coverage doesn't guarantee good tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dangerous_function(x: u32) -&gt; u32 {
    if x &gt; 0 {
        return x * 2;  // Intentional bug: should be x * 3
    }
    0
}

test!(test_bad_coverage, {
    // This test gives 100% code coverage
    assert_eq!(dangerous_function(5), 10);  // This passes even with bug!
    // But tests don't verify the result is CORRECT

    // Bad test - doesn't verify behavior
    assert!(dangerous_function(5) &gt; 0);  // Passes even if returns 99
});
<span class="boring">}</span></code></pre></pre>
<p>Mutation testing fixes this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_mutation, {
    // Arrange
    let mut tester = MutationTester::new(dangerous_function);

    // Apply mutation: change * 2 to * 3
    tester.apply_mutation(MutationOperator::ChangeValue(...));

    // Act: Test catches the mutation
    let caught = tester.test_mutation_detection(|func| {
        func(5) == 10  // This will fail with mutation
    });

    // Assert: Mutation was caught
    assert!(caught);  // ‚úÖ Good test catches mutation
});
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-mutation-testing"><a class="header" href="#basic-mutation-testing">Basic Mutation Testing</a></h2>
<h3 id="creating-a-mutation-tester"><a class="header" href="#creating-a-mutation-tester">Creating a Mutation Tester</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::mutation::*;
use std::collections::HashMap;

test!(test_mutation_basic, {
    let mut data = HashMap::new();
    data.insert("key1".to_string(), "value1".to_string());

    // Create tester
    let mut tester = MutationTester::new(data);

    // Apply mutation: remove a key
    tester.apply_mutation(MutationOperator::RemoveKey("key1".to_string()));

    // Test detects the mutation
    let caught = tester.test_mutation_detection(|data| {
        !data.is_empty()  // Should fail with mutation
    });

    assert!(caught);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-operators"><a class="header" href="#mutation-operators">Mutation Operators</a></h2>
<h3 id="removekey"><a class="header" href="#removekey">RemoveKey</a></h3>
<p>Remove a key from the data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::RemoveKey("key".to_string()));
<span class="boring">}</span></code></pre></pre>
<h3 id="addkey"><a class="header" href="#addkey">AddKey</a></h3>
<p>Add a new key:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::AddKey(
    "new_key".to_string(),
    "new_value".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="changevalue"><a class="header" href="#changevalue">ChangeValue</a></h3>
<p>Change a value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::ChangeValue(
    "key".to_string(),
    "different_value".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="swapvalues"><a class="header" href="#swapvalues">SwapValues</a></h3>
<p>Swap values between two keys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::SwapValues(
    "key1".to_string(),
    "key2".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="toggleboolean"><a class="header" href="#toggleboolean">ToggleBoolean</a></h3>
<p>Toggle a boolean value (flip true/false):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::ToggleBoolean(
    "is_active".to_string()
));
<span class="boring">}</span></code></pre></pre>
<h3 id="numericdelta"><a class="header" href="#numericdelta">NumericDelta</a></h3>
<p>Change a numeric value by a delta:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>tester.apply_mutation(MutationOperator::NumericDelta(
    "count".to_string(),
    10  // Add 10 to the value
));
<span class="boring">}</span></code></pre></pre>
<h3 id="stringcase"><a class="header" href="#stringcase">StringCase</a></h3>
<p>Change string case:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::mutation::CaseMode;

tester.apply_mutation(MutationOperator::StringCase(
    "name".to_string(),
    CaseMode::Upper  // or Lower, Mixed
));
<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-score"><a class="header" href="#mutation-score">Mutation Score</a></h2>
<p>Calculate how many mutations your tests catch:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_mutation_score, {
    let mut data = HashMap::new();
    data.insert("key1".to_string(), "value1".to_string());
    data.insert("key2".to_string(), "value2".to_string());

    let mut tester = MutationTester::new(data);

    // Apply 3 mutations
    let mut caught = 0;

    // Mutation 1: Remove key1
    tester.apply_mutation(MutationOperator::RemoveKey("key1".to_string()));
    if tester.test_mutation_detection(|d| d.contains_key("key1")) {
        caught += 1;
    }

    // Mutation 2: Remove key2
    tester.apply_mutation(MutationOperator::RemoveKey("key2".to_string()));
    if tester.test_mutation_detection(|d| d.contains_key("key2")) {
        caught += 1;
    }

    // Mutation 3: Add key3
    tester.apply_mutation(MutationOperator::AddKey("key3".to_string(), "value3".to_string()));
    if tester.test_mutation_detection(|d| d.len() == 2) {
        caught += 1;
    }

    // Calculate score
    let score = MutationScore::calculate(caught, 3);
    assert!(score.is_acceptable());  // &gt;= 80%

    alert_info!("Mutation score: {}%", score.score());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-user-service"><a class="header" href="#real-world-example-user-service">Real-World Example: User Service</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_service_mutations, {
    let user = User {
        id: 123,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };

    let mut tester = MutationTester::new(user);
    let mut caught = 0;
    let mut total = 0;

    // Test 1: Mutation removes user ID
    total += 1;
    tester.apply_mutation(MutationOperator::ChangeValue(
        "id".to_string(),
        "0".to_string()
    ));
    if tester.test_mutation_detection(|u| u.id &gt; 0) {
        caught += 1;
    }

    // Test 2: Mutation changes name
    total += 1;
    tester.apply_mutation(MutationOperator::ChangeValue(
        "name".to_string(),
        "Bob".to_string()
    ));
    if tester.test_mutation_detection(|u| u.name == "Alice") {
        caught += 1;
    }

    // Test 3: Mutation changes email
    total += 1;
    tester.apply_mutation(MutationOperator::ChangeValue(
        "email".to_string(),
        "bob@example.com".to_string()
    ));
    if tester.test_mutation_detection(|u| u.email == "alice@example.com") {
        caught += 1;
    }

    let score = MutationScore::calculate(caught, total);
    alert_info!("User service mutation score: {}%", score.score());
    assert!(score.is_acceptable());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="interpreting-results"><a class="header" href="#interpreting-results">Interpreting Results</a></h2>
<h3 id="high-mutation-score-80"><a class="header" href="#high-mutation-score-80">High Mutation Score (&gt;80%)</a></h3>
<p>‚úÖ <strong>Good</strong>: Tests are catching mutations</p>
<pre><code>Mutation Score: 95%
- 95 out of 100 mutations caught
- Tests are effective
- High confidence in code quality
</code></pre>
<h3 id="low-mutation-score-80"><a class="header" href="#low-mutation-score-80">Low Mutation Score (&lt;80%)</a></h3>
<p>‚ö†Ô∏è <strong>Warning</strong>: Some mutations slip through</p>
<pre><code>Mutation Score: 60%
- Only 60 out of 100 mutations caught
- 40 mutations go undetected
- May have weak tests or untested branches
</code></pre>
<h3 id="mutations-caught-vs-missed"><a class="header" href="#mutations-caught-vs-missed">Mutations Caught vs. Missed</a></h3>
<pre><code>Mutation "Remove key1" ‚Üí CAUGHT (test failed)
Mutation "Change value" ‚Üí MISSED (test still passed!)
</code></pre>
<p>When mutations are missed, improve tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: Weak test
assert!(data.contains_key("key1"));

// After: Strong test
assert_eq!(data.get("key1").unwrap(), "expected_value");
<span class="boring">}</span></code></pre></pre>
<h2 id="mutation-testing-workflow"><a class="header" href="#mutation-testing-workflow">Mutation Testing Workflow</a></h2>
<ol>
<li><strong>Write tests</strong> (core patterns)</li>
<li><strong>Measure coverage</strong> (80%+ code coverage)</li>
<li><strong>Run mutation tests</strong> (catch mutations)</li>
<li><strong>Improve weak tests</strong> (missing mutations)</li>
<li><strong>Reach 80%+ mutation score</strong></li>
</ol>
<h2 id="when-to-use-mutation-testing"><a class="header" href="#when-to-use-mutation-testing">When to Use Mutation Testing</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>Validating test suite quality</li>
<li>Critical code paths</li>
<li>Security-sensitive code</li>
<li>Core algorithms</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Every test (slow)</li>
<li>Simple tests</li>
<li>Learning phase</li>
<li>Every build</li>
</ul>
<p><strong>Recommendation</strong>: Use mutation testing:</p>
<ul>
<li>During development (spot check)</li>
<li>For critical code (ensure quality)</li>
<li>Occasionally in CI (weekly)</li>
<li>Not every build (too slow)</li>
</ul>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<ul>
<li>Small mutation set: 1-10 mutations (seconds)</li>
<li>Medium set: 10-100 mutations (minutes)</li>
<li>Large set: 100+ mutations (hours)</li>
</ul>
<p><strong>Recommendation</strong>: Limit to 20-50 mutations for regular testing.</p>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Focus on critical code</li>
<li>Test both success and error paths</li>
<li>Improve tests that miss mutations</li>
<li>Calculate mutation score</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Run mutation tests on every commit (slow)</li>
<li>Expect 100% mutation score (impossible)</li>
<li>Ignore missed mutations</li>
<li>Over-optimize for mutation score</li>
</ul>
<h2 id="common-mutations-to-check"><a class="header" href="#common-mutations-to-check">Common Mutations to Check</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Mutation</th><th>What to Test</th></tr></thead><tbody>
<tr><td>RemoveKey</td><td>Verify required keys exist</td></tr>
<tr><td>AddKey</td><td>Verify exact set of keys</td></tr>
<tr><td>ChangeValue</td><td>Verify exact value, not just type</td></tr>
<tr><td>SwapValues</td><td>Verify values aren't accidentally swapped</td></tr>
<tr><td>ToggleBoolean</td><td>Verify both true and false cases</td></tr>
<tr><td>NumericDelta</td><td>Test boundary values and edge cases</td></tr>
<tr><td>StringCase</td><td>Verify case-sensitive comparisons</td></tr>
</tbody></table>
</div>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="mutation-not-caught"><a class="header" href="#mutation-not-caught">Mutation Not Caught</a></h3>
<p>Your test is too weak:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Weak - passes even with mutation
assert!(user.id &gt; 0);

// ‚úÖ Strong - catches changes
assert_eq!(user.id, 123);
<span class="boring">}</span></code></pre></pre>
<h3 id="mutation-score-unrealistic"><a class="header" href="#mutation-score-unrealistic">Mutation Score Unrealistic</a></h3>
<p>Adjust your mutations to match actual bugs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only test realistic mutations
tester.apply_mutation(MutationOperator::ChangeValue(...));

// Skip mutations that don't matter
// (e.g., changing comments, unused variables)
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>Learn snapshot testing: <a href="advanced/snapshot-testing.html">Snapshot Testing</a></p>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Mutation testing:</p>
<ul>
<li>‚úÖ Validates test quality</li>
<li>‚úÖ Catches weak tests</li>
<li>‚úÖ Increases confidence</li>
<li>‚úÖ Target 80%+ score</li>
</ul>
<p>Use for critical code to ensure maximum quality.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="snapshot-testing-1"><a class="header" href="#snapshot-testing-1">Snapshot Testing</a></h1>
<p>Snapshot testing captures output on the first run and compares it on subsequent runs to detect unintended changes.</p>
<h2 id="why-snapshot-testing"><a class="header" href="#why-snapshot-testing">Why Snapshot Testing?</a></h2>
<p>Perfect for testing output that's complex but stable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Hard to maintain
let report = generate_report();
assert_eq!(report, "Employee Report\nAlice: ...\nBob: ...\n");  // 100 lines!

// ‚úÖ Easy to maintain with snapshots
assert_matches!(report, "employee_report");  // Stored in file
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<h3 id="first-run-create-snapshot"><a class="header" href="#first-run-create-snapshot">First Run: Create Snapshot</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_report, {
    let report = generate_report();
    assert_matches!(report, "report");  // Creates report.snap
    // report.snap contains the generated report
});
<span class="boring">}</span></code></pre></pre>
<h3 id="subsequent-runs-compare"><a class="header" href="#subsequent-runs-compare">Subsequent Runs: Compare</a></h3>
<p>If output changes:</p>
<ul>
<li>Old: <code>Employee Report\nAlice: 50000\n</code></li>
<li>New: <code>Employee Report\nAlice: 60000\n</code>  (salary changed)</li>
</ul>
<p>Test shows a <strong>diff</strong>:</p>
<pre><code>- Alice: 50000
+ Alice: 60000
</code></pre>
<p>You review and decide:</p>
<ul>
<li>‚úÖ Accept change (intentional update)</li>
<li>‚ùå Reject change (bug introduced)</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="string-snapshots"><a class="header" href="#string-snapshots">String Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_string_snapshot, {
    let output = "Hello, World!";
    assert_matches!(output, "greeting");
});
<span class="boring">}</span></code></pre></pre>
<p>File <code>greeting.snap</code> contains: <code>Hello, World!</code></p>
<h3 id="json-snapshots"><a class="header" href="#json-snapshots">JSON Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_json_snapshot, {
    let data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("age", "30")
        .build_json()?;

    assert_json_matches!(data, "user_data");
});
<span class="boring">}</span></code></pre></pre>
<p>File <code>user_data.snap</code> contains JSON:</p>
<pre><code class="language-json">{
  "name": "Alice",
  "age": "30"
}
</code></pre>
<h3 id="debug-snapshots"><a class="header" href="#debug-snapshots">Debug Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_debug_snapshot, {
    let user = User { id: 123, name: "Alice".to_string() };
    assert_debug_matches!(user, "user_debug");
});
<span class="boring">}</span></code></pre></pre>
<p>File <code>user_debug.snap</code> contains:</p>
<pre><code>User {
    id: 123,
    name: "Alice",
}
</code></pre>
<h2 id="real-world-example-api-response"><a class="header" href="#real-world-example-api-response">Real-World Example: API Response</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_api_response_snapshot, {
    let client = ApiClient::new();
    let response = client.get_users()?;

    // Snapshot the API response
    assert_json_matches!(response, "api_users_response");

    // If API adds fields, you'll see a diff
    // Review and accept if intentional
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-report-generation"><a class="header" href="#real-world-example-report-generation">Real-World Example: Report Generation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_report_snapshot, {
    let data = vec![
        Employee { name: "Alice".to_string(), salary: 50000 },
        Employee { name: "Bob".to_string(), salary: 60000 },
    ];

    let report = generate_report(&amp;data)?;

    // Snapshot the entire report
    assert_matches!(report, "employee_report");

    // Changes to formatting or content show up immediately
});
<span class="boring">}</span></code></pre></pre>
<h2 id="workflow-accepting-changes"><a class="header" href="#workflow-accepting-changes">Workflow: Accepting Changes</a></h2>
<p>When you intentionally change output:</p>
<h3 id="step-1-run-tests"><a class="header" href="#step-1-run-tests">Step 1: Run Tests</a></h3>
<pre><code class="language-bash">cargo test --features snapshot-testing
# Tests fail with diff if snapshot changed
</code></pre>
<h3 id="step-2-review-diff"><a class="header" href="#step-2-review-diff">Step 2: Review Diff</a></h3>
<pre><code>- Alice: 50000
+ Alice: 60000
</code></pre>
<h3 id="step-3-accept-or-reject"><a class="header" href="#step-3-accept-or-reject">Step 3: Accept or Reject</a></h3>
<pre><code class="language-bash"># Review snapshot changes
cargo insta review

# Or programmatically
insta::assert_snapshot!(output);  // Accepts in CI if --accept-all
</code></pre>
<h3 id="step-4-commit-changes"><a class="header" href="#step-4-commit-changes">Step 4: Commit Changes</a></h3>
<pre><code class="language-bash">git add snapshot.snap
git commit -m "Update snapshot for salary changes"
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="snapshot-paths"><a class="header" href="#snapshot-paths">Snapshot Paths</a></h3>
<p>Control where snapshots are stored:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_with_custom_path() {
    let settings = insta::Settings::clone_current();
    settings.set_snapshot_dir("tests/snapshots");
    settings.bind(|| {
        insta::assert_snapshot!("my_test", "output");
    });
}
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshot-cleanup"><a class="header" href="#snapshot-cleanup">Snapshot Cleanup</a></h3>
<p>Remove old snapshots:</p>
<pre><code class="language-bash"># Remove unused snapshots
insta::cleanup_unused_snapshots!();
</code></pre>
<h2 id="snapshot-comparisons"><a class="header" href="#snapshot-comparisons">Snapshot Comparisons</a></h2>
<h3 id="inline-snapshots"><a class="header" href="#inline-snapshots">Inline Snapshots</a></h3>
<p>Store snapshot in test file (useful for small outputs):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_inline_snapshot, {
    let result = simple_function();
    insta::assert_snapshot!("simple_function", @"expected output");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="file-snapshots"><a class="header" href="#file-snapshots">File Snapshots</a></h3>
<p>Store snapshot in separate file (better for large outputs):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_file_snapshot, {
    let result = large_report();
    assert_matches!(result, "large_report");  // Stored in file
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use for stable, complex output</li>
<li>Review diffs carefully</li>
<li>Commit snapshot changes</li>
<li>Version control snapshots</li>
<li>Update when intentional changes occur</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use for simple outputs (too much overhead)</li>
<li>Use for non-deterministic output (timestamps, random data)</li>
<li>Blindly accept all changes</li>
<li>Skip reviewing diffs</li>
<li>Use for performance data (it changes)</li>
</ul>
<h2 id="when-to-use-snapshots"><a class="header" href="#when-to-use-snapshots">When to Use Snapshots</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>API responses</li>
<li>Generated reports</li>
<li>Formatted output</li>
<li>Complex data structures</li>
<li>UI/HTML output</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Simple assertions (<code>assert_eq!</code>)</li>
<li>Non-deterministic output</li>
<li>Performance metrics</li>
<li>Timestamps</li>
</ul>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Snapshots are fast:</p>
<ul>
<li>First run: Create snapshot (~1ms)</li>
<li>Subsequent runs: Compare (~1ms)</li>
</ul>
<p>No performance overhead.</p>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="snapshot-not-updating"><a class="header" href="#snapshot-not-updating">Snapshot Not Updating</a></h3>
<p>Check file permissions:</p>
<pre><code class="language-bash">ls -la tests/snapshots/
# Should be readable/writable
</code></pre>
<h3 id="snapshot-too-long"><a class="header" href="#snapshot-too-long">Snapshot Too Long</a></h3>
<p>Break into multiple snapshots:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå One large snapshot
assert_matches!(entire_report, "report");

// ‚úÖ Multiple focused snapshots
assert_matches!(report.header, "report_header");
assert_matches!(report.body, "report_body");
assert_matches!(report.footer, "report_footer");
<span class="boring">}</span></code></pre></pre>
<h3 id="non-deterministic-output"><a class="header" href="#non-deterministic-output">Non-Deterministic Output</a></h3>
<p>Normalize data before snapshotting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Timestamps change every run
let output = format!("Time: {}", now());
assert_matches!(output, "output");

// ‚úÖ Normalize timestamps
let output = "Time: [TIMESTAMP]";
assert_matches!(output, "output");
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-with-other-techniques"><a class="header" href="#combining-with-other-techniques">Combining with Other Techniques</a></h2>
<h3 id="snapshots--property-based-testing"><a class="header" href="#snapshots--property-based-testing">Snapshots + Property-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_snapshot_property, {
    let strategy = ProptestStrategy::new().with_cases(10);

    strategy.test(any::&lt;u32&gt;(), |num| {
        let formatted = format!("{}", num);
        let parsed: u32 = formatted.parse().unwrap();

        // Snapshot the first case
        if num == 1 {
            assert_matches!(formatted, "formatted_number");
        }

        num == parsed
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshots--fixtures"><a class="header" href="#snapshots--fixtures">Snapshots + Fixtures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_snapshot_fixture, {
    let fixture = TestFixture::new()?;
    let report = generate_report(&amp;fixture)?;
    assert_matches!(report, "fixture_report");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<p>Learn CLI testing: <a href="advanced/cli-testing.html">CLI Testing</a></p>
<hr />
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>Snapshot testing:</p>
<ul>
<li>‚úÖ Captures complex output</li>
<li>‚úÖ Detects unintended changes</li>
<li>‚úÖ Easy to review diffs</li>
<li>‚úÖ Great for regression detection</li>
</ul>
<p>Perfect for generated output and API responses.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-testing-1"><a class="header" href="#cli-testing-1">CLI Testing</a></h1>
<p>Test command-line interfaces using golden files (<code>.trycmd</code>) to verify commands work correctly.</p>
<h2 id="why-cli-testing"><a class="header" href="#why-cli-testing">Why CLI Testing?</a></h2>
<p>CLIs are complex because they involve:</p>
<ul>
<li>Argument parsing</li>
<li>Environment variables</li>
<li>Output formatting</li>
<li>Exit codes</li>
<li>Error messages</li>
</ul>
<p>Golden file testing captures all of this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Golden file testing
test!(test_cli, {
    let output = run_command("myapp", vec!["list", "--verbose"]);
    assert_matches!(output, "cli_list_verbose");  // .trycmd file
});
<span class="boring">}</span></code></pre></pre>
<p>The <code>.trycmd</code> file contains:</p>
<pre><code>$ myapp list --verbose
stdout: Item 1
        Item 2
exit-code: 0
</code></pre>
<h2 id="basic-cli-testing"><a class="header" href="#basic-cli-testing">Basic CLI Testing</a></h2>
<h3 id="creating-a-test-command"><a class="header" href="#creating-a-test-command">Creating a Test Command</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::cli::*;

test!(test_cli_basic, {
    let output = CliTest::new("myapp", vec!["help"])
        .run()?;

    assert!(output.contains("Usage:"));
    assert!(output.contains("Options:"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-with-arguments"><a class="header" href="#testing-with-arguments">Testing with Arguments</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_with_args, {
    let output = CliTest::new("myapp", vec![
        "process",
        "--input", "data.txt",
        "--output", "result.txt",
        "--verbose"
    ]).run()?;

    assert!(output.contains("Processing"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-environment-variables"><a class="header" href="#testing-environment-variables">Testing Environment Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_with_env, {
    let output = CliTest::new("myapp", vec!["list"])
        .env("LOG_LEVEL", "DEBUG")
        .env("TIMEOUT", "30")
        .run()?;

    assert!(output.contains("DEBUG"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="golden-file-format-trycmd"><a class="header" href="#golden-file-format-trycmd">Golden File Format (.trycmd)</a></h2>
<p>Golden files store expected output:</p>
<pre><code>$ myapp list
Item 1
Item 2
Item 3

$ myapp list --filter active
Item 1
Item 3
</code></pre>
<h3 id="command-line"><a class="header" href="#command-line">Command Line</a></h3>
<pre><code>$ myapp [args]
</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><code>stdout:
Actual command output
Goes here

stderr:
Error output if applicable
</code></pre>
<h3 id="exit-code"><a class="header" href="#exit-code">Exit Code</a></h3>
<pre><code>exit-code: 0  (Success)
exit-code: 1  (Failure)
</code></pre>
<h2 id="real-world-example-file-tool"><a class="header" href="#real-world-example-file-tool">Real-World Example: File Tool</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_file_commands, {
    // List files
    let list_output = CliTest::new("filetool", vec!["list"])
        .run()?;
    assert!(list_output.contains("data.txt"));

    // Copy file
    let copy_output = CliTest::new("filetool", vec![
        "copy",
        "source.txt",
        "dest.txt"
    ]).run()?;
    assert!(copy_output.contains("Copied"));

    // Delete file
    let del_output = CliTest::new("filetool", vec![
        "delete",
        "old.txt"
    ]).run()?;
    assert!(del_output.contains("Deleted"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-configuration-tool"><a class="header" href="#real-world-example-configuration-tool">Real-World Example: Configuration Tool</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_config_commands, {
    // Get config
    let output = CliTest::new("config", vec!["get", "database.host"])
        .env("CONFIG_PATH", "./config.toml")
        .run()?;
    assert!(output.contains("localhost"));

    // Set config
    let output = CliTest::new("config", vec!["set", "database.port", "5433"])
        .env("CONFIG_PATH", "./config.toml")
        .run()?;
    assert!(output.contains("Updated"));

    // List all config
    let output = CliTest::new("config", vec!["list"])
        .run()?;
    assert!(output.contains("database.host"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="error-testing"><a class="header" href="#error-testing">Error Testing</a></h2>
<h3 id="command-failures"><a class="header" href="#command-failures">Command Failures</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_errors, {
    // Wrong arguments
    let output = CliTest::new("myapp", vec!["invalid-command"])
        .run();

    assert!(output.is_err());  // Command failed
});
<span class="boring">}</span></code></pre></pre>
<h3 id="exit-codes"><a class="header" href="#exit-codes">Exit Codes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_exit_codes, {
    // Success
    let result = CliTest::new("myapp", vec!["list"]).run()?;
    assert_eq!(result.exit_code, 0);

    // Failure
    let result = CliTest::new("myapp", vec!["error"]).run()?;
    assert_ne!(result.exit_code, 0);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="assertion-helpers"><a class="header" href="#assertion-helpers">Assertion Helpers</a></h2>
<h3 id="contains"><a class="header" href="#contains">Contains</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_contains, {
    let output = CliTest::new("myapp", vec!["help"]).run()?;
    assert!(output.contains("Usage:"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="matches-pattern"><a class="header" href="#matches-pattern">Matches Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_pattern, {
    let output = CliTest::new("myapp", vec!["version"]).run()?;
    assert!(output.contains("v1."));  // Matches v1.0, v1.1, etc.
});
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshot"><a class="header" href="#snapshot">Snapshot</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_snapshot, {
    let output = CliTest::new("myapp", vec!["help"]).run()?;
    assert_matches!(output, "myapp_help");  // Golden file
});
<span class="boring">}</span></code></pre></pre>
<h2 id="comprehensive-cli-test"><a class="header" href="#comprehensive-cli-test">Comprehensive CLI Test</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_comprehensive, {
    // Test 1: Help works
    let help = CliTest::new("mytool", vec!["help"]).run()?;
    assert!(help.contains("Usage:"));

    // Test 2: List works
    let list = CliTest::new("mytool", vec!["list"]).run()?;
    assert!(list.contains("Item"));

    // Test 3: Filter works
    let filtered = CliTest::new("mytool", vec![
        "list",
        "--filter", "active"
    ]).run()?;
    assert!(filtered.contains("Item 1"));

    // Test 4: Sort works
    let sorted = CliTest::new("mytool", vec![
        "list",
        "--sort", "name"
    ]).run()?;
    let lines: Vec&lt;_&gt; = sorted.lines().collect();
    assert!(lines.len() &gt;= 2);

    // Test 5: Output format
    let json = CliTest::new("mytool", vec![
        "list",
        "--format", "json"
    ]).run()?;
    assert!(json.contains("{"));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test all major commands</li>
<li>Test error cases</li>
<li>Test environment variables</li>
<li>Test output format</li>
<li>Use golden files for complex output</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Hard-code full output (use snapshots)</li>
<li>Test implementation details</li>
<li>Ignore error exit codes</li>
<li>Use shell pipes in tests</li>
<li>Test external commands</li>
</ul>
<h2 id="when-to-use-cli-testing"><a class="header" href="#when-to-use-cli-testing">When to Use CLI Testing</a></h2>
<p>‚úÖ <strong>Use for:</strong></p>
<ul>
<li>CLI applications</li>
<li>Command subcommands</li>
<li>Argument parsing</li>
<li>Output formatting</li>
<li>Error messages</li>
</ul>
<p>‚ùå <strong>Don't use for:</strong></p>
<ul>
<li>Library functions (use unit tests)</li>
<li>Web services (use integration tests)</li>
<li>Complex pipelines (too fragile)</li>
</ul>
<h2 id="combining-with-other-techniques-1"><a class="header" href="#combining-with-other-techniques-1">Combining with Other Techniques</a></h2>
<h3 id="cli--snapshots"><a class="header" href="#cli--snapshots">CLI + Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_snapshot, {
    let output = CliTest::new("myapp", vec!["help"]).run()?;
    assert_matches!(output, "help_output");  // Snapshot
});
<span class="boring">}</span></code></pre></pre>
<h3 id="cli--properties"><a class="header" href="#cli--properties">CLI + Properties</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_cli_properties, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;String&gt;(), |cmd| {
        let output = CliTest::new("myapp", vec![&amp;cmd]).run();
        // Property: Command doesn't crash
        true  // If crashes, test fails
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="test-fails-with-different-output"><a class="header" href="#test-fails-with-different-output">Test Fails with Different Output</a></h3>
<p>Check for:</p>
<ul>
<li>Timestamps (use <code>[TIMESTAMP]</code>)</li>
<li>UUIDs (use <code>[UUID]</code>)</li>
<li>Paths (use relative paths)</li>
</ul>
<h3 id="command-not-found"><a class="header" href="#command-not-found">Command Not Found</a></h3>
<p>Ensure binary is built:</p>
<pre><code class="language-bash">cargo build --bin myapp
# Then tests can run it
</code></pre>
<h3 id="flaky-tests"><a class="header" href="#flaky-tests">Flaky Tests</a></h3>
<p>Normalize output:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let output = CliTest::new("myapp", vec!["status"]).run()?;
let normalized = output.replace("2024-11-15", "[DATE]");
assert!(normalized.contains("Started on [DATE]"));
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>Learn concurrency testing: <a href="advanced/concurrency-testing.html">Concurrency Testing</a></p>
<hr />
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>CLI testing:</p>
<ul>
<li>‚úÖ Tests command-line interfaces</li>
<li>‚úÖ Uses golden files</li>
<li>‚úÖ Detects output changes</li>
<li>‚úÖ Verifies exit codes</li>
</ul>
<p>Perfect for CLI applications and scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-testing-1"><a class="header" href="#concurrency-testing-1">Concurrency Testing</a></h1>
<p>Test thread-safe code with deterministic thread ordering using loom.</p>
<h2 id="why-concurrency-testing"><a class="header" href="#why-concurrency-testing">Why Concurrency Testing?</a></h2>
<p>Normal tests run threads in random order - race conditions may not appear:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå This might pass or fail randomly
test!(test_race_condition, {
    let data = Arc::new(Mutex::new(0));
    let data_clone = data.clone();

    thread::spawn(move || {
        *data_clone.lock().unwrap() += 1;
    });

    thread::sleep(Duration::from_millis(1));
    let result = *data.lock().unwrap();
    assert_eq!(result, 1);  // Might fail if thread hasn't run yet
});
<span class="boring">}</span></code></pre></pre>
<p>Loom testing explores <strong>all possible interleavings</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ This tests all possible thread orderings
test!(test_with_loom, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));
        let data_clone = data.clone();

        thread::spawn(move || {
            *data_clone.lock().unwrap() += 1;
        });

        let result = *data.lock().unwrap();
        assert_eq!(result, 1);  // Tests all interleavings
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="basic-loom-testing"><a class="header" href="#basic-loom-testing">Basic Loom Testing</a></h2>
<h3 id="simple-loom-model"><a class="header" href="#simple-loom-model">Simple Loom Model</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::concurrency::*;
use std::sync::{Arc, Mutex};

test!(test_basic_loom, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));
        let value = *data.lock().unwrap();
        assert_eq!(value, 0);
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="two-threads"><a class="header" href="#two-threads">Two Threads</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_two_threads, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));

        let data_clone = data.clone();
        thread::spawn(move || {
            *data_clone.lock().unwrap() += 1;
        });

        let result = *data.lock().unwrap();
        // Loom tests both possible interleavings:
        // 1. Main thread reads first (0)
        // 2. Worker thread increments first (1)
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-counter"><a class="header" href="#real-world-example-counter">Real-World Example: Counter</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_concurrent_counter, {
    loom::model(|| {
        let counter = Arc::new(Mutex::new(0));

        let mut handles = vec![];

        // Spawn 3 threads
        for _ in 0..3 {
            let counter = counter.clone();
            let handle = thread::spawn(move || {
                *counter.lock().unwrap() += 1;
            });
            handles.push(handle);
        }

        // Wait for all threads
        for handle in handles {
            handle.join().unwrap();
        }

        // All threads should have incremented
        assert_eq!(*counter.lock().unwrap(), 3);
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-channel-communication"><a class="header" href="#real-world-example-channel-communication">Real-World Example: Channel Communication</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_channel_communication, {
    loom::model(|| {
        let (tx, rx) = std::sync::mpsc::channel();

        thread::spawn(move || {
            tx.send(42).unwrap();
        });

        let value = rx.recv().unwrap();
        assert_eq!(value, 42);
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="common-concurrency-patterns"><a class="header" href="#common-concurrency-patterns">Common Concurrency Patterns</a></h2>
<h3 id="mutex-protection"><a class="header" href="#mutex-protection">Mutex Protection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_mutex_safety, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(vec![]));

        let data_clone = data.clone();
        thread::spawn(move || {
            data_clone.lock().unwrap().push(1);
        });

        data.lock().unwrap().push(2);
        let result = data.lock().unwrap();
        assert_eq!(result.len(), 2);
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="rwlock-reader-writer-lock"><a class="header" href="#rwlock-reader-writer-lock">RwLock (Reader-Writer Lock)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_rwlock, {
    loom::model(|| {
        let data = Arc::new(RwLock::new(0));

        let data_clone = data.clone();
        thread::spawn(move || {
            *data_clone.write().unwrap() = 42;
        });

        let value = *data.read().unwrap();
        assert_eq!(value, 42);
    });
});
<span class="boring">}</span></code></pre></pre>
<h3 id="atomic-operations"><a class="header" href="#atomic-operations">Atomic Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_atomic, {
    loom::model(|| {
        use std::sync::atomic::{AtomicU32, Ordering};

        let counter = Arc::new(AtomicU32::new(0));

        let counter_clone = counter.clone();
        thread::spawn(move || {
            counter_clone.fetch_add(1, Ordering::SeqCst);
        });

        let value = counter.load(Ordering::SeqCst);
        // Value might be 0 or 1 depending on scheduling
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="detecting-race-conditions"><a class="header" href="#detecting-race-conditions">Detecting Race Conditions</a></h2>
<h3 id="race-condition-example"><a class="header" href="#race-condition-example">Race Condition Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_detects_race_condition, {
    loom::model(|| {
        let data = Arc::new(Cell::new(0));  // ‚ùå Not thread-safe!

        let data_clone = data.clone();
        thread::spawn(move || {
            data_clone.set(data_clone.get() + 1);
        });

        // This will fail with loom!
        // Cell doesn't provide synchronization
    });
});
<span class="boring">}</span></code></pre></pre>
<p>Loom detects this because <code>Cell</code> isn't thread-safe.</p>
<h3 id="use-mutex-instead"><a class="header" href="#use-mutex-instead">Use Mutex Instead</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_thread_safe, {
    loom::model(|| {
        let data = Arc::new(Mutex::new(0));  // ‚úÖ Thread-safe

        let data_clone = data.clone();
        thread::spawn(move || {
            *data_clone.lock().unwrap() += 1;
        });

        let result = *data.lock().unwrap();
        // Now safe for all interleavings
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-for-deadlocks"><a class="header" href="#testing-for-deadlocks">Testing for Deadlocks</a></h2>
<p>Loom can detect potential deadlocks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_deadlock_detection, {
    loom::model(|| {
        let lock1 = Arc::new(Mutex::new(0));
        let lock2 = Arc::new(Mutex::new(0));

        let (lock1_clone, lock2_clone) = (lock1.clone(), lock2.clone());
        thread::spawn(move || {
            // Thread 1: Lock in order lock1, lock2
            let _g1 = lock1_clone.lock().unwrap();
            let _g2 = lock2_clone.lock().unwrap();
        });

        // Main thread: Lock in opposite order lock2, lock1
        // Loom will explore both interleavings
        // Can detect potential deadlock!
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test small, focused scenarios</li>
<li>Use appropriate synchronization primitives</li>
<li>Test with few threads (2-3 typical)</li>
<li>Verify all possible interleavings</li>
<li>Use Loom for critical concurrent code</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Test large thread pools (explodes combinations)</li>
<li>Mix blocking I/O with Loom (I/O not deterministic)</li>
<li>Over-test (Loom is slow, only use for critical code)</li>
<li>Assume one test covers all cases</li>
</ul>
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<p>Loom explores all interleavings - it's <strong>slow</strong>:</p>
<ul>
<li>Simple model (2 threads): 10ms - 100ms</li>
<li>Complex model (3 threads): 100ms - 1s</li>
<li>Many threads: Can be very slow</li>
</ul>
<p><strong>Recommendation</strong>:</p>
<ul>
<li>Only use Loom for critical synchronization</li>
<li>Test with 2-3 threads, not more</li>
<li>Use normal tests for non-concurrent code</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Loom only works with:</p>
<ul>
<li>Loom-aware primitives (<code>loom::sync</code>)</li>
<li>Thread creation (<code>loom::thread</code>)</li>
<li>Standard Rust types it instruments</li>
</ul>
<p>Cannot test:</p>
<ul>
<li>Real time (time is controlled)</li>
<li>System I/O (returns dummy values)</li>
<li>External libraries (unless they use loom)</li>
</ul>
<h2 id="combining-with-other-techniques-2"><a class="header" href="#combining-with-other-techniques-2">Combining with Other Techniques</a></h2>
<h3 id="concurrency--property-based"><a class="header" href="#concurrency--property-based">Concurrency + Property-Based</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_concurrent_property, {
    loom::model(|| {
        let counter = Arc::new(Mutex::new(0));

        for i in 0..5 {
            let counter = counter.clone();
            thread::spawn(move || {
                *counter.lock().unwrap() += i;
            });
        }

        // Verify invariant holds
        let sum: u32 = (0..5).sum();
        assert!(*counter.lock().unwrap() &lt;= sum);
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-integration-example-1"><a class="header" href="#real-world-integration-example-1">Real-World Integration Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_thread_pool_safety, {
    loom::model(|| {
        let task_queue = Arc::new(Mutex::new(vec![]));
        let result_queue = Arc::new(Mutex::new(vec![]));

        // Producer
        {
            let queue = task_queue.clone();
            thread::spawn(move || {
                queue.lock().unwrap().push("task1");
            });
        }

        // Consumer
        {
            let task_queue = task_queue.clone();
            let result_queue = result_queue.clone();
            thread::spawn(move || {
                if let Some(task) = task_queue.lock().unwrap().pop() {
                    result_queue.lock().unwrap().push(format!("done: {}", task));
                }
            });
        }

        // Verify result eventually
        // (Loom explores all orderings)
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-6"><a class="header" href="#troubleshooting-6">Troubleshooting</a></h2>
<h3 id="too-many-interleavings"><a class="header" href="#too-many-interleavings">"Too many interleavings"</a></h3>
<p>Reduce complexity:</p>
<ul>
<li>Use fewer threads</li>
<li>Smaller critical sections</li>
<li>Simpler synchronization patterns</li>
</ul>
<h3 id="this-synchronization-is-not-supported"><a class="header" href="#this-synchronization-is-not-supported">"This synchronization is not supported"</a></h3>
<p>Use only Loom-supported primitives:</p>
<ul>
<li><code>loom::sync::Mutex</code></li>
<li><code>loom::sync::RwLock</code></li>
<li><code>std::sync::atomic</code></li>
<li><code>std::sync::mpsc</code></li>
</ul>
<h3 id="test-still-hangsdeadlocks"><a class="header" href="#test-still-hangsdeadlocks">Test Still Hangs/Deadlocks</a></h3>
<p>Loom doesn't catch all deadlocks. Use timeouts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
#[timeout = "5s"]  // Add timeout
fn test_with_timeout() {
    loom::model(|| {
        // Test code
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<p>Learn the "Go the Extra Mile" pattern: <a href="advanced/../guides/extra-mile.html">Go the Extra Mile</a></p>
<hr />
<h2 id="summary-8"><a class="header" href="#summary-8">Summary</a></h2>
<p>Concurrency testing with Loom:</p>
<ul>
<li>‚úÖ Tests all possible thread interleavings</li>
<li>‚úÖ Detects race conditions</li>
<li>‚úÖ Verifies synchronization correctness</li>
<li>‚úÖ Finds potential deadlocks</li>
</ul>
<p>Use for critical concurrent code to ensure thread safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-go-the-extra-mile-pattern"><a class="header" href="#the-go-the-extra-mile-pattern">The "Go the Extra Mile" Pattern</a></h1>
<p>The "Go the Extra Mile" pattern demonstrates progressive enhancement from simple solutions to maximum-value solutions.</p>
<h2 id="the-three-ideas-framework"><a class="header" href="#the-three-ideas-framework">The Three Ideas Framework</a></h2>
<h3 id="1st-idea-solve-the-problem"><a class="header" href="#1st-idea-solve-the-problem">1st Idea: Solve the Problem</a></h3>
<p>Minimal scope, just solves the immediate need:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1st Idea: Parse u32 only
pub fn parse_u32(input: &amp;str) -&gt; Result&lt;u32, String&gt; {
    input.parse().map_err(|e| format!("Parse error: {e}"))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Single type (<code>u32</code> only)</li>
<li>No telemetry</li>
<li>No validation</li>
<li>Solves the problem ‚úì</li>
</ul>
<h3 id="2nd-idea-8020-sweet-spot"><a class="header" href="#2nd-idea-8020-sweet-spot">2nd Idea: 80/20 Sweet Spot</a></h3>
<p>Generic version with significant value added:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2nd Idea: Generic parser
pub fn parse_number&lt;T: FromStr&gt;(input: &amp;str) -&gt; Result&lt;T, String&gt;
where
    T::Err: Display,
{
    input.parse().map_err(|e| format!("Parse error: {e}"))
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Works for all number types (<code>u32</code>, <code>i32</code>, <code>f64</code>, etc.)</li>
<li>Minimal additional effort</li>
<li>80% more value</li>
<li>20% more work</li>
</ul>
<p><strong>When to use</strong>: Most of the time (best cost/benefit ratio)</p>
<h3 id="3rd-idea-maximum-value"><a class="header" href="#3rd-idea-maximum-value">3rd Idea: Maximum Value</a></h3>
<p>Full-featured solution with complete correctness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd Idea: Type-validated with OTEL instrumentation
pub struct ValidatedNumber&lt;T&gt; {
    value: T,
    span: Span,  // OTEL instrumentation
}

impl&lt;T: FromStr&gt; ValidatedNumber&lt;T&gt; {
    pub fn parse(input: &amp;str, span_name: &amp;str) -&gt; Result&lt;Self, String&gt; {
        // Type-level validation prevents errors
        // OTEL spans provide observability
        // Weaver validation ensures compliance
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Type-level validation (prevents entire classes of errors)</li>
<li>OTEL instrumentation (observability)</li>
<li>Weaver validation (schema compliance)</li>
<li>Maximum value</li>
<li>Significant additional effort</li>
</ul>
<p><strong>When to use</strong>: For critical code where correctness is paramount</p>
<h2 id="decision-framework"><a class="header" href="#decision-framework">Decision Framework</a></h2>
<pre><code>Does the code need:
‚îú‚îÄ Basic functionality only?
‚îÇ  ‚îî‚îÄ 1st Idea ‚úì
‚îú‚îÄ Works for multiple types + some observability?
‚îÇ  ‚îî‚îÄ 2nd Idea ‚úì (usually best choice)
‚îî‚îÄ Type safety + full observability + validation?
   ‚îî‚îÄ 3rd Idea ‚úì (for critical paths)
</code></pre>
<h2 id="real-world-example-configuration-loader"><a class="header" href="#real-world-example-configuration-loader">Real-World Example: Configuration Loader</a></h2>
<h3 id="1st-idea-load-from-env"><a class="header" href="#1st-idea-load-from-env">1st Idea: Load from ENV</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_config() -&gt; Result&lt;Config, String&gt; {
    let host = std::env::var("DB_HOST")
        .map_err(|e| format!("Missing DB_HOST: {e}"))?;
    let port = std::env::var("DB_PORT")
        .map_err(|e| format!("Missing DB_PORT: {e}"))?
        .parse::&lt;u16&gt;()
        .map_err(|e| format!("Invalid port: {e}"))?;

    Ok(Config { host, port })
}
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Works
‚ùå Only ENV, no file support, no validation</p>
<h3 id="2nd-idea-env--file-support"><a class="header" href="#2nd-idea-env--file-support">2nd Idea: ENV + File Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load_config(source: &amp;str) -&gt; Result&lt;Config, String&gt; {
    match source {
        "env" =&gt; load_from_env(),
        "file" =&gt; load_from_file(),
        _ =&gt; Err("Invalid source".to_string()),
    }
}

fn load_from_env() -&gt; Result&lt;Config, String&gt; { /* ... */ }
fn load_from_file() -&gt; Result&lt;Config, String&gt; { /* ... */ }
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Works for multiple sources
‚úÖ 80% more value (supports files, ENV)
‚úì Best choice for most cases</p>
<h3 id="3rd-idea-type-safe-with-validation--otel"><a class="header" href="#3rd-idea-type-safe-with-validation--otel">3rd Idea: Type-Safe with Validation + OTEL</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidatedConfig {
    config: Config,
    span: Span,  // OTEL span
}

impl ValidatedConfig {
    pub fn load(source: &amp;str, span_name: &amp;str) -&gt; Result&lt;Self, String&gt; {
        let start = SystemTime::now();

        // Load config
        let config = load_config(source)?;

        // Validate
        validate_config(&amp;config)?;

        // Create OTEL span
        let mut span = create_span(span_name);
        span.attributes.insert("source".to_string(), source.to_string());

        let end = SystemTime::now();
        span.complete(end.duration_since(start).ok()?)?;

        Ok(Self { config, span })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>‚úÖ Type-safe configuration
‚úÖ OTEL instrumentation
‚úÖ Validation enforcement
‚úì For mission-critical systems</p>
<h2 id="applying-the-pattern-step-by-step"><a class="header" href="#applying-the-pattern-step-by-step">Applying the Pattern: Step by Step</a></h2>
<h3 id="step-1-start-simple"><a class="header" href="#step-1-start-simple">Step 1: Start Simple</a></h3>
<p>Write the simplest thing that works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn process_user(id: u32) -&gt; Result&lt;User, String&gt; {
    // Query database
    let user = query_db(id)?;
    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-consider-8020"><a class="header" href="#step-2-consider-8020">Step 2: Consider 80/20</a></h3>
<p>Does adding a feature provide disproportionate value?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2nd Idea: Support both ID and email lookup
pub fn get_user(identifier: &amp;str) -&gt; Result&lt;User, String&gt; {
    if let Ok(id) = identifier.parse::&lt;u32&gt;() {
        query_db_by_id(id)
    } else {
        query_db_by_email(identifier)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Cost: +10 lines
Value: 80% more functionality</p>
<h3 id="step-3-evaluate-going-further"><a class="header" href="#step-3-evaluate-going-further">Step 3: Evaluate Going Further</a></h3>
<p>Is maximum value worth the effort?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd Idea: Type-safe, validated, instrumented
pub struct ValidatedUser {
    user: User,
    span: Span,
}

impl ValidatedUser {
    pub fn get(identifier: &amp;str) -&gt; Result&lt;Self, String&gt; {
        // Validation + OTEL + error handling
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Cost: +50 lines
Value: Type safety + observability</p>
<p><strong>Decision</strong>: Only go to 3rd idea if the value justifies the effort.</p>
<h2 id="when-to-stop-at-1st-idea"><a class="header" href="#when-to-stop-at-1st-idea">When to Stop at 1st Idea</a></h2>
<p>‚úÖ For utilities that are:</p>
<ul>
<li>Well-isolated</li>
<li>Simple logic</li>
<li>Low risk</li>
<li>Rarely changed</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1st idea is fine here - simple utility
pub fn format_currency(amount: f64) -&gt; String {
    format!("${:.2}", amount)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-2nd-idea-most-common"><a class="header" href="#when-to-use-2nd-idea-most-common">When to Use 2nd Idea (Most Common)</a></h2>
<p>‚úÖ For code that is:</p>
<ul>
<li>Reused in multiple places</li>
<li>Needs flexibility</li>
<li>Not mission-critical</li>
<li>Has room for improvements</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2nd idea - generic, flexible, good value
pub fn parse&lt;T: FromStr&gt;(input: &amp;str) -&gt; Result&lt;T, String&gt; {
    input.parse().map_err(|e| format!("Parse error: {e}"))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="when-to-use-3rd-idea"><a class="header" href="#when-to-use-3rd-idea">When to Use 3rd Idea</a></h2>
<p>‚úÖ For code that is:</p>
<ul>
<li>Mission-critical (payments, security, core logic)</li>
<li>Needs full observability</li>
<li>Must prevent errors at compile time</li>
<li>Complex enough to benefit from type system</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3rd idea - type-safe, critical path
pub struct ValidatedPayment {
    amount: PositiveAmount,
    currency: ValidatedCurrency,
    span: Span,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="combining-ideas-in-one-system"><a class="header" href="#combining-ideas-in-one-system">Combining Ideas in One System</a></h2>
<p>A production system uses all three:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1st Idea: Simple utilities
fn format_time(secs: u64) -&gt; String { /* simple */ }

// 2nd Idea: Core operations (most code)
fn parse_config(source: &amp;str) -&gt; Result&lt;Config, String&gt; { /* generic */ }

// 3rd Idea: Mission-critical operations
struct ValidatedPayment { /* type-safe, instrumented */ }
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits-of-this-pattern"><a class="header" href="#benefits-of-this-pattern">Benefits of This Pattern</a></h2>
<ol>
<li><strong>Clear thinking</strong>: Forces you to consider scope and value</li>
<li><strong>Cost-benefit</strong>: Justified effort for each level</li>
<li><strong>Flexibility</strong>: Easy to upgrade later</li>
<li><strong>Clarity</strong>: Team understands why certain code is complex</li>
</ol>
<h2 id="common-mistakes"><a class="header" href="#common-mistakes">Common Mistakes</a></h2>
<p>‚ùå <strong>Always using 3rd idea</strong></p>
<ul>
<li>Over-engineered simple code</li>
<li>Too much complexity</li>
<li>Slower development</li>
</ul>
<p>‚úÖ <strong>Use appropriate idea level</strong></p>
<p>‚ùå <strong>Stuck at 1st idea</strong></p>
<ul>
<li>Limited by narrow scope</li>
<li>Duplicate code</li>
<li>Poor reusability</li>
</ul>
<p>‚úÖ <strong>Identify when 2nd idea helps</strong></p>
<p>‚ùå <strong>Skipping evaluation</strong></p>
<ul>
<li>Random complexity levels</li>
<li>Inconsistent codebase</li>
</ul>
<p>‚úÖ <strong>Evaluate intentionally</strong></p>
<h2 id="practical-checklist"><a class="header" href="#practical-checklist">Practical Checklist</a></h2>
<p>For each piece of code, ask:</p>
<ol>
<li>
<p><strong>Does 1st idea solve the problem?</strong></p>
<ul>
<li>If no ‚Üí Can't proceed</li>
<li>If yes ‚Üí Consider 2nd idea</li>
</ul>
</li>
<li>
<p><strong>Would 2nd idea add 80% value with 20% effort?</strong></p>
<ul>
<li>If no ‚Üí Stop at 1st idea</li>
<li>If yes ‚Üí Consider 2nd idea</li>
</ul>
</li>
<li>
<p><strong>Does 3rd idea add critical value?</strong></p>
<ul>
<li>If mission-critical ‚Üí Use 3rd idea</li>
<li>If improved but not critical ‚Üí Use 2nd idea</li>
<li>If over-engineering ‚Üí Use 1st or 2nd idea</li>
</ul>
</li>
</ol>
<h2 id="real-world-example-web-service"><a class="header" href="#real-world-example-web-service">Real-World Example: Web Service</a></h2>
<h3 id="get-user-endpoint"><a class="header" href="#get-user-endpoint">GET User Endpoint</a></h3>
<p>1st Idea (minimal):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_user(id: u32) -&gt; Result&lt;User, String&gt; {
    query_database(id)
}
<span class="boring">}</span></code></pre></pre>
<p>2nd Idea (flexible, instrumented):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_user(id: u32) -&gt; Result&lt;(User, Span), String&gt; {
    let span = create_span("get_user");
    let user = query_database(id)?;
    Ok((user, span))
}
<span class="boring">}</span></code></pre></pre>
<p>3rd Idea (type-safe, fully instrumented):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidatedUserResponse {
    user: ValidatedUser,
    span: Span,
}

impl ValidatedUserResponse {
    pub fn get(id: ValidUserId) -&gt; Result&lt;Self, String&gt; {
        // Type-safe, instrumented, validated
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Recommendation</strong>: Use 2nd idea for most endpoints. Only use 3rd for sensitive data (auth, payments).</p>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><a href="guides/observability.html">Observability &amp; Quality</a> - Implement 2nd and 3rd ideas</li>
<li><a href="guides/real-world.html">Real-World Applications</a> - See complete examples</li>
</ul>
<hr />
<h2 id="summary-9"><a class="header" href="#summary-9">Summary</a></h2>
<p>The "Go the Extra Mile" pattern:</p>
<p><strong>1st Idea</strong>: Minimal, solves the problem
<strong>2nd Idea</strong>: 80% more value, 20% more effort (usually best)
<strong>3rd Idea</strong>: Maximum value, significant effort (for critical paths)</p>
<p>Use this framework to make intentional design decisions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observability--quality"><a class="header" href="#observability--quality">Observability &amp; Quality</a></h1>
<p>Chicago TDD Tools provides comprehensive observability and quality measurement capabilities.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Observability helps you understand what your code is doing:</p>
<ul>
<li><strong>OTEL Instrumentation</strong>: Track operations with spans and metrics</li>
<li><strong>Weaver Validation</strong>: Ensure telemetry matches semantic conventions</li>
<li><strong>Coverage Measurement</strong>: Verify test coverage</li>
<li><strong>Performance Tracking</strong>: Measure operation timing</li>
</ul>
<h2 id="otel-spans"><a class="header" href="#otel-spans">OTEL Spans</a></h2>
<p>OTEL (OpenTelemetry) spans track operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::otel::*;

test!(test_with_span, {
    let start_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    // Create a span
    let mut span = Span::new_active(
        SpanContext::root(TraceId(123), SpanId(456), 1),
        "parse_operation",
        start_time,
        BTreeMap::new(),
        Vec::new(),
        SpanStatus::Unset,
    );

    // Add attributes
    span.attributes.insert("input".to_string(), "42".to_string());

    // Do work
    let result = "42".parse::&lt;u32&gt;()?;

    // Complete span
    let end_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    span.complete(end_time)?;
    span.status = SpanStatus::Ok;

    // Span is now complete with timing
    assert_ok!(&amp;span.validate());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="otel-metrics"><a class="header" href="#otel-metrics">OTEL Metrics</a></h2>
<p>Track measurements over time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::otel::*;

test!(test_with_metric, {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    let mut metric = Metric {
        name: "requests_total".to_string(),
        value: MetricValue::Counter(42),
        timestamp_ms: timestamp,
        attributes: BTreeMap::new(),
    };

    metric.attributes.insert("endpoint".to_string(), "/api/users".to_string());
    metric.attributes.insert("status".to_string(), "success".to_string());

    // Validate metric
    let validator = MetricValidator::new();
    assert_ok!(&amp;validator.validate(&amp;metric));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="weaver-live-check"><a class="header" href="#weaver-live-check">Weaver Live-Check</a></h2>
<p>Validate telemetry against semantic conventions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_weaver_validation, {
    // Check if Weaver is available
    match WeaverValidator::check_weaver_available() {
        Ok(()) =&gt; {
            // Weaver is available
            // Can validate OTEL spans against semantic conventions
            alert_success!("Weaver available");
        }
        Err(e) =&gt; {
            alert_info!("Weaver not available: {}", e);
            alert_info!("Install with: cargo make weaver-bootstrap");
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="coverage-measurement"><a class="header" href="#coverage-measurement">Coverage Measurement</a></h2>
<p>Measure test coverage:</p>
<pre><code class="language-bash"># Run coverage
cargo make coverage

# Generate report
cargo make coverage-report
</code></pre>
<p>Coverage shows:</p>
<ul>
<li>Code coverage percentage</li>
<li>Covered lines</li>
<li>Uncovered lines</li>
<li>Branch coverage</li>
</ul>
<p><strong>Target</strong>: 80%+ coverage for critical code</p>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="otel-spans-1"><a class="header" href="#otel-spans-1">OTEL Spans</a></h3>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Add meaningful attributes</li>
<li>Track timing</li>
<li>Mark errors with SpanStatus</li>
<li>Propagate context between services</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Create spans for every operation (too noisy)</li>
<li>Include sensitive data in attributes</li>
<li>Forget to complete spans</li>
</ul>
<h3 id="weaver-validation"><a class="header" href="#weaver-validation">Weaver Validation</a></h3>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use semantic conventions</li>
<li>Validate telemetry early</li>
<li>Document telemetry schema</li>
<li>Keep conventions up-to-date</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use custom attribute names</li>
<li>Skip validation</li>
<li>Ignore schema mismatches</li>
</ul>
<h3 id="coverage"><a class="header" href="#coverage">Coverage</a></h3>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Aim for 80%+ coverage</li>
<li>Focus on critical paths</li>
<li>Test error paths (often uncovered)</li>
<li>Review coverage reports</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Obsess over 100% coverage</li>
<li>Ignore untested lines</li>
<li>Only focus on coverage number</li>
</ul>
<h2 id="combining-observability-with-testing"><a class="header" href="#combining-observability-with-testing">Combining Observability with Testing</a></h2>
<h3 id="otel--unit-tests"><a class="header" href="#otel--unit-tests">OTEL + Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_otel, {
    let span = create_test_span("my_operation");

    // Do work
    let result = my_function()?;

    // Verify behavior AND telemetry
    assert_ok!(&amp;result);
    span.validate()?;
    assert_eq!(span.status, SpanStatus::Ok);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics--property-based-testing"><a class="header" href="#metrics--property-based-testing">Metrics + Property-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_metrics, {
    let strategy = ProptestStrategy::new().with_cases(100);

    strategy.test(any::&lt;u32&gt;(), |num| {
        let timestamp = SystemTime::now()...;
        let mut metric = Metric {
            name: "parsing_attempts".to_string(),
            value: MetricValue::Counter(1),
            timestamp_ms: timestamp,
            attributes: BTreeMap::new(),
        };

        // Validate metric
        let validator = MetricValidator::new();
        validator.validate(&amp;metric).is_ok()
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example-1"><a class="header" href="#real-world-example-1">Real-World Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_api_with_observability, {
    // Span for entire operation
    let mut operation_span = Span::new_active(
        SpanContext::root(TraceId(1), SpanId(1), 1),
        "api_request",
        start_time,
        BTreeMap::new(),
        Vec::new(),
        SpanStatus::Unset,
    );

    // Make API call
    let result = api_client.get_user(123)?;

    // Record metric
    let mut metric = Metric {
        name: "api_requests_total".to_string(),
        value: MetricValue::Counter(1),
        timestamp_ms: current_time,
        attributes: {
            let mut m = BTreeMap::new();
            m.insert("endpoint".to_string(), "/users".to_string());
            m.insert("status".to_string(), "success".to_string());
            m
        },
    };

    // Validate everything
    let span_validator = SpanValidator::new();
    assert_ok!(&amp;span_validator.validate(&amp;operation_span));

    let metric_validator = MetricValidator::new();
    assert_ok!(&amp;metric_validator.validate(&amp;metric));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="observability-checklist"><a class="header" href="#observability-checklist">Observability Checklist</a></h2>
<p>For production code:</p>
<ul>
<li><input disabled="" type="checkbox"/>
Operations tracked with OTEL spans</li>
<li><input disabled="" type="checkbox"/>
Meaningful attributes on spans</li>
<li><input disabled="" type="checkbox"/>
Metrics for important measurements</li>
<li><input disabled="" type="checkbox"/>
Error cases marked in telemetry</li>
<li><input disabled="" type="checkbox"/>
Telemetry validates against conventions</li>
<li><input disabled="" type="checkbox"/>
80%+ test coverage</li>
<li><input disabled="" type="checkbox"/>
Error paths covered</li>
<li><input disabled="" type="checkbox"/>
Boundary conditions tested</li>
</ul>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<p>See how to combine observability with real applications: <a href="guides/real-world.html">Real-World Applications</a></p>
<hr />
<h2 id="summary-10"><a class="header" href="#summary-10">Summary</a></h2>
<p>Observability provides:</p>
<ul>
<li>‚úÖ OTEL spans for operation tracking</li>
<li>‚úÖ Metrics for measurements</li>
<li>‚úÖ Weaver validation for compliance</li>
<li>‚úÖ Coverage for test quality</li>
</ul>
<p>Combined with testing for complete confidence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otel-instrumentation"><a class="header" href="#otel-instrumentation">OTEL Instrumentation</a></h1>
<p>OpenTelemetry instrumentation provides observability into your operations.</p>
<h2 id="creating-spans"><a class="header" href="#creating-spans">Creating Spans</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::otel::*;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::BTreeMap;

test!(test_span_creation, {
    let start_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    let mut span = Span::new_active(
        SpanContext::root(TraceId(12345), SpanId(67890), 1),
        "parse_user_data",
        start_time,
        BTreeMap::new(),
        Vec::new(),
        SpanStatus::Unset,
    );

    // Add attributes
    span.attributes.insert("user_id".to_string(), "123".to_string());
    span.attributes.insert("operation".to_string(), "parse".to_string());

    // Complete span
    let end_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    span.complete(end_time)?;
    span.status = SpanStatus::Ok;

    assert_eq!(span.status, SpanStatus::Ok);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="span-status"><a class="header" href="#span-status">Span Status</a></h2>
<p>Mark success or error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Success
span.status = SpanStatus::Ok;

// Error
span.status = SpanStatus::Error;

// Unset
span.status = SpanStatus::Unset;
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-metrics"><a class="header" href="#creating-metrics">Creating Metrics</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_metric_creation, {
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .ok()?
        .as_millis() as u64;

    let mut metric = Metric {
        name: "parsing_operations_total".to_string(),
        value: MetricValue::Counter(1),
        timestamp_ms: timestamp,
        attributes: BTreeMap::new(),
    };

    metric.attributes.insert("type".to_string(), "user".to_string());
    metric.attributes.insert("success".to_string(), "true".to_string());

    // Metric is ready to send to observability backend
    assert_eq!(metric.name, "parsing_operations_total");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="span-validation"><a class="header" href="#span-validation">Span Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_span_validation, {
    let span = create_valid_span()?;
    let validator = SpanValidator::new();
    
    assert_ok!(&amp;validator.validate(&amp;span));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use consistent span names</li>
<li>Add meaningful attributes</li>
<li>Track operation timing</li>
<li>Mark errors explicitly</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Include sensitive data in attributes</li>
<li>Create excessive spans</li>
<li>Forget timing information</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weaver-live-check-validation"><a class="header" href="#weaver-live-check-validation">Weaver Live-Check Validation</a></h1>
<p>Weaver validates telemetry against semantic conventions.</p>
<h2 id="what-is-weaver"><a class="header" href="#what-is-weaver">What is Weaver?</a></h2>
<p>Weaver ensures your OTEL telemetry complies with OpenTelemetry semantic conventions - the industry standard for attribute names and structure.</p>
<h2 id="checking-weaver-availability"><a class="header" href="#checking-weaver-availability">Checking Weaver Availability</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::observability::weaver::WeaverValidator;

test!(test_weaver_check, {
    match WeaverValidator::check_weaver_available() {
        Ok(()) =&gt; {
            alert_success!("Weaver is available");
            // Can validate telemetry
        }
        Err(e) =&gt; {
            alert_info!("Weaver not available: {}", e);
            // Install with: cargo make weaver-bootstrap
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="installing-weaver"><a class="header" href="#installing-weaver">Installing Weaver</a></h2>
<pre><code class="language-bash"># Bootstrap Weaver
cargo make weaver-bootstrap

# Run smoke test
cargo make weaver-smoke
</code></pre>
<h2 id="semantic-conventions"><a class="header" href="#semantic-conventions">Semantic Conventions</a></h2>
<p>Weaver checks that your attributes follow conventions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Correct - follows semantic conventions
let mut span = create_span("http.request");
span.attributes.insert("http.method".to_string(), "GET".to_string());
span.attributes.insert("http.target".to_string(), "/api/users".to_string());
span.attributes.insert("http.status_code".to_string(), "200".to_string());

// ‚ùå Wrong - custom attributes
span.attributes.insert("method".to_string(), "GET".to_string());
span.attributes.insert("endpoint".to_string(), "/api/users".to_string());
<span class="boring">}</span></code></pre></pre>
<h2 id="common-conventions"><a class="header" href="#common-conventions">Common Conventions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Attribute</th><th>Format</th><th>Example</th></tr></thead><tbody>
<tr><td><code>http.method</code></td><td>HTTP method</td><td>GET, POST, PUT</td></tr>
<tr><td><code>http.status_code</code></td><td>Integer</td><td>200, 404, 500</td></tr>
<tr><td><code>http.target</code></td><td>Path</td><td>/api/users</td></tr>
<tr><td><code>db.system</code></td><td>Database type</td><td>mysql, postgresql</td></tr>
<tr><td><code>db.operation</code></td><td>SQL operation</td><td>SELECT, INSERT</td></tr>
</tbody></table>
</div>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Follow semantic conventions</li>
<li>Validate with Weaver</li>
<li>Document telemetry schema</li>
<li>Keep conventions up-to-date</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Use custom attribute names</li>
<li>Ignore Weaver validation</li>
<li>Duplicate information in attributes</li>
</ul>
<h2 id="troubleshooting-7"><a class="header" href="#troubleshooting-7">Troubleshooting</a></h2>
<h3 id="weaver-binary-not-found"><a class="header" href="#weaver-binary-not-found">Weaver Binary Not Found</a></h3>
<p>Install Weaver:</p>
<pre><code class="language-bash">cargo make weaver-bootstrap
</code></pre>
<h3 id="validation-fails"><a class="header" href="#validation-fails">Validation Fails</a></h3>
<p>Check attribute names against conventions:</p>
<pre><code class="language-bash"># See Weaver registry
cargo make weaver-smoke
</code></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<p>Combine observability with testing: <a href="guides/observability.html">Observability &amp; Quality</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage--performance"><a class="header" href="#coverage--performance">Coverage &amp; Performance</a></h1>
<p>Measure test coverage and performance metrics.</p>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<p>Coverage shows which code is executed by tests:</p>
<pre><code class="language-bash"># Generate coverage report
cargo make coverage

# View coverage report
cargo make coverage-report
</code></pre>
<h3 id="coverage-metrics"><a class="header" href="#coverage-metrics">Coverage Metrics</a></h3>
<ul>
<li><strong>Line Coverage</strong>: % of lines executed</li>
<li><strong>Branch Coverage</strong>: % of branches executed</li>
<li><strong>Function Coverage</strong>: % of functions executed</li>
</ul>
<h3 id="target-coverage"><a class="header" href="#target-coverage">Target Coverage</a></h3>
<ul>
<li><strong>Minimum</strong>: 70% (warning level)</li>
<li><strong>Target</strong>: 80%+ (good)</li>
<li><strong>Excellent</strong>: 90%+ (very thorough)</li>
</ul>
<p>‚ùå Don't obsess over 100% (often impossible/impractical)</p>
<h3 id="improving-coverage"><a class="header" href="#improving-coverage">Improving Coverage</a></h3>
<p>Focus on uncovered lines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Uncovered error path
if let Err(e) = operation() {
    // This might not be tested
    log_error(e);
}

// ‚úÖ Test the error path too
test!(test_error_handling, {
    let result = risky_operation();
    assert_err!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<p>Measure operation timing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(performance_test, {
    let start = std::time::Instant::now();

    // Code to benchmark
    for _ in 0..1000 {
        let _result = parse_number("42");
    }

    let elapsed = start.elapsed();
    println!("Time for 1000 parses: {:?}", elapsed);

    // Assert performance target
    assert!(elapsed.as_millis() &lt; 100);  // &lt; 100ms
});
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-targets"><a class="header" href="#performance-targets">Performance Targets</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Target</th><th>Too Slow</th></tr></thead><tbody>
<tr><td>Parse number</td><td>&lt;1Œºs</td><td>&gt;10Œºs</td></tr>
<tr><td>Database query</td><td>&lt;10ms</td><td>&gt;100ms</td></tr>
<tr><td>API call</td><td>&lt;100ms</td><td>&gt;1s</td></tr>
<tr><td>Test execution</td><td>&lt;10ms</td><td>&gt;100ms</td></tr>
</tbody></table>
</div>
<h3 id="profiling"><a class="header" href="#profiling">Profiling</a></h3>
<pre><code class="language-bash"># Run performance tests
cargo make test-timings

# Profile with cargo flamegraph (if installed)
cargo flamegraph --test performance_tests
</code></pre>
<h2 id="combining-coverage-and-performance"><a class="header" href="#combining-coverage-and-performance">Combining Coverage and Performance</a></h2>
<p>Track both:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(comprehensive_test, {
    let start = std::time::Instant::now();

    // Success path (covered)
    let ok = parse_number("42");
    assert_ok!(&amp;ok);

    // Error path (covered)
    let err = parse_number("invalid");
    assert_err!(&amp;err);

    // Performance assertion
    let elapsed = start.elapsed();
    assert!(elapsed.as_millis() &lt; 10);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<p>‚úÖ <strong>Coverage:</strong></p>
<ul>
<li>Aim for 80%+ overall</li>
<li>Focus on critical paths</li>
<li>Test error cases</li>
<li>Review uncovered lines</li>
</ul>
<p>‚ùå <strong>Coverage:</strong></p>
<ul>
<li>Don't chase 100%</li>
<li>Don't test generated code</li>
<li>Don't test trivial code</li>
</ul>
<p>‚úÖ <strong>Performance:</strong></p>
<ul>
<li>Set realistic targets</li>
<li>Measure on target hardware</li>
<li>Profile before optimizing</li>
<li>Test under load</li>
</ul>
<p>‚ùå <strong>Performance:</strong></p>
<ul>
<li>Optimize prematurely</li>
<li>Ignore benchmarks</li>
<li>Assume fast</li>
<li>Measure on dev machine only</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-world-applications"><a class="header" href="#real-world-applications">Real-World Applications</a></h1>
<p>See complete examples of Chicago TDD Tools in action.</p>
<h2 id="cli-application-example"><a class="header" href="#cli-application-example">CLI Application Example</a></h2>
<p>The playground includes a complete CLI tool with multiple commands.</p>
<h3 id="running-the-playground"><a class="header" href="#running-the-playground">Running the Playground</a></h3>
<pre><code class="language-bash"># Build the playground
cargo build --release -p playground

# Run CLI help
./target/release/playground help

# Run specific commands
./target/release/playground test --help
./target/release/playground quality --help
./target/release/playground obs --help
</code></pre>
<h3 id="playground-structure"><a class="header" href="#playground-structure">Playground Structure</a></h3>
<pre><code>playground/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs          # CLI entry point
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs           # Library exports
‚îÇ   ‚îî‚îÄ‚îÄ cli/             # Subcommands
‚îÇ       ‚îú‚îÄ‚îÄ test.rs      # Testing commands
‚îÇ       ‚îú‚îÄ‚îÄ quality.rs   # Quality commands
‚îÇ       ‚îú‚îÄ‚îÄ obs.rs       # Observability commands
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ tests/               # Integration tests
    ‚îú‚îÄ‚îÄ core_tests.rs
    ‚îú‚îÄ‚îÄ testing_tests.rs
    ‚îî‚îÄ‚îÄ integration_tests.rs
</code></pre>
<h3 id="example-commands"><a class="header" href="#example-commands">Example Commands</a></h3>
<pre><code class="language-bash"># Test fixtures
playground test fixtures

# Run mutation tests
playground quality mutation

# Check OTEL compliance
playground obs validate

# Generate coverage
playground quality coverage
</code></pre>
<h2 id="example-based-learning"><a class="header" href="#example-based-learning">Example-Based Learning</a></h2>
<h3 id="example-basic_testrs"><a class="header" href="#example-basic_testrs">Example: basic_test.rs</a></h3>
<p>Demonstrates core patterns:</p>
<ul>
<li>Fixture creation</li>
<li>Data builders</li>
<li>Assertions</li>
<li>Error handling</li>
</ul>
<pre><code class="language-bash">cargo run --example basic_test
</code></pre>
<h3 id="example-property_testingrs"><a class="header" href="#example-property_testingrs">Example: property_testing.rs</a></h3>
<p>Property-based testing:</p>
<ul>
<li>Random data generation</li>
<li>Property verification</li>
<li>Shrinking failed cases</li>
</ul>
<pre><code class="language-bash">cargo run --example property_testing --features property-testing
</code></pre>
<h3 id="example-go_extra_milers"><a class="header" href="#example-go_extra_milers">Example: go_extra_mile.rs</a></h3>
<p>Progressive enhancement:</p>
<ul>
<li>1st idea (basic)</li>
<li>2nd idea (generic)</li>
<li>3rd idea (validated)</li>
</ul>
<pre><code class="language-bash">cargo run --example go_extra_mile --features otel,weaver
</code></pre>
<h2 id="integration-testing-patterns"><a class="header" href="#integration-testing-patterns">Integration Testing Patterns</a></h2>
<h3 id="with-docker-containers"><a class="header" href="#with-docker-containers">With Docker Containers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_docker_db, {
    // Requires Docker to be running
    let fixture = TestFixture::new()?;

    // Fixture provides Docker container support
    // (when testcontainers feature enabled)

    // Run test against real database
    let result = query_database(&amp;fixture)?;
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo make test-integration
</code></pre>
<h2 id="testing-workflows"><a class="header" href="#testing-workflows">Testing Workflows</a></h2>
<h3 id="quick-feedback-loop-5-seconds"><a class="header" href="#quick-feedback-loop-5-seconds">Quick Feedback Loop (5 seconds)</a></h3>
<pre><code class="language-bash"># Format + check + unit tests
cargo make pre-commit

# Then fix issues
</code></pre>
<h3 id="comprehensive-testing-1-2-minutes"><a class="header" href="#comprehensive-testing-1-2-minutes">Comprehensive Testing (1-2 minutes)</a></h3>
<pre><code class="language-bash"># Format + lint + all tests
cargo make test-all

# Includes integration tests (requires Docker)
</code></pre>
<h3 id="release-validation-5-10-minutes"><a class="header" href="#release-validation-5-10-minutes">Release Validation (5-10 minutes)</a></h3>
<pre><code class="language-bash"># Full validation before release
cargo make release-validate

# Includes:
# - All tests
# - Coverage
# - Mutation testing
# - Documentation
</code></pre>
<h2 id="architecture-patterns"><a class="header" href="#architecture-patterns">Architecture Patterns</a></h2>
<h3 id="fixture-based-setup"><a class="header" href="#fixture-based-setup">Fixture-Based Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_fixture, {
    // Arrange: Create isolated fixture
    let fixture = TestFixture::new()?;

    // Act: Use fixture in test
    let result = process(&amp;fixture)?;

    // Assert: Verify behavior
    assert_ok!(&amp;result);

    // Cleanup: Automatic (fixture dropped)
});
<span class="boring">}</span></code></pre></pre>
<h3 id="builder-driven-test-data"><a class="header" href="#builder-driven-test-data">Builder-Driven Test Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_builders, {
    let user = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    let result = create_user(&amp;user)?;
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="property-based-coverage"><a class="header" href="#property-based-coverage">Property-Based Coverage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_property, {
    let strategy = ProptestStrategy::new().with_cases(1000);

    strategy.test(any::&lt;(u32, u32)&gt;(), |(a, b)| {
        a + b == b + a  // Commutativity
    });
});
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-user-service"><a class="header" href="#complete-example-user-service">Complete Example: User Service</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(complete_user_service_test, {
    // Setup
    let fixture = TestFixture::new()?;

    // Create user with builder
    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act: Create
    let create_result = create_user(&amp;user_data)?;
    assert_ok!(&amp;create_result);
    let user = create_result.unwrap();

    // Act: Read
    let read_result = get_user(user.id)?;
    assert_ok!(&amp;read_result);
    assert_eq!(read_result.unwrap().name, "Alice");

    // Act: Update
    let mut updated = user.clone();
    updated.email = "alice.new@example.com".to_string();
    let update_result = update_user(&amp;updated)?;
    assert_ok!(&amp;update_result);

    // Act: Delete
    let delete_result = delete_user(user.id)?;
    assert_ok!(&amp;delete_result);

    // Verify deleted
    let read_result = get_user(user.id);
    assert_err!(&amp;read_result);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-from-examples"><a class="header" href="#best-practices-from-examples">Best Practices from Examples</a></h2>
<p>‚úÖ <strong>From examples:</strong></p>
<ul>
<li>Clear Arrange-Act-Assert structure</li>
<li>Comprehensive error testing</li>
<li>Progressive complexity</li>
<li>Reusable patterns</li>
</ul>
<p>‚úÖ <strong>From playground:</strong></p>
<ul>
<li>Multiple testing techniques</li>
<li>Integration with Docker</li>
<li>CLI testing patterns</li>
<li>Quality metrics</li>
</ul>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<p>Apply what you've learned:</p>
<ol>
<li>Start with <a href="guides/../core/README.html">Core Patterns</a></li>
<li>Add <a href="guides/../advanced/README.html">Advanced Techniques</a></li>
<li>Implement <a href="guides/observability.html">Observability</a></li>
<li>Follow <a href="guides/best-practices.html">Best Practices</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-cli-application"><a class="header" href="#building-a-cli-application">Building a CLI Application</a></h1>
<p>Complete example of testing a CLI application with Chicago TDD Tools.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<pre><code>myapp/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs         # CLI entry point
‚îÇ   ‚îî‚îÄ‚îÄ commands/
‚îÇ       ‚îú‚îÄ‚îÄ list.rs     # List command
‚îÇ       ‚îú‚îÄ‚îÄ add.rs      # Add command
‚îÇ       ‚îî‚îÄ‚îÄ delete.rs   # Delete command
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ cli_tests.rs    # CLI integration tests
    ‚îî‚îÄ‚îÄ commands_tests.rs
</code></pre>
<h2 id="testing-cli-commands"><a class="header" href="#testing-cli-commands">Testing CLI Commands</a></h2>
<h3 id="example-list-command-test"><a class="header" href="#example-list-command-test">Example: List Command Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_list_command, {
    let output = CliTest::new("myapp", vec!["list"])
        .run()?;

    assert!(output.contains("Item"));
    assert!(output.exit_code == 0);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-add-command-test"><a class="header" href="#example-add-command-test">Example: Add Command Test</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_add_command, {
    let output = CliTest::new("myapp", vec![
        "add",
        "--name", "New Item",
        "--priority", "high"
    ]).run()?;

    assert!(output.contains("Added"));
    assert!(output.exit_code == 0);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-error-handling"><a class="header" href="#example-error-handling">Example: Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_invalid_command, {
    let result = CliTest::new("myapp", vec!["invalid"])
        .run();

    assert!(result.is_err());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-for-cli-testing"><a class="header" href="#best-practices-for-cli-testing">Best Practices for CLI Testing</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test all commands</li>
<li>Test argument combinations</li>
<li>Test error cases</li>
<li>Use snapshots for complex output</li>
<li>Test environment variables</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Hard-code full output</li>
<li>Test shell integration</li>
<li>Test external tools</li>
</ul>
<p>See: <a href="guides/../advanced/cli-testing.html">CLI Testing</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-a-web-service"><a class="header" href="#testing-a-web-service">Testing a Web Service</a></h1>
<p>Complete example of testing a web service with Chicago TDD Tools.</p>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<pre><code>myservice/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.rs
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ integration_tests.rs
    ‚îî‚îÄ‚îÄ api_tests.rs
</code></pre>
<h2 id="testing-endpoints"><a class="header" href="#testing-endpoints">Testing Endpoints</a></h2>
<h3 id="example-get-users"><a class="header" href="#example-get-users">Example: GET /users</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_get_users, {
    let client = TestClient::new()?;

    // Act
    let response = client.get("/users")?;

    // Assert
    assert_eq!(response.status, 200);
    let users: Vec&lt;User&gt; = response.json()?;
    assert!(!users.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-post-users"><a class="header" href="#example-post-users">Example: POST /users</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_create_user, {
    let client = TestClient::new()?;

    let user_data = TestDataBuilder::new()
        .with_var("name", "Alice")
        .with_var("email", "alice@example.com")
        .build_json()?;

    // Act
    let response = client.post("/users", &amp;user_data)?;

    // Assert
    assert_eq!(response.status, 201);  // Created
    assert_ok!(&amp;response.json::&lt;User&gt;());
});
<span class="boring">}</span></code></pre></pre>
<h3 id="example-error-cases"><a class="header" href="#example-error-cases">Example: Error Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_create_user_validation_error, {
    let client = TestClient::new()?;

    let invalid_data = TestDataBuilder::new()
        .with_var("email", "not_an_email")
        .build_json()?;

    // Act
    let response = client.post("/users", &amp;invalid_data)?;

    // Assert
    assert_eq!(response.status, 400);  // Bad request
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-real-database"><a class="header" href="#testing-with-real-database">Testing with Real Database</a></h2>
<p>Use integration tests with fixtures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_database, {
    let fixture = TestFixture::new()?;

    // Fixture provides database connection
    let db = fixture.db_connection();

    // Create user in database
    let user = db.create_user("Alice", "alice@example.com")?;

    // Test retrieval
    let retrieved = db.get_user(user.id)?;
    assert_eq!(retrieved.name, "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-authentication"><a class="header" href="#testing-authentication">Testing Authentication</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_auth_required, {
    let client = TestClient::new()?;

    // No authentication
    let response = client.get("/protected")?;
    assert_eq!(response.status, 401);  // Unauthorized

    // With authentication
    let token = client.login("alice", "password")?;
    let response = client.get_with_auth("/protected", &amp;token)?;
    assert_eq!(response.status, 200);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Test with real database (in tests)</li>
<li>Test all HTTP methods (GET, POST, PUT, DELETE)</li>
<li>Test error cases (400, 401, 404, 500)</li>
<li>Test response structure</li>
<li>Use fixtures for isolation</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Mock the entire HTTP layer</li>
<li>Test framework code</li>
<li>Hard-code full responses</li>
</ul>
<h2 id="testing-workflow"><a class="header" href="#testing-workflow">Testing Workflow</a></h2>
<pre><code class="language-bash"># 1. Unit tests (fast)
cargo make test-unit

# 2. Integration tests (requires database)
cargo make test-integration

# 3. Full CI simulation
cargo make ci-local
</code></pre>
<p>See: <a href="guides/../advanced/README.html">Advanced Techniques</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-testing-with-docker"><a class="header" href="#integration-testing-with-docker">Integration Testing with Docker</a></h1>
<p>Test with real services using Docker containers.</p>
<h2 id="why-docker-for-testing"><a class="header" href="#why-docker-for-testing">Why Docker for Testing?</a></h2>
<p>Docker provides:</p>
<ul>
<li>Real service instances (not mocks)</li>
<li>Isolated test environment</li>
<li>Reproducible results</li>
<li>Easy cleanup</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<pre><code class="language-bash"># Ensure Docker is running
docker --version

# Enable testcontainers feature
[dev-dependencies]
chicago-tdd-tools = { version = "1.3", features = ["testcontainers"] }
</code></pre>
<h2 id="docker-compose-for-tests"><a class="header" href="#docker-compose-for-tests">Docker Compose for Tests</a></h2>
<p>Create <code>docker-compose.test.yml</code>:</p>
<pre><code class="language-yaml">version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: test_user
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: test_db
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
</code></pre>
<p>Run tests:</p>
<pre><code class="language-bash"># Start services
docker-compose -f docker-compose.test.yml up -d

# Run tests
cargo make test-integration

# Stop services
docker-compose -f docker-compose.test.yml down
</code></pre>
<h2 id="testing-with-database"><a class="header" href="#testing-with-database">Testing with Database</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_postgres, {
    // Fixture provides database connection
    let fixture = TestFixture::new()?;

    // Create test user
    fixture.db().create_user("alice", "alice@example.com")?;

    // Query database
    let user = fixture.db().get_user_by_email("alice@example.com")?;
    assert_eq!(user.name, "alice");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-redis"><a class="header" href="#testing-with-redis">Testing with Redis</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_redis, {
    let fixture = TestFixture::new()?;

    // Use Redis from fixture
    let cache = fixture.redis();

    // Set value
    cache.set("key", "value")?;

    // Get value
    let value = cache.get("key")?;
    assert_eq!(value, "value");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-integration-test"><a class="header" href="#complete-integration-test">Complete Integration Test</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(complete_integration_test, {
    let fixture = TestFixture::new()?;
    let db = fixture.db();
    let cache = fixture.redis();

    // 1. Create user in database
    let user = db.create_user("alice", "alice@example.com")?;

    // 2. Cache user
    cache.set(&amp;format!("user:{}", user.id), &amp;user.to_json())?;

    // 3. Verify database
    let retrieved = db.get_user(user.id)?;
    assert_eq!(retrieved.email, "alice@example.com");

    // 4. Verify cache
    let cached = cache.get(&amp;format!("user:{}", user.id))?;
    assert!(!cached.is_empty());
});
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-docker-failures"><a class="header" href="#handling-docker-failures">Handling Docker Failures</a></h2>
<p>If Docker is unavailable:</p>
<pre><code class="language-bash"># Skip integration tests
WEAVER_ALLOW_SKIP=1 cargo make test-unit

# Or just run unit tests
cargo test --lib
</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<p>Docker containers have overhead:</p>
<ul>
<li>Slow: 30-60 seconds per test</li>
<li>Solution: Batch related tests</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_db_operations_batch, {
    let fixture = TestFixture::new()?;

    // Test 1: Create
    let user = fixture.db().create_user("alice", "alice@example.com")?;
    assert_ok!(&amp;user);

    // Test 2: Read
    let retrieved = fixture.db().get_user(user.id)?;
    assert_ok!(&amp;retrieved);

    // Test 3: Update
    fixture.db().update_user(user.id, "new_email@example.com")?;
    let updated = fixture.db().get_user(user.id)?;
    assert_eq!(updated.email, "new_email@example.com");

    // Test 4: Delete
    fixture.db().delete_user(user.id)?;
    let result = fixture.db().get_user(user.id);
    assert_err!(&amp;result);

    // One test, multiple operations, one fixture overhead
});
<span class="boring">}</span></code></pre></pre>
<h2 id="cicd-pipeline"><a class="header" href="#cicd-pipeline">CI/CD Pipeline</a></h2>
<h3 id="github-actions-example"><a class="header" href="#github-actions-example">GitHub Actions Example</a></h3>
<pre><code class="language-yaml">name: Integration Tests

on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: password
        options: --health-cmd pg_isready

    steps:
      - uses: actions/checkout@v3
      - uses: actions-rs/toolchain@v1
      - run: cargo make test-integration
</code></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<p>‚úÖ <strong>Do:</strong></p>
<ul>
<li>Use Docker for real services</li>
<li>Batch related tests</li>
<li>Use fixtures for isolation</li>
<li>Clean up after tests</li>
</ul>
<p>‚ùå <strong>Don't:</strong></p>
<ul>
<li>Mock Docker services</li>
<li>Share containers between tests</li>
<li>Run Docker tests in CI for every commit</li>
<li>Forget about cleanup</li>
</ul>
<h2 id="troubleshooting-8"><a class="header" href="#troubleshooting-8">Troubleshooting</a></h2>
<h3 id="docker-daemon-not-running"><a class="header" href="#docker-daemon-not-running">"Docker daemon not running"</a></h3>
<p>Start Docker:</p>
<pre><code class="language-bash"># macOS
open /Applications/Docker.app

# Linux
sudo systemctl start docker

# Windows
Start Docker Desktop
</code></pre>
<h3 id="port-already-in-use"><a class="header" href="#port-already-in-use">"Port already in use"</a></h3>
<p>Check ports:</p>
<pre><code class="language-bash">docker ps  # See running containers
docker stop &lt;container&gt;
</code></pre>
<h3 id="tests-timeout"><a class="header" href="#tests-timeout">Tests Timeout</a></h3>
<p>Increase timeout:</p>
<pre><code class="language-bash">cargo test --lib -- --test-threads=1  # Sequential
</code></pre>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<p>See: <a href="guides/best-practices.html">Best Practices</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="best-practices--migration"><a class="header" href="#best-practices--migration">Best Practices &amp; Migration</a></h1>
<p>Proven patterns and migration strategies for Chicago TDD.</p>
<h2 id="testing-best-practices"><a class="header" href="#testing-best-practices">Testing Best Practices</a></h2>
<h3 id="1-write-tests-first-tdd"><a class="header" href="#1-write-tests-first-tdd">1. Write Tests First (TDD)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 1. Write failing test
test!(test_parse_positive_number, {
    let result = parse_number("42");
    assert_ok!(&amp;result);
    assert_eq!(result.unwrap(), 42);
});

// 2. Implement minimal code
pub fn parse_number(input: &amp;str) -&gt; Result&lt;u32, String&gt; {
    input.parse().map_err(|e| format!("Parse failed: {e}"))
}

// 3. Refactor (improve design, remove duplication)
// 4. Test passes ‚úì
<span class="boring">}</span></code></pre></pre>
<h3 id="2-test-both-paths"><a class="header" href="#2-test-both-paths">2. Test Both Paths</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_complete_behavior, {
    // Success path
    assert_ok!(&amp;parse_number("42"));

    // Error path
    assert_err!(&amp;parse_number("invalid"));
});
<span class="boring">}</span></code></pre></pre>
<h3 id="3-focus-on-error-cases"><a class="header" href="#3-focus-on-error-cases">3. Focus on Error Cases</a></h3>
<p>80% of bugs hide in error paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_error_cases, {
    // Test invalid input
    assert_err!(&amp;parse_number(""));
    assert_err!(&amp;parse_number("not_a_number"));
    assert_err!(&amp;parse_number("-1"));  // If negative not allowed

    // Test boundaries
    assert_ok!(&amp;parse_number("0"));
    assert_ok!(&amp;parse_number("4294967295"));  // u32::MAX
});
<span class="boring">}</span></code></pre></pre>
<h3 id="4-keep-tests-focused"><a class="header" href="#4-keep-tests-focused">4. Keep Tests Focused</a></h3>
<p>One test per behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Focused
test!(test_parse_valid_number, {
    let result = parse_number("42");
    assert_ok!(&amp;result);
});

test!(test_parse_invalid_number, {
    let result = parse_number("invalid");
    assert_err!(&amp;result);
});

// ‚ùå Too many behaviors
test!(test_parsing, {
    // Tests both valid and invalid
    // Hard to know what failed
});
<span class="boring">}</span></code></pre></pre>
<h3 id="5-use-descriptive-names"><a class="header" href="#5-use-descriptive-names">5. Use Descriptive Names</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚úÖ Clear intent
test!(test_parse_handles_negative_numbers_gracefully, { /* */ });

// ‚ùå Vague
test!(test_parse, { /* */ });
<span class="boring">}</span></code></pre></pre>
<h2 id="organization-best-practices"><a class="header" href="#organization-best-practices">Organization Best Practices</a></h2>
<h3 id="1-mirror-source-structure"><a class="header" href="#1-mirror-source-structure">1. Mirror Source Structure</a></h3>
<pre><code>src/
‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îî‚îÄ‚îÄ service.rs
‚îî‚îÄ‚îÄ orders/
    ‚îî‚îÄ‚îÄ service.rs

tests/
‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îî‚îÄ‚îÄ service_tests.rs
‚îî‚îÄ‚îÄ orders/
    ‚îî‚îÄ‚îÄ service_tests.rs
</code></pre>
<h3 id="2-shared-utilities"><a class="header" href="#2-shared-utilities">2. Shared Utilities</a></h3>
<pre><code>tests/
‚îú‚îÄ‚îÄ common.rs           # Shared utilities
‚îú‚îÄ‚îÄ users_tests.rs
‚îî‚îÄ‚îÄ orders_tests.rs
</code></pre>
<p>In <code>common.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_test_user() -&gt; Result&lt;User, String&gt; {
    TestDataBuilder::new()
        .with_var("name", "Test User")
        .build_json()?
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-fixture-factory-pattern"><a class="header" href="#3-fixture-factory-pattern">3. Fixture Factory Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_database_fixture() -&gt; Result&lt;TestFixture, String&gt; {
    let fixture = TestFixture::new()?;
    // Additional setup
    Ok(fixture)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-best-practices"><a class="header" href="#performance-best-practices">Performance Best Practices</a></h2>
<h3 id="1-isolate-slow-tests"><a class="header" href="#1-isolate-slow-tests">1. Isolate Slow Tests</a></h3>
<p>Mark slow tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ignore]  // Run with --ignored flag
test!(slow_integration_test, {
    // Takes 10 seconds
});
<span class="boring">}</span></code></pre></pre>
<p>Run separately:</p>
<pre><code class="language-bash">cargo test --ignored  # Only slow tests
</code></pre>
<h3 id="2-parallel-execution"><a class="header" href="#2-parallel-execution">2. Parallel Execution</a></h3>
<p>Tests run in parallel by default:</p>
<pre><code class="language-bash">cargo test -- --test-threads=4  # 4 threads (default: CPU count)
cargo test -- --test-threads=1  # Sequential (slow, for debugging)
</code></pre>
<h3 id="3-cache-expensive-operations"><a class="header" href="#3-cache-expensive-operations">3. Cache Expensive Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_expensive_setup, {
    // Reuse expensive setup
    lazy_static::lazy_static! {
        static ref EXPENSIVE_DATA: Data = { /* expensive */ };
    }

    // Use cached data
    assert_ok!(&amp;process(&amp;EXPENSIVE_DATA));
});
<span class="boring">}</span></code></pre></pre>
<h2 id="migration-from-traditional-testing"><a class="header" href="#migration-from-traditional-testing">Migration from Traditional Testing</a></h2>
<h3 id="from-no-tests--to-core-tests"><a class="header" href="#from-no-tests--to-core-tests">From: No Tests ‚Üí To: Core Tests</a></h3>
<ol>
<li>Start with core patterns (fixtures, builders, assertions)</li>
<li>Test public APIs</li>
<li>Focus on error cases</li>
<li>Gradually increase coverage</li>
</ol>
<h3 id="from-mocks--to-real-dependencies"><a class="header" href="#from-mocks--to-real-dependencies">From: Mocks ‚Üí To: Real Dependencies</a></h3>
<ol>
<li>Replace mocks with real implementations</li>
<li>Use fixtures for isolation</li>
<li>Only mock external services (APIs, DBs)</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: Mock-heavy
let mock_db = MockDatabase::new();
let result = process(&amp;mock_db);

// After: Real implementations
let fixture = TestFixture::new()?;
let result = process(&amp;fixture)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="from-global-state--to-fixtures"><a class="header" href="#from-global-state--to-fixtures">From: Global State ‚Üí To: Fixtures</a></h3>
<ol>
<li>Remove global state</li>
<li>Create fixtures for test isolation</li>
<li>Pass fixtures as parameters</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Before: Global
static mut TEST_DATA: Option&lt;Data&gt; = None;

// After: Fixture-based
test!(test_with_data, {
    let fixture = TestFixture::new()?;
    // Use fixture
});
<span class="boring">}</span></code></pre></pre>
<h3 id="from-100-coverage--to-80--error-paths"><a class="header" href="#from-100-coverage--to-80--error-paths">From: 100% Coverage ‚Üí To: 80% + Error Paths</a></h3>
<ol>
<li>Stop obsessing over coverage</li>
<li>Focus on critical paths</li>
<li>Test error cases thoroughly</li>
</ol>
<h2 id="common-pitfalls--solutions"><a class="header" href="#common-pitfalls--solutions">Common Pitfalls &amp; Solutions</a></h2>
<h3 id="pitfall-1-tests-coupled-to-implementation"><a class="header" href="#pitfall-1-tests-coupled-to-implementation">Pitfall 1: Tests Coupled to Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Brittle - depends on internal structure
test!(test_struct_format, {
    let user = create_user();
    assert_eq!(format!("{:?}", user), "User { id: 123, ... }");
});

// ‚úÖ Robust - tests behavior
test!(test_user_creation, {
    let user = create_user();
    assert_eq!(user.id, 123);
    assert_eq!(user.name, "Alice");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-2-flaky-tests"><a class="header" href="#pitfall-2-flaky-tests">Pitfall 2: Flaky Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Flaky - depends on time
test!(test_timing_dependent, {
    let start = Instant::now();
    operation();
    assert!(start.elapsed() &lt; Duration::from_secs(1));  // Unreliable
});

// ‚úÖ Reliable - deterministic
test!(test_result_correct, {
    let result = operation();
    assert_eq!(result, expected);  // Same result every time
});
<span class="boring">}</span></code></pre></pre>
<h3 id="pitfall-3-test-interdependencies"><a class="header" href="#pitfall-3-test-interdependencies">Pitfall 3: Test Interdependencies</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ‚ùå Tests depend on order
test!(test_1_setup, { /* setup */ });
test!(test_2_use_setup_from_1, { /* depends on test_1 */ });

// ‚úÖ Each test is independent
test!(test_setup, {
    let fixture = TestFixture::new()?;
    // setup complete
});

test!(test_use, {
    let fixture = TestFixture::new()?;
    // independent
});
<span class="boring">}</span></code></pre></pre>
<h2 id="quality-checklist"><a class="header" href="#quality-checklist">Quality Checklist</a></h2>
<p>For each test, verify:</p>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>AAA Pattern</strong>: Arrange, Act, Assert clearly separated</li>
<li><input disabled="" type="checkbox"/>
<strong>Isolation</strong>: No dependencies on other tests</li>
<li><input disabled="" type="checkbox"/>
<strong>Error Paths</strong>: Tests both success and failure</li>
<li><input disabled="" type="checkbox"/>
<strong>Clear Name</strong>: Describes what's being tested</li>
<li><input disabled="" type="checkbox"/>
<strong>One Assertion</strong>: Focused on one behavior</li>
<li><input disabled="" type="checkbox"/>
<strong>Deterministic</strong>: Same result every run</li>
<li><input disabled="" type="checkbox"/>
<strong>Fast</strong>: &lt;100ms per test (unless integration)</li>
</ul>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="pre-commit"><a class="header" href="#pre-commit">Pre-Commit</a></h3>
<pre><code class="language-bash">cargo make pre-commit  # Format + lint + unit tests
</code></pre>
<h3 id="before-push"><a class="header" href="#before-push">Before Push</a></h3>
<pre><code class="language-bash">cargo make ci-local    # Simulate full CI pipeline
</code></pre>
<h3 id="in-ci"><a class="header" href="#in-ci">In CI</a></h3>
<pre><code class="language-bash">cargo make test-all    # All tests including integration
</code></pre>
<h2 id="graduation-path"><a class="header" href="#graduation-path">Graduation Path</a></h2>
<pre><code>Learning
  ‚Üì
Core Patterns (fixtures, builders, assertions)
  ‚Üì
Error Path Testing
  ‚Üì
Advanced Techniques (properties, mutations, snapshots)
  ‚Üì
Observability (OTEL, Weaver)
  ‚Üì
Expert
</code></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="guides/../core/README.html">Core Patterns</a></li>
<li><a href="guides/../advanced/README.html">Advanced Techniques</a></li>
<li><a href="guides/real-world.html">Real-World Examples</a></li>
<li><a href="guides/../../cookbook/README.html">Pattern Cookbook</a></li>
<li><a href="https://docs.rs/chicago-tdd-tools/">API Reference</a></li>
</ul>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ol>
<li>Pick a project to refactor</li>
<li>Start with core patterns</li>
<li>Add tests incrementally</li>
<li>Build confidence with error paths</li>
<li>Add advanced techniques where beneficial</li>
</ol>
<hr />
<p><strong>Chicago TDD Tools</strong>: Testing with confidence, errors prevented at compile time.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
