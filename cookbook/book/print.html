<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chicago TDD Tools Pattern Cookbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Alexander-style pattern language for Chicago TDD Tools">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Chicago TDD Tools Pattern Cookbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chicago-tdd-tools-pattern-cookbook"><a class="header" href="#chicago-tdd-tools-pattern-cookbook">Chicago TDD Tools Pattern Cookbook</a></h1>
<p>Welcome to the Chicago TDD Tools Pattern Cookbook. This mdBook captures the living pattern language behind the framework. Inspired by Christopher Alexander's "A Pattern Language," each pattern documents a recurring problem and the high-leverage solution encoded in the framework. Patterns are organized across testing, architecture, and design themes so you can quickly discover what fits your current context.</p>
<p>Every pattern includes:</p>
<ul>
<li><strong>Context</strong> â€“ when the pattern applies</li>
<li><strong>Problem</strong> â€“ the tension you are trying to resolve</li>
<li><strong>Solution</strong> â€“ the structure that resolves the tension, with concrete code</li>
<li><strong>Forces</strong> â€“ trade-offs the solution balances</li>
<li><strong>Examples</strong> â€“ copy-pasteable Rust using Chicago TDD Tools</li>
<li><strong>Related Patterns</strong> â€“ how the language connects</li>
</ul>
<p>Use this cookbook as a field guide while building and testing Rust systems with Chicago TDD Tools.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Christopher Alexander famously observed that great environments share a pattern language â€“ a network of proven responses to recurring forces. Chicago TDD Tools embodies the same philosophy for Rust testing. Instead of isolated utilities, the framework codifies high-leverage patterns that push teams toward dependable, behavior-focused tests and extendable architecture.</p>
<p>This cookbook distills those patterns. Each entry is written in Alexander's form so you can quickly scan the context, recognize the tension, and apply the solution. Read the patterns sequentially to see how they reinforce each other, or jump to the problem you have today.</p>
<p>The language is organized into three families:</p>
<ol>
<li><strong>Testing Patterns</strong> â€“ maintainable, behavior-driven tests that fail fast and verify real outcomes.</li>
<li><strong>Architecture Patterns</strong> â€“ structural choices that keep the framework extensible and consistent.</li>
<li><strong>Design Patterns</strong> â€“ type-level techniques, zero-cost abstractions, and compile-time validation.</li>
</ol>
<p>Combine these ingredients to build resilient Rust systems aligned with Chicago TDD principles: state-based testing, real collaborators, behavior verification, and the AAA pattern.</p>
<hr />
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p><strong>Not sure where to start?</strong> Choose your path:</p>
<div class="table-wrapper"><table><thead><tr><th>Your Situation</th><th>Go To</th><th>Time</th></tr></thead><tbody>
<tr><td><strong>I need to solve a problem</strong></td><td><a href="choosing-your-pattern.html">Choosing Your Pattern</a></td><td>5 min</td></tr>
<tr><td><strong>I want a quick overview</strong></td><td><a href="all-patterns-reference.html">All Patterns Reference</a></td><td>10 min</td></tr>
<tr><td><strong>I want to learn systematically</strong></td><td>Choose a learning sequence below</td><td>60-120 min</td></tr>
<tr><td><strong>I want a specific pattern</strong></td><td>Jump to pattern reference below</td><td>Varies</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="learning-sequences"><a class="header" href="#learning-sequences">Learning Sequences</a></h2>
<p>Learn patterns progressively through structured tutorials:</p>
<div class="table-wrapper"><table><thead><tr><th>Sequence</th><th>Focus</th><th>Time</th><th>Difficulty</th></tr></thead><tbody>
<tr><td><a href="tutorials/learning-testing-patterns.html">Testing Patterns</a></td><td>How to write better tests</td><td>90 min</td><td>Beginner</td></tr>
<tr><td><a href="tutorials/learning-architecture-patterns.html">Architecture Patterns</a></td><td>How to organize code</td><td>60 min</td><td>Intermediate</td></tr>
<tr><td><a href="tutorials/learning-design-patterns.html">Design Patterns</a></td><td>Type safety and optimization</td><td>120 min</td><td>Advanced</td></tr>
</tbody></table>
</div>
<p><strong>Recommended</strong>: Follow in order (Testing â†’ Architecture â†’ Design).</p>
<hr />
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><strong><a href="choosing-your-pattern.html">Choosing Your Pattern</a></strong> - Decision matrices to find the right pattern</li>
<li><strong><a href="all-patterns-reference.html">All Patterns Reference</a></strong> - All 20 patterns at a glance</li>
<li><strong><a href="testing-patterns/">Testing Patterns</a></strong> - Learn to write great tests</li>
<li><strong><a href="architecture-patterns/">Architecture Patterns</a></strong> - Learn to organize code</li>
<li><strong><a href="design-patterns/">Design Patterns</a></strong> - Learn advanced safety and design</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choosing-your-pattern"><a class="header" href="#choosing-your-pattern">Choosing Your Pattern</a></h1>
<blockquote>
<p>ğŸ—ºï¸ <strong>NAVIGATION</strong> | Find the right pattern for your testing problem</p>
</blockquote>
<p>This guide helps you choose the right pattern(s) based on your testing situation.</p>
<hr />
<h2 id="quick-pattern-finder"><a class="header" href="#quick-pattern-finder">Quick Pattern Finder</a></h2>
<p><strong>What's your challenge?</strong> Find it in the table below:</p>
<div class="table-wrapper"><table><thead><tr><th>Your Challenge</th><th>Pattern Family</th><th>Pattern Name</th><th>Go To</th></tr></thead><tbody>
<tr><td>How do I structure a test?</td><td>Testing</td><td>Pattern 1: AAA Pattern</td><td><a href="testing-patterns/aaa-pattern.html">Learn</a></td></tr>
<tr><td>How do I test error cases?</td><td>Testing</td><td>Pattern 2: Error Path Testing</td><td><a href="testing-patterns/error-path-testing.html">Learn</a></td></tr>
<tr><td>How do I test edge cases?</td><td>Testing</td><td>Pattern 3: Boundary Conditions</td><td><a href="testing-patterns/boundary-conditions.html">Learn</a></td></tr>
<tr><td>How do I clean up resources?</td><td>Testing</td><td>Pattern 4: Resource Cleanup</td><td><a href="testing-patterns/resource-cleanup.html">Learn</a></td></tr>
<tr><td>Should I use mocks?</td><td>Testing</td><td>Pattern 5: Real Collaborators</td><td><a href="testing-patterns/real-collaborators.html">Learn</a></td></tr>
<tr><td>How do I organize my code?</td><td>Architecture</td><td>Pattern 6: Generic Base Layer</td><td><a href="architecture-patterns/generic-base.html">Learn</a></td></tr>
<tr><td>How do I extend without duplicating?</td><td>Architecture</td><td>Pattern 7: Extension Layer</td><td><a href="architecture-patterns/extension-layer.html">Learn</a></td></tr>
<tr><td>How do I avoid code duplication?</td><td>Architecture</td><td>Pattern 8: Composition Over Duplication</td><td><a href="architecture-patterns/composition-over-duplication.html">Learn</a></td></tr>
<tr><td>How do I avoid data inconsistency?</td><td>Architecture</td><td>Pattern 9: Single Source of Truth</td><td><a href="architecture-patterns/single-source-of-truth.html">Learn</a></td></tr>
<tr><td>How do I organize large modules?</td><td>Architecture</td><td>Pattern 10: Capability Grouping</td><td><a href="architecture-patterns/capability-groups.html">Learn</a></td></tr>
<tr><td>How do I optimize for performance?</td><td>Design</td><td>Pattern 11: Zero-Cost Abstractions</td><td><a href="design-patterns/zero-cost-abstractions.html">Learn</a></td></tr>
<tr><td>How do I prevent type errors?</td><td>Design</td><td>Pattern 12: Type Safety with GATs</td><td><a href="design-patterns/type-safety-patterns.html">Learn</a></td></tr>
<tr><td>How do I prevent API misuse?</td><td>Design</td><td>Pattern 13: Sealed Traits</td><td><a href="design-patterns/sealed-traits.html">Learn</a></td></tr>
<tr><td>How do I validate at compile-time?</td><td>Design</td><td>Pattern 14: Compile-Time Validation</td><td><a href="design-patterns/compile-time-validation.html">Learn</a></td></tr>
<tr><td>How do I enforce state machines?</td><td>Design</td><td>Pattern 15: Type State Enforcement</td><td><a href="design-patterns/type-state-pattern.html">Learn</a></td></tr>
<tr><td>How do I manage fixture lifecycle?</td><td>Design</td><td>Pattern 16: Fixture Lifecycle Management</td><td><a href="design-patterns/fixture-lifecycle.html">Learn</a></td></tr>
<tr><td>How do I build test data easily?</td><td>Design</td><td>Pattern 17: Builder-Driven Test Data</td><td><a href="design-patterns/builder-test-data.html">Learn</a></td></tr>
<tr><td>How do I prevent timeouts?</td><td>Design</td><td>Pattern 18: Timeout Defense</td><td><a href="design-patterns/timeout-defense.html">Learn</a></td></tr>
<tr><td>How do I manage feature flags?</td><td>Design</td><td>Pattern 19: Feature Gate Slices</td><td><a href="design-patterns/feature-gating.html">Learn</a></td></tr>
<tr><td>How do I enforce patterns with macros?</td><td>Design</td><td>Pattern 20: Macro Pattern Enforcement</td><td><a href="design-patterns/macro-enforcement.html">Learn</a></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="by-category"><a class="header" href="#by-category">By Category</a></h2>
<h3 id="testing-patterns-how-do-i-write-better-tests"><a class="header" href="#testing-patterns-how-do-i-write-better-tests">Testing Patterns: "How Do I Write Better Tests?"</a></h3>
<p>These patterns solve fundamental testing problems:</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Problem</th><th>Solution</th></tr></thead><tbody>
<tr><td><strong>Pattern 1: AAA</strong></td><td>Tests are hard to read</td><td>Structure: Arrange, Act, Assert</td></tr>
<tr><td><strong>Pattern 2: Error Paths</strong></td><td>I don't test failures</td><td>Test both success and error cases</td></tr>
<tr><td><strong>Pattern 3: Boundaries</strong></td><td>I miss edge cases</td><td>Systematically test limits</td></tr>
<tr><td><strong>Pattern 4: Resource Cleanup</strong></td><td>Tests leak resources</td><td>Automatic fixture cleanup</td></tr>
<tr><td><strong>Pattern 5: Real Collaborators</strong></td><td>Mocks hide integration bugs</td><td>Test with real implementations</td></tr>
</tbody></table>
</div>
<p><strong>When to use</strong>: All the time. These are foundational.</p>
<p><strong>Learning Path</strong>: <a href="tutorials/learning-testing-patterns.html">Testing Patterns Learning Sequence</a></p>
<hr />
<h3 id="architecture-patterns-how-do-i-organize-code"><a class="header" href="#architecture-patterns-how-do-i-organize-code">Architecture Patterns: "How Do I Organize Code?"</a></h3>
<p>These patterns solve structural problems:</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Problem</th><th>Solution</th></tr></thead><tbody>
<tr><td><strong>Pattern 6: Generic Base</strong></td><td>Code is duplicate</td><td>Extract generic abstractions</td></tr>
<tr><td><strong>Pattern 7: Extension Layer</strong></td><td>I can't extend without modifying</td><td>Add layers for extensions</td></tr>
<tr><td><strong>Pattern 8: Composition</strong></td><td>DRY violations everywhere</td><td>Compose instead of duplicating</td></tr>
<tr><td><strong>Pattern 9: Single Source</strong></td><td>Data gets out of sync</td><td>One canonical source of truth</td></tr>
<tr><td><strong>Pattern 10: Capability Groups</strong></td><td>Module is too large</td><td>Organize by capability, not type</td></tr>
</tbody></table>
</div>
<p><strong>When to use</strong>: During architecture phase and refactoring.</p>
<p><strong>Learning Path</strong>: <a href="tutorials/learning-architecture-patterns.html">Architecture Patterns Learning Sequence</a></p>
<hr />
<h3 id="design-patterns-how-do-i-make-code-safer"><a class="header" href="#design-patterns-how-do-i-make-code-safer">Design Patterns: "How Do I Make Code Safer?"</a></h3>
<p>These patterns solve design and safety problems:</p>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Problem</th><th>Solution</th></tr></thead><tbody>
<tr><td><strong>Pattern 11: Zero-Cost</strong></td><td>Abstractions are slow</td><td>Zero-cost abstractions via generics</td></tr>
<tr><td><strong>Pattern 12: Type Safety</strong></td><td>Type errors at runtime</td><td>Use GATs for safety</td></tr>
<tr><td><strong>Pattern 13: Sealed Traits</strong></td><td>API is too easy to misuse</td><td>Seal traits to prevent misuse</td></tr>
<tr><td><strong>Pattern 14: Compile-Time</strong></td><td>Errors caught at runtime</td><td>Validate at compile-time</td></tr>
<tr><td><strong>Pattern 15: Type State</strong></td><td>State machines are error-prone</td><td>Encode states in types</td></tr>
<tr><td><strong>Pattern 16: Fixture Lifecycle</strong></td><td>Test setup is complex</td><td>Manage lifecycle with traits</td></tr>
<tr><td><strong>Pattern 17: Builder Test Data</strong></td><td>Building test data is tedious</td><td>Fluent builders for test data</td></tr>
<tr><td><strong>Pattern 18: Timeout Defense</strong></td><td>Tests hang forever</td><td>Timeout defense in depth</td></tr>
<tr><td><strong>Pattern 19: Feature Gates</strong></td><td>Feature flags are unreliable</td><td>Gate slices across codebase</td></tr>
<tr><td><strong>Pattern 20: Macro Enforcement</strong></td><td>Patterns are easy to violate</td><td>Use macros to enforce patterns</td></tr>
</tbody></table>
</div>
<p><strong>When to use</strong>: During design and implementation.</p>
<p><strong>Learning Path</strong>: <a href="tutorials/learning-design-patterns.html">Design Patterns Learning Sequence</a></p>
<hr />
<h2 id="decision-trees"><a class="header" href="#decision-trees">Decision Trees</a></h2>
<h3 id="im-writing-a-test-which-pattern-do-i-need"><a class="header" href="#im-writing-a-test-which-pattern-do-i-need">"I'm writing a test. Which pattern do I need?"</a></h3>
<pre><code>â”Œâ”€ Start: Writing a test
â”‚
â”œâ”€ What am I testing?
â”‚  â”œâ”€ Normal behavior â”€â”€â†’ Pattern 1: AAA Pattern
â”‚  â”œâ”€ Error behavior â”€â”€â†’ Pattern 2: Error Path Testing
â”‚  â”œâ”€ Edge cases â”€â”€â†’ Pattern 3: Boundary Conditions
â”‚  â””â”€ Setup/teardown â”€â”€â†’ Pattern 4: Resource Cleanup
â”‚
â”œâ”€ What should I test against?
â”‚  â”œâ”€ Mock/fake â”€â”€â†’ Consider Pattern 5: Real Collaborators
â”‚  â””â”€ Real implementation â”€â”€â†’ Pattern 5: Real Collaborators âœ“
â”‚
â””â”€ How do I build test data?
   â””â”€ Complex data â”€â”€â†’ Pattern 17: Builder-Driven Test Data
</code></pre>
<hr />
<h3 id="im-designing-an-architecture-which-patterns-apply"><a class="header" href="#im-designing-an-architecture-which-patterns-apply">"I'm designing an architecture. Which patterns apply?"</a></h3>
<pre><code>â”Œâ”€ Start: Designing architecture
â”‚
â”œâ”€ How do I organize modules?
â”‚  â”œâ”€ By type (models, handlers, etc.) â”€â”€â†’ Consider Pattern 10: Capability Groups
â”‚  â””â”€ By capability â”€â”€â†’ Pattern 10: Capability Groups âœ“
â”‚
â”œâ”€ How do I reuse code?
â”‚  â”œâ”€ Copy-paste â”€â”€â†’ NO! Use Pattern 8: Composition Over Duplication
â”‚  â””â”€ Abstract base â”€â”€â†’ Pattern 6: Generic Base Layer
â”‚
â”œâ”€ How do I extend without modifying?
â”‚  â””â”€ Pattern 7: Extension Layer
â”‚
â””â”€ Where is the source of truth?
   â””â”€ Pattern 9: Single Source of Truth
</code></pre>
<hr />
<h3 id="im-designing-apis-which-patterns-keep-them-safe"><a class="header" href="#im-designing-apis-which-patterns-keep-them-safe">"I'm designing APIs. Which patterns keep them safe?"</a></h3>
<pre><code>â”Œâ”€ Start: Designing public API
â”‚
â”œâ”€ Can downstream code misuse my API?
â”‚  â””â”€ YES â”€â”€â†’ Pattern 13: Sealed Traits
â”‚
â”œâ”€ Should errors be compile-time or runtime?
â”‚  â”œâ”€ Compile-time â”€â”€â†’ Pattern 14: Compile-Time Validation
â”‚  â””â”€ Runtime â”€â”€â†’ Less safe, but sometimes necessary
â”‚
â”œâ”€ Does state machine matter?
â”‚  â”œâ”€ YES (auth states, connection states) â”€â”€â†’ Pattern 15: Type State Enforcement
â”‚  â””â”€ NO â”€â”€â†’ Continue
â”‚
â”œâ”€ Are lifetimes complex?
â”‚  â””â”€ YES â”€â”€â†’ Pattern 12: Type Safety with GATs
â”‚
â””â”€ Should this be in macros?
   â””â”€ Pattern 20: Macro Pattern Enforcement
</code></pre>
<hr />
<h2 id="learning-by-difficulty"><a class="header" href="#learning-by-difficulty">Learning by Difficulty</a></h2>
<h3 id="beginner-start-here"><a class="header" href="#beginner-start-here">Beginner (Start Here)</a></h3>
<ol>
<li><strong>Pattern 1: AAA Pattern</strong> - Foundation</li>
<li><strong>Pattern 2: Error Path Testing</strong> - See what not to do</li>
<li><strong>Pattern 3: Boundary Conditions</strong> - Edge cases matter</li>
<li><strong>Pattern 4: Resource Cleanup</strong> - Don't leak resources</li>
<li><strong>Pattern 5: Real Collaborators</strong> - Test with real code</li>
</ol>
<p><strong>Time</strong>: ~3 hours | <strong>Content</strong>: Testing fundamentals</p>
<h3 id="intermediate-build-on-basics"><a class="header" href="#intermediate-build-on-basics">Intermediate (Build on Basics)</a></h3>
<ol start="6">
<li><strong>Pattern 6: Generic Base Layer</strong> - Code organization</li>
<li><strong>Pattern 8: Composition Over Duplication</strong> - DRY principle</li>
<li><strong>Pattern 10: Capability Grouping</strong> - Module organization</li>
<li><strong>Pattern 17: Builder-Driven Test Data</strong> - Practical testing</li>
<li><strong>Pattern 14: Compile-Time Validation</strong> - Type safety</li>
</ol>
<p><strong>Time</strong>: ~4 hours | <strong>Content</strong>: Architecture and safety</p>
<h3 id="advanced-master-the-craft"><a class="header" href="#advanced-master-the-craft">Advanced (Master the Craft)</a></h3>
<ol start="11">
<li><strong>Pattern 11: Zero-Cost Abstractions</strong> - Performance</li>
<li><strong>Pattern 12: Type Safety with GATs</strong> - Advanced types</li>
<li><strong>Pattern 15: Type State Enforcement</strong> - State machines</li>
<li><strong>Pattern 13: Sealed Traits</strong> - API design</li>
<li><strong>Pattern 18: Timeout Defense</strong> - Robustness</li>
</ol>
<p><strong>Time</strong>: ~5 hours | <strong>Content</strong>: Advanced design and optimization</p>
<hr />
<h2 id="pattern-combination-guide"><a class="header" href="#pattern-combination-guide">Pattern Combination Guide</a></h2>
<h3 id="i-want-to-write-production-quality-tests"><a class="header" href="#i-want-to-write-production-quality-tests">"I want to write production-quality tests"</a></h3>
<p>Use these patterns together:</p>
<ol>
<li><strong>Pattern 1: AAA</strong> - Structure your tests</li>
<li><strong>Pattern 2: Error Paths</strong> - Test failures</li>
<li><strong>Pattern 3: Boundaries</strong> - Test edge cases</li>
<li><strong>Pattern 4: Resource Cleanup</strong> - Clean automatically</li>
<li><strong>Pattern 5: Real Collaborators</strong> - Use real dependencies</li>
<li><strong>Pattern 17: Builder Test Data</strong> - Build complex test data</li>
</ol>
<p><strong>Expected outcome</strong>: Comprehensive, maintainable test suite</p>
<h3 id="i-want-to-build-a-safe-extensible-api"><a class="header" href="#i-want-to-build-a-safe-extensible-api">"I want to build a safe, extensible API"</a></h3>
<p>Use these patterns together:</p>
<ol>
<li><strong>Pattern 6: Generic Base</strong> - Reusable abstractions</li>
<li><strong>Pattern 7: Extension Layer</strong> - Allow extensibility</li>
<li><strong>Pattern 13: Sealed Traits</strong> - Prevent misuse</li>
<li><strong>Pattern 14: Compile-Time Validation</strong> - Validate early</li>
<li><strong>Pattern 15: Type State</strong> - Enforce state machines</li>
<li><strong>Pattern 20: Macro Enforcement</strong> - Enforce usage patterns</li>
</ol>
<p><strong>Expected outcome</strong>: Safe, extensible, hard-to-misuse API</p>
<h3 id="i-want-maximum-performance"><a class="header" href="#i-want-maximum-performance">"I want maximum performance"</a></h3>
<p>Use these patterns together:</p>
<ol>
<li><strong>Pattern 11: Zero-Cost Abstractions</strong> - Generic dispatch</li>
<li><strong>Pattern 12: Type Safety with GATs</strong> - Type-safe lifetimes</li>
<li><strong>Pattern 14: Compile-Time Validation</strong> - Zero runtime checks</li>
<li><strong>Pattern 8: Composition Over Duplication</strong> - Avoid copies</li>
</ol>
<p><strong>Expected outcome</strong>: Fast code with safety guarantees</p>
<hr />
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><strong>Q: How many patterns should I learn?</strong>
A: Start with Testing Patterns (5), then Architecture (5) for production code. Advanced designers learn all 20.</p>
<p><strong>Q: Do I need to learn them in order?</strong>
A: No, but the beginner patterns are prerequisites for understanding advanced ones.</p>
<p><strong>Q: Can I use just one pattern?</strong>
A: Yes, but patterns work together. Combine related patterns for best results.</p>
<p><strong>Q: Where do I go from here?</strong>
A: Choose a <a href="tutorials/">Learning Sequence</a> or pick a pattern you need right now.</p>
<p><strong>Q: How do patterns relate to the application guide?</strong>
A: Application guide shows <em>how to apply patterns in practice</em>. Cookbook explains <em>why patterns exist</em>. Use both together.</p>
<hr />
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Choose your learning path:</p>
<ul>
<li><strong><a href="tutorials/learning-testing-patterns.html">Testing Patterns Learning Path</a></strong> (90 minutes)</li>
<li><strong><a href="tutorials/learning-architecture-patterns.html">Architecture Patterns Learning Path</a></strong> (60 minutes)</li>
<li><strong><a href="tutorials/learning-design-patterns.html">Design Patterns Learning Path</a></strong> (120 minutes)</li>
<li><strong><a href="all-patterns-reference.html">All Patterns Quick Reference</a></strong> (Lookup table for all 20)</li>
</ul>
<p>Or jump directly to the pattern you need from the Quick Finder above.</p>
<hr />
<p><strong>Remember</strong>: Patterns work together. As you learn each one, you'll recognize them appearing in others. That's the power of a pattern language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="all-patterns-quick-reference-card"><a class="header" href="#all-patterns-quick-reference-card">All Patterns: Quick Reference Card</a></h1>
<blockquote>
<p>ğŸ“š <strong>REFERENCE</strong> | All 20 patterns at a glance</p>
</blockquote>
<p>Quick lookup for all patterns. Use this to find a pattern and jump to its full description.</p>
<hr />
<h2 id="testing-patterns-5"><a class="header" href="#testing-patterns-5">Testing Patterns (5)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>#</th><th>Pattern</th><th>Problem</th><th>Solution</th><th>Learn More</th></tr></thead><tbody>
<tr><td>1</td><td><strong>AAA Pattern</strong></td><td>Tests are unreadable</td><td>Structure into Arrange-Act-Assert</td><td><a href="testing-patterns/aaa-pattern.html">â†’</a></td></tr>
<tr><td>2</td><td><strong>Error Path Testing</strong></td><td>Failures aren't tested</td><td>Test both success AND error paths</td><td><a href="testing-patterns/error-path-testing.html">â†’</a></td></tr>
<tr><td>3</td><td><strong>Boundary Conditions</strong></td><td>Edge cases are missed</td><td>Systematically test limits</td><td><a href="testing-patterns/boundary-conditions.html">â†’</a></td></tr>
<tr><td>4</td><td><strong>Resource Cleanup</strong></td><td>Tests leak resources</td><td>Automatic fixture cleanup</td><td><a href="testing-patterns/resource-cleanup.html">â†’</a></td></tr>
<tr><td>5</td><td><strong>Real Collaborators</strong></td><td>Mocks hide bugs</td><td>Test with real implementations</td><td><a href="testing-patterns/real-collaborators.html">â†’</a></td></tr>
</tbody></table>
</div>
<p><strong>Key</strong>: These 5 patterns are the <strong>foundation</strong>. Use them in every test.</p>
<hr />
<h2 id="architecture-patterns-5"><a class="header" href="#architecture-patterns-5">Architecture Patterns (5)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>#</th><th>Pattern</th><th>Problem</th><th>Solution</th><th>Learn More</th></tr></thead><tbody>
<tr><td>6</td><td><strong>Generic Base Layer</strong></td><td>Code duplication</td><td>Extract generic abstractions</td><td><a href="architecture-patterns/generic-base.html">â†’</a></td></tr>
<tr><td>7</td><td><strong>Extension Layer</strong></td><td>Can't extend without modifying</td><td>Add layers for safe extension</td><td><a href="architecture-patterns/extension-layer.html">â†’</a></td></tr>
<tr><td>8</td><td><strong>Composition Over Duplication</strong></td><td>DRY violations</td><td>Compose instead of copying</td><td><a href="architecture-patterns/composition-over-duplication.html">â†’</a></td></tr>
<tr><td>9</td><td><strong>Single Source of Truth</strong></td><td>Data inconsistencies</td><td>One canonical source</td><td><a href="architecture-patterns/single-source-of-truth.html">â†’</a></td></tr>
<tr><td>10</td><td><strong>Capability Grouping</strong></td><td>Monolithic modules</td><td>Organize by capability</td><td><a href="architecture-patterns/capability-groups.html">â†’</a></td></tr>
</tbody></table>
</div>
<p><strong>Key</strong>: These 5 patterns organize code structure. Use during architecture phase.</p>
<hr />
<h2 id="design-patterns-10"><a class="header" href="#design-patterns-10">Design Patterns (10)</a></h2>
<div class="table-wrapper"><table><thead><tr><th>#</th><th>Pattern</th><th>Problem</th><th>Solution</th><th>Learn More</th></tr></thead><tbody>
<tr><td>11</td><td><strong>Zero-Cost Abstractions</strong></td><td>Abstractions are slow</td><td>Use generics, compile away overhead</td><td><a href="design-patterns/zero-cost-abstractions.html">â†’</a></td></tr>
<tr><td>12</td><td><strong>Type Safety with GATs</strong></td><td>Type errors at runtime</td><td>Generic Associated Types</td><td><a href="design-patterns/type-safety-patterns.html">â†’</a></td></tr>
<tr><td>13</td><td><strong>Sealed Traits</strong></td><td>API is too easy to misuse</td><td>Seal traits to prevent misuse</td><td><a href="design-patterns/sealed-traits.html">â†’</a></td></tr>
<tr><td>14</td><td><strong>Compile-Time Validation</strong></td><td>Errors caught at runtime</td><td>Validate during compilation</td><td><a href="design-patterns/compile-time-validation.html">â†’</a></td></tr>
<tr><td>15</td><td><strong>Type State Enforcement</strong></td><td>State machines are error-prone</td><td>Encode states in the type system</td><td><a href="design-patterns/type-state-pattern.html">â†’</a></td></tr>
<tr><td>16</td><td><strong>Fixture Lifecycle</strong></td><td>Complex test setup</td><td>Manage with sealed traits</td><td><a href="design-patterns/fixture-lifecycle.html">â†’</a></td></tr>
<tr><td>17</td><td><strong>Builder-Driven Test Data</strong></td><td>Building test data is tedious</td><td>Fluent builders for data</td><td><a href="design-patterns/builder-test-data.html">â†’</a></td></tr>
<tr><td>18</td><td><strong>Timeout Defense</strong></td><td>Tests hang indefinitely</td><td>Timeout defense in depth</td><td><a href="design-patterns/timeout-defense.html">â†’</a></td></tr>
<tr><td>19</td><td><strong>Feature Gate Slices</strong></td><td>Feature flags are unreliable</td><td>Slice-based feature gating</td><td><a href="design-patterns/feature-gating.html">â†’</a></td></tr>
<tr><td>20</td><td><strong>Macro Pattern Enforcement</strong></td><td>Patterns are easy to violate</td><td>Use macros to enforce</td><td><a href="design-patterns/macro-enforcement.html">â†’</a></td></tr>
</tbody></table>
</div>
<p><strong>Key</strong>: These 10 patterns provide safety, performance, and design tools. Use during implementation.</p>
<hr />
<h2 id="pattern-organization"><a class="header" href="#pattern-organization">Pattern Organization</a></h2>
<h3 id="by-complexity-learning-path"><a class="header" href="#by-complexity-learning-path">By Complexity (Learning Path)</a></h3>
<p><strong>Phase 1 - Foundation (Read First)</strong></p>
<ol>
<li>Pattern 1: AAA Pattern</li>
<li>Pattern 2: Error Path Testing</li>
<li>Pattern 3: Boundary Conditions</li>
</ol>
<p><strong>Phase 2 - Production Ready (Read Next)</strong>
4. Pattern 4: Resource Cleanup
5. Pattern 5: Real Collaborators
6. Pattern 17: Builder-Driven Test Data</p>
<p><strong>Phase 3 - Architecture (Advanced)</strong>
6. Pattern 8: Composition Over Duplication
7. Pattern 10: Capability Grouping
8. Pattern 9: Single Source of Truth</p>
<p><strong>Phase 4 - Advanced Design (Mastery)</strong>
11. Pattern 11: Zero-Cost Abstractions
12. Pattern 13: Sealed Traits
13. Pattern 15: Type State Enforcement
14. Pattern 20: Macro Pattern Enforcement</p>
<hr />
<h3 id="by-category-type-system"><a class="header" href="#by-category-type-system">By Category (Type System)</a></h3>
<p><strong>Testing Patterns</strong>: Patterns 1-5
<strong>Architecture Patterns</strong>: Patterns 6-10
<strong>Design Patterns</strong>: Patterns 11-20</p>
<hr />
<h3 id="by-problem-domain"><a class="header" href="#by-problem-domain">By Problem Domain</a></h3>
<p><strong>Testing Problems</strong>: Patterns 1-5, 17
<strong>Code Organization</strong>: Patterns 6-10
<strong>Type Safety</strong>: Patterns 12, 14, 15
<strong>API Design</strong>: Patterns 13, 20
<strong>Performance</strong>: Pattern 11
<strong>Robustness</strong>: Pattern 18
<strong>Reliability</strong>: Pattern 19</p>
<hr />
<h2 id="how-to-use-this-card"><a class="header" href="#how-to-use-this-card">How to Use This Card</a></h2>
<ol>
<li><strong>Find your problem</strong> in the Problem column</li>
<li><strong>See the solution</strong> in the Solution column</li>
<li><strong>Click Learn More</strong> to read the full pattern</li>
<li><strong>Bookmark</strong> the pattern for future reference</li>
</ol>
<hr />
<h2 id="quick-links-1"><a class="header" href="#quick-links-1">Quick Links</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Want to...</th><th>Go to...</th></tr></thead><tbody>
<tr><td>Choose a pattern</td><td><a href="choosing-your-pattern.html">Choosing Your Pattern</a></td></tr>
<tr><td>Learn testing</td><td><a href="tutorials/learning-testing-patterns.html">Testing Learning Sequence</a></td></tr>
<tr><td>Learn architecture</td><td><a href="tutorials/learning-architecture-patterns.html">Architecture Learning Sequence</a></td></tr>
<tr><td>Learn design</td><td><a href="tutorials/learning-design-patterns.html">Design Learning Sequence</a></td></tr>
<tr><td>All 20 patterns</td><td>This page (you are here)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="pattern-dependencies"><a class="header" href="#pattern-dependencies">Pattern Dependencies</a></h2>
<p>Some patterns build on others. Recommended learning order:</p>
<pre><code>Pattern 1 (AAA)
  â”œâ”€â†’ Pattern 2 (Error Paths)
  â”œâ”€â†’ Pattern 3 (Boundaries)
  â”œâ”€â†’ Pattern 4 (Resource Cleanup)
  â””â”€â†’ Pattern 5 (Real Collaborators)
       â””â”€â†’ Pattern 17 (Builder Test Data)

Pattern 6 (Generic Base)
  â””â”€â†’ Pattern 8 (Composition)
       â””â”€â†’ Pattern 10 (Capability Groups)

Pattern 14 (Compile-Time)
  â””â”€â†’ Pattern 15 (Type State)

Pattern 13 (Sealed Traits)
  â””â”€â†’ Pattern 20 (Macro Enforcement)
</code></pre>
<hr />
<h2 id="statistics"><a class="header" href="#statistics">Statistics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody>
<tr><td>Total Patterns</td><td>20</td></tr>
<tr><td>Testing Patterns</td><td>5</td></tr>
<tr><td>Architecture Patterns</td><td>5</td></tr>
<tr><td>Design Patterns</td><td>10</td></tr>
<tr><td>Difficulty Range</td><td>Beginner â†’ Advanced</td></tr>
<tr><td>Total Learning Time</td><td>~10 hours</td></tr>
<tr><td>Estimated Implementation</td><td>2-3 weeks</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="pro-tips"><a class="header" href="#pro-tips">Pro Tips</a></h2>
<p>ğŸ’¡ <strong>Tip 1</strong>: You don't need to learn all 20 patterns at once. Start with Testing (1-5), then add what you need.</p>
<p>ğŸ’¡ <strong>Tip 2</strong>: Patterns often appear in combinations. When you use Pattern 5 (Real Collaborators), you'll probably also use Pattern 17 (Builder Test Data).</p>
<p>ğŸ’¡ <strong>Tip 3</strong>: Look for patterns in the codebase you're reading. The more you see patterns, the better you'll understand them.</p>
<p>ğŸ’¡ <strong>Tip 4</strong>: Bookmark the <a href="choosing-your-pattern.html">Decision Guide</a>. You'll return to it when solving problems.</p>
<hr />
<p><strong>Next</strong>: Choose your learning path or jump to a pattern you need right now!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-testing-patterns-90-minute-mastery"><a class="header" href="#learning-testing-patterns-90-minute-mastery">Learning Testing Patterns: 90-Minute Mastery</a></h1>
<blockquote>
<p>ğŸ“ <strong>TUTORIAL</strong> | Master the 5 fundamental testing patterns</p>
</blockquote>
<p>This tutorial guides you through the 5 testing patterns in a natural progression. Each builds on the previous one.</p>
<p><strong>Time</strong>: ~90 minutes | <strong>Difficulty</strong>: Beginner | <strong>Prerequisites</strong>: Basic Rust knowledge</p>
<hr />
<h2 id="module-overview"><a class="header" href="#module-overview">Module Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Time</th><th>Focus</th></tr></thead><tbody>
<tr><td>Pattern 1: AAA</td><td>15 min</td><td>Test structure and readability</td></tr>
<tr><td>Pattern 2: Error Paths</td><td>20 min</td><td>Testing failures and error cases</td></tr>
<tr><td>Pattern 3: Boundaries</td><td>15 min</td><td>Edge cases and limits</td></tr>
<tr><td>Pattern 4: Resource Cleanup</td><td>15 min</td><td>Automatic cleanup and fixtures</td></tr>
<tr><td>Pattern 5: Real Collaborators</td><td>15 min</td><td>Testing with real dependencies</td></tr>
<tr><td><strong>Practice Exercises</strong></td><td><strong>15 min</strong></td><td><strong>Apply what you've learned</strong></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="part-1-aaa-pattern-15-minutes"><a class="header" href="#part-1-aaa-pattern-15-minutes">Part 1: AAA Pattern (15 minutes)</a></h2>
<p><strong>Goal</strong>: Understand how to structure tests for readability</p>
<h3 id="the-three-phases"><a class="header" href="#the-three-phases">The Three Phases</a></h3>
<p>Every test has three parts:</p>
<ol>
<li><strong>Arrange</strong>: Set up the test data and environment</li>
<li><strong>Act</strong>: Execute the behavior you're testing</li>
<li><strong>Assert</strong>: Verify the result is correct</li>
</ol>
<h3 id="example-structure"><a class="header" href="#example-structure">Example Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_name, {
    // Arrange: Set up
    let input = 42;

    // Act: Execute
    let result = process(input);

    // Assert: Verify
    assert_eq!(result, 84);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="key-points"><a class="header" href="#key-points">Key Points</a></h3>
<p>âœ… <strong>Do</strong>: Label each phase with comments
âœ… <strong>Do</strong>: Test one behavior per test
âœ… <strong>Do</strong>: Make test names describe what they test</p>
<p>âŒ <strong>Don't</strong>: Mix phases together
âŒ <strong>Don't</strong>: Put logic in assertions
âŒ <strong>Don't</strong>: Test multiple behaviors in one test</p>
<h3 id="checkpoint-question"><a class="header" href="#checkpoint-question">Checkpoint Question</a></h3>
<p>How would you structure a test that:</p>
<ol>
<li>Creates a user</li>
<li>Verifies the user was created correctly</li>
</ol>
<p><strong>Answer</strong>: Create â†’ Verify (Pattern 1: AAA structure)</p>
<hr />
<h2 id="part-2-error-path-testing-20-minutes"><a class="header" href="#part-2-error-path-testing-20-minutes">Part 2: Error Path Testing (20 minutes)</a></h2>
<p><strong>Goal</strong>: Test both success AND failure cases</p>
<h3 id="why-error-testing-matters"><a class="header" href="#why-error-testing-matters">Why Error Testing Matters</a></h3>
<p>Tests that only verify success hide bugs. Real systems fail. You must test how code behaves when things go wrong.</p>
<h3 id="success-path-vs-error-path"><a class="header" href="#success-path-vs-error-path">Success Path vs. Error Path</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Success path: Everything works
test!(test_add_user_success, {
    // Arrange
    let mut db = Database::new();

    // Act
    let result = db.add_user("alice@example.com");

    // Assert
    assert_ok!(&amp;result);  // Should succeed
});

// Error path: Something goes wrong
test!(test_add_duplicate_user_fails, {
    // Arrange
    let mut db = Database::new();
    db.add_user("alice@example.com").ok();  // Add once

    // Act
    let result = db.add_user("alice@example.com");  // Try to add again

    // Assert
    assert_err!(&amp;result);  // Should fail
});
<span class="boring">}</span></code></pre></pre>
<h3 id="what-to-test"><a class="header" href="#what-to-test">What to Test</a></h3>
<p>For each behavior, test:</p>
<ol>
<li><strong>Normal case</strong> - Everything works perfectly</li>
<li><strong>Invalid input</strong> - Bad data</li>
<li><strong>Boundary case</strong> - Limits (empty, max size, etc.)</li>
<li><strong>Error case</strong> - Something fails</li>
<li><strong>Concurrent case</strong> (if applicable) - Multiple threads</li>
</ol>
<h3 id="checkpoint-question-1"><a class="header" href="#checkpoint-question-1">Checkpoint Question</a></h3>
<p>You have a function <code>divide(a, b)</code> that returns <code>Result&lt;i32, Error&gt;</code>.</p>
<p><strong>What test cases should you write?</strong></p>
<p>Answers:</p>
<ol>
<li>âœ… Normal: <code>divide(10, 2)</code> â†’ <code>Ok(5)</code></li>
<li>âœ… Error: <code>divide(10, 0)</code> â†’ <code>Err(Division by zero)</code></li>
<li>âœ… Boundary: Negative numbers?  Large numbers?</li>
</ol>
<hr />
<h2 id="part-3-boundary-conditions-15-minutes"><a class="header" href="#part-3-boundary-conditions-15-minutes">Part 3: Boundary Conditions (15 minutes)</a></h2>
<p><strong>Goal</strong>: Systematically test edge cases</p>
<h3 id="what-are-boundaries"><a class="header" href="#what-are-boundaries">What Are Boundaries?</a></h3>
<p>Boundaries are the limits where bugs often hide:</p>
<ul>
<li>Empty collections (size 0)</li>
<li>Full collections (size = capacity)</li>
<li>Negative numbers</li>
<li>Maximum values</li>
<li>Null/None cases</li>
<li>First vs. Last elements</li>
</ul>
<h3 id="boundary-testing-pattern"><a class="header" href="#boundary-testing-pattern">Boundary Testing Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_boundaries, {
    // Arrange
    let mut list = List::new();

    // Test: Empty list (boundary)
    assert_eq!(list.len(), 0);

    // Test: Add one (crossing boundary)
    list.add(42);
    assert_eq!(list.len(), 1);

    // Test: Add many (stress)
    for i in 0..1000 {
        list.add(i);
    }
    assert_eq!(list.len(), 1001);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="common-boundaries-to-test"><a class="header" href="#common-boundaries-to-test">Common Boundaries to Test</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Boundary</th><th>Test Values</th><th>Example</th></tr></thead><tbody>
<tr><td>Empty</td><td>0 items</td><td><code>vec![]</code></td></tr>
<tr><td>Single</td><td>1 item</td><td><code>vec![1]</code></td></tr>
<tr><td>Multiple</td><td>2-many items</td><td><code>vec![1, 2, 3...]</code></td></tr>
<tr><td>Negative</td><td>Negative numbers</td><td><code>-1, -100</code></td></tr>
<tr><td>Maximum</td><td>Max value</td><td><code>u32::MAX</code></td></tr>
<tr><td>Minimum</td><td>Min value</td><td><code>u32::MIN</code></td></tr>
</tbody></table>
</div>
<h3 id="checkpoint-question-2"><a class="header" href="#checkpoint-question-2">Checkpoint Question</a></h3>
<p>You're testing a <code>split_string(s, limit)</code> function.</p>
<p><strong>What boundary cases should you test?</strong></p>
<p>Answers:</p>
<ol>
<li>âœ… Empty string</li>
<li>âœ… Limit = 0</li>
<li>âœ… Limit = 1</li>
<li>âœ… Limit &gt; length</li>
<li>âœ… Very long string</li>
</ol>
<hr />
<h2 id="part-4-resource-cleanup-15-minutes"><a class="header" href="#part-4-resource-cleanup-15-minutes">Part 4: Resource Cleanup (15 minutes)</a></h2>
<p><strong>Goal</strong>: Ensure tests clean up automatically</p>
<h3 id="why-cleanup-matters"><a class="header" href="#why-cleanup-matters">Why Cleanup Matters</a></h3>
<p>Tests often create resources:</p>
<ul>
<li>Files</li>
<li>Database connections</li>
<li>Network sockets</li>
<li>Memory allocations</li>
</ul>
<p>If not cleaned up, tests <strong>leak resources</strong> and fail.</p>
<h3 id="the-fixture-pattern"><a class="header" href="#the-fixture-pattern">The Fixture Pattern</a></h3>
<p>Chicago TDD provides <code>TestFixture</code> for automatic cleanup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_with_cleanup, {
    // Create fixture - sets up
    let fixture = TestFixture::new()?;

    // Use the fixture
    fixture.set_metadata("key", "value");

    // No need to cleanup - happens automatically
    // when fixture is dropped!
});  // Cleanup happens here automatically
<span class="boring">}</span></code></pre></pre>
<h3 id="what-gets-cleaned-up"><a class="header" href="#what-gets-cleaned-up">What Gets Cleaned Up</a></h3>
<ul>
<li>File handles closed</li>
<li>Connections closed</li>
<li>Memory freed</li>
<li>Temporary directories removed</li>
</ul>
<p>All automatic! âœ…</p>
<h3 id="checkpoint-question-3"><a class="header" href="#checkpoint-question-3">Checkpoint Question</a></h3>
<p>You're writing tests that use a database. What should you do?</p>
<p>Answer: Use a <code>TestFixture</code> that:</p>
<ul>
<li>Connects to test database on creation</li>
<li>Runs tests</li>
<li>Closes connection automatically on drop</li>
</ul>
<hr />
<h2 id="part-5-real-collaborators-15-minutes"><a class="header" href="#part-5-real-collaborators-15-minutes">Part 5: Real Collaborators (15 minutes)</a></h2>
<p><strong>Goal</strong>: Test with real implementations, not mocks</p>
<h3 id="mocks-vs-real-implementations"><a class="header" href="#mocks-vs-real-implementations">Mocks vs. Real Implementations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Using a mock (hides integration bugs)
test!(test_with_mock, {
    let mock_client = MockApiClient::new();  // Fake
    mock_client.set_response(Ok(User { ... }));
    let result = my_service.fetch_user(&amp;mock_client);
    assert_ok!(&amp;result);
    // But does real client work? Who knows!
});

// âœ… Using real implementation (catches real bugs)
test!(test_with_real_client, {
    let real_client = RealApiClient::new();  // Actually calls API
    let result = my_service.fetch_user(&amp;real_client);
    assert_ok!(&amp;result);
    // Proves it works with the real API
});
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-real-collaborators"><a class="header" href="#when-to-use-real-collaborators">When to Use Real Collaborators</a></h3>
<p>âœ… <strong>Always preferred</strong>:</p>
<ul>
<li>Database queries</li>
<li>File I/O</li>
<li>Web services</li>
<li>Network calls</li>
</ul>
<p>âœ… <strong>When it's fast</strong> (&lt; 100ms):</p>
<ul>
<li>Real implementations</li>
</ul>
<p>âŒ <strong>Only when necessary</strong>:</p>
<ul>
<li>Slow external services (use test doubles)</li>
<li>Non-deterministic behavior</li>
<li>Expensive operations</li>
</ul>
<h3 id="the-philosophy"><a class="header" href="#the-philosophy">The Philosophy</a></h3>
<p><strong>Chicago TDD principle</strong>: Test behavior with real dependencies. This proves code actually works, not just in the test's imagination.</p>
<h3 id="checkpoint-question-4"><a class="header" href="#checkpoint-question-4">Checkpoint Question</a></h3>
<p>You're testing a payment service. What should you test against?</p>
<p>Answer: A real (test) payment processor, not a mock. Why? Because the real one is what you'll use in production.</p>
<hr />
<h2 id="putting-it-together-practice-exercise-15-minutes"><a class="header" href="#putting-it-together-practice-exercise-15-minutes">Putting It Together: Practice Exercise (15 minutes)</a></h2>
<h3 id="exercise-user-registration-service"><a class="header" href="#exercise-user-registration-service">Exercise: User Registration Service</a></h3>
<p>Write tests for this service:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct UserService {
    db: UserDatabase,
}

impl UserService {
    pub fn register(&amp;mut self, email: &amp;str, password: &amp;str) -&gt; Result&lt;User, Error&gt; {
        // Validate input
        if email.is_empty() || password.len() &lt; 8 {
            return Err(Error::InvalidInput);
        }

        // Check if user exists
        if self.db.user_exists(email) {
            return Err(Error::UserExists);
        }

        // Create user
        let user = User::new(email, password);
        self.db.save(&amp;user)?;
        Ok(user)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="what-tests-should-you-write"><a class="header" href="#what-tests-should-you-write">What Tests Should You Write?</a></h3>
<p>Using all 5 patterns, write tests for:</p>
<ol>
<li><strong>Pattern 1 (AAA)</strong>: Structure tests clearly</li>
<li><strong>Pattern 2 (Error Paths)</strong>:
<ul>
<li>Empty email âŒ</li>
<li>Short password âŒ</li>
<li>User already exists âŒ</li>
<li>Valid registration âœ…</li>
</ul>
</li>
<li><strong>Pattern 3 (Boundaries)</strong>:
<ul>
<li>Minimum password length (7, 8, 9 chars)</li>
<li>Very long email</li>
</ul>
</li>
<li><strong>Pattern 4 (Resource Cleanup)</strong>:
<ul>
<li>Use fixture for database cleanup</li>
</ul>
</li>
<li><strong>Pattern 5 (Real Collaborators)</strong>:
<ul>
<li>Use real UserDatabase, not mock</li>
</ul>
</li>
</ol>
<h3 id="example-solution-framework"><a class="header" href="#example-solution-framework">Example Solution Framework</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_register_success, {
    // Arrange
    let fixture = TestFixture::new()?;
    let db = fixture.test_database();  // Real database
    let mut service = UserService::new(db);

    // Act
    let result = service.register("alice@example.com", "password123");

    // Assert
    assert_ok!(&amp;result);
    let user = result.unwrap();
    assert_eq!(user.email, "alice@example.com");
});
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-the-5-testing-patterns"><a class="header" href="#summary-the-5-testing-patterns">Summary: The 5 Testing Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Goal</th><th>Use When</th></tr></thead><tbody>
<tr><td><strong>Pattern 1: AAA</strong></td><td>ReadÂ­able tests</td><td>Every test</td></tr>
<tr><td><strong>Pattern 2: Error Paths</strong></td><td>Test failures</td><td>Every function</td></tr>
<tr><td><strong>Pattern 3: Boundaries</strong></td><td>Test limits</td><td>Every input</td></tr>
<tr><td><strong>Pattern 4: Resource Cleanup</strong></td><td>Auto cleanup</td><td>Complex tests</td></tr>
<tr><td><strong>Pattern 5: Real Collaborators</strong></td><td>Real deps</td><td>Integration tests</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<h3 id="immediate-today"><a class="header" href="#immediate-today">Immediate (Today)</a></h3>
<p>Write 5-10 tests using all patterns for something in your codebase.</p>
<h3 id="short-term-this-week"><a class="header" href="#short-term-this-week">Short-term (This Week)</a></h3>
<p>Review existing tests. Rewrite any that don't follow these patterns.</p>
<h3 id="long-term-this-month"><a class="header" href="#long-term-this-month">Long-term (This Month)</a></h3>
<p>Learn <a href="tutorials/learning-architecture-patterns.html">Architecture Patterns</a> to organize your code structure.</p>
<hr />
<h2 id="checkpoint-do-you-know"><a class="header" href="#checkpoint-do-you-know">Checkpoint: Do You Know...?</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
How to structure a test with AAA?</li>
<li><input disabled="" type="checkbox"/>
How to test both success and error cases?</li>
<li><input disabled="" type="checkbox"/>
What boundary conditions to test?</li>
<li><input disabled="" type="checkbox"/>
How fixtures provide automatic cleanup?</li>
<li><input disabled="" type="checkbox"/>
Why real collaborators are better than mocks?</li>
</ul>
<p>If you answered yes to all, you've mastered Testing Patterns! ğŸ‰</p>
<hr />
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><strong>Full Pattern Details</strong>: <a href="tutorials/../testing-patterns/">Testing Patterns</a></li>
<li><strong>Decision Guide</strong>: <a href="tutorials/../choosing-your-pattern.html">Choosing Your Pattern</a></li>
<li><strong>All Patterns</strong>: <a href="tutorials/../all-patterns-reference.html">Quick Reference</a></li>
</ul>
<hr />
<p><strong>Congratulations!</strong> You now understand the 5 fundamental testing patterns. Next, learn how to organize your code with Architecture Patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-architecture-patterns-60-minute-mastery"><a class="header" href="#learning-architecture-patterns-60-minute-mastery">Learning Architecture Patterns: 60-Minute Mastery</a></h1>
<blockquote>
<p>ğŸ“ <strong>TUTORIAL</strong> | Master the 5 fundamental architecture patterns</p>
</blockquote>
<p>This tutorial guides you through the 5 architecture patterns that organize your codebase.</p>
<p><strong>Time</strong>: ~60 minutes | <strong>Difficulty</strong>: Intermediate | <strong>Prerequisites</strong>: <a href="tutorials/learning-testing-patterns.html">Testing Patterns</a></p>
<hr />
<h2 id="module-overview-1"><a class="header" href="#module-overview-1">Module Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Time</th><th>Focus</th></tr></thead><tbody>
<tr><td>Pattern 6: Generic Base Layer</td><td>15 min</td><td>Eliminating duplication with abstractions</td></tr>
<tr><td>Pattern 7: Extension Layer</td><td>12 min</td><td>Safe extensibility without modification</td></tr>
<tr><td>Pattern 8: Composition Over Duplication</td><td>12 min</td><td>DRY principle in action</td></tr>
<tr><td>Pattern 9: Single Source of Truth</td><td>12 min</td><td>Keeping data consistent</td></tr>
<tr><td>Pattern 10: Capability Grouping</td><td>9 min</td><td>Organizing large modules</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="part-1-generic-base-layer-15-minutes"><a class="header" href="#part-1-generic-base-layer-15-minutes">Part 1: Generic Base Layer (15 minutes)</a></h2>
<p><strong>Goal</strong>: Eliminate code duplication through generic abstractions</p>
<h3 id="the-problem-code-duplication"><a class="header" href="#the-problem-code-duplication">The Problem: Code Duplication</a></h3>
<p>Imagine you have multiple types that behave similarly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Duplicate code everywhere
struct FileStorage {
    path: String,
}

impl FileStorage {
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;String&gt; { ... }
    fn set(&amp;self, key: &amp;str, value: String) -&gt; Result&lt;()&gt; { ... }
    fn delete(&amp;self, key: &amp;str) -&gt; Result&lt;()&gt; { ... }
}

struct DatabaseStorage {
    connection: Connection,
}

impl DatabaseStorage {
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;String&gt; { ... }
    fn set(&amp;self, key: &amp;str, value: String) -&gt; Result&lt;()&gt; { ... }
    fn delete(&amp;self, key: &amp;str) -&gt; Result&lt;()&gt; { ... }
}

// Duplicated 9 times!
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-generic-abstraction"><a class="header" href="#the-solution-generic-abstraction">The Solution: Generic Abstraction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Define generic behavior once
pub trait KeyValueStore {
    fn get(&amp;self, key: &amp;str) -&gt; Result&lt;String&gt;;
    fn set(&amp;self, key: &amp;str, value: String) -&gt; Result&lt;()&gt;;
    fn delete(&amp;self, key: &amp;str) -&gt; Result&lt;()&gt;;
}

// Both implement the same trait
struct FileStorage { ... }
impl KeyValueStore for FileStorage { ... }

struct DatabaseStorage { ... }
impl KeyValueStore for DatabaseStorage { ... }

// Code that works with BOTH
fn backup_all_data(store: &amp;dyn KeyValueStore) {
    // Works with file, database, or any implementation!
}
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-this-pattern"><a class="header" href="#when-to-use-this-pattern">When to Use This Pattern</a></h3>
<p>âœ… <strong>Use when</strong>: You have similar code in multiple places
âœ… <strong>Use when</strong>: You want to swap implementations
âœ… <strong>Use when</strong>: You want to test with fakes/stubs</p>
<h3 id="checkpoint-question-5"><a class="header" href="#checkpoint-question-5">Checkpoint Question</a></h3>
<p>You have <code>RedisCache</code> and <code>MemoryCache</code> with nearly identical code.</p>
<p><strong>What should you do?</strong></p>
<p>Answer: Extract a <code>Cache</code> trait and implement it for both.</p>
<hr />
<h2 id="part-2-extension-layer-12-minutes"><a class="header" href="#part-2-extension-layer-12-minutes">Part 2: Extension Layer (12 minutes)</a></h2>
<p><strong>Goal</strong>: Allow safe extensions without modifying existing code</p>
<h3 id="the-problem-modifying-core-code"><a class="header" href="#the-problem-modifying-core-code">The Problem: Modifying Core Code</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Original code
pub struct HttpServer {
    fn handle_request(&amp;self, req: Request) {
        // Handle request
    }
}

// âŒ To add logging, you modify the core:
impl HttpServer {
    fn handle_request(&amp;self, req: Request) {
        println!("Request: {:?}", req);  // Logging added
        // Handle request
    }
}

// âŒ To add authentication, you modify again:
impl HttpServer {
    fn handle_request(&amp;self, req: Request) {
        println!("Request: {:?}", req);  // Still here
        // Check auth
        // Handle request
    }
}

// âŒ Code gets messy fast!
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-extension-layer"><a class="header" href="#the-solution-extension-layer">The Solution: Extension Layer</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Core code - never changes
pub struct HttpServer { ... }

// Extension layer - add features here
pub struct LoggingHttpServer {
    inner: HttpServer,
}

impl LoggingHttpServer {
    fn handle_request(&amp;self, req: Request) {
        println!("Request: {:?}", req);
        self.inner.handle_request(req);
    }
}

// Another extension layer
pub struct AuthHttpServer {
    inner: LoggingHttpServer,
}

impl AuthHttpServer {
    fn handle_request(&amp;self, req: Request) {
        if !req.is_authenticated() {
            return Err(Unauthorized);
        }
        self.inner.handle_request(req);
    }
}

// Usage: Stack them!
let server = HttpServer::new();
let logged = LoggingHttpServer::new(server);
let secured = AuthHttpServer::new(logged);
<span class="boring">}</span></code></pre></pre>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h3>
<ul>
<li><strong>Original code never changes</strong> â†’ No bugs introduced</li>
<li><strong>Easy to test</strong> â†’ Test each layer separately</li>
<li><strong>Composable</strong> â†’ Mix and match features</li>
<li><strong>Reversible</strong> â†’ Remove a layer anytime</li>
</ul>
<h3 id="checkpoint-question-6"><a class="header" href="#checkpoint-question-6">Checkpoint Question</a></h3>
<p>You need to add timeout handling to a database connection.</p>
<p><strong>Using the Extension Layer pattern, how would you do it?</strong></p>
<p>Answer: Create a <code>TimeoutConnection</code> wrapper that wraps the original <code>Connection</code>.</p>
<hr />
<h2 id="part-3-composition-over-duplication-12-minutes"><a class="header" href="#part-3-composition-over-duplication-12-minutes">Part 3: Composition Over Duplication (12 minutes)</a></h2>
<p><strong>Goal</strong>: Use composition instead of copying code</p>
<h3 id="the-problem-copy-paste-duplication"><a class="header" href="#the-problem-copy-paste-duplication">The Problem: Copy-Paste Duplication</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Copy-pasting code
struct Logger {
    buffer: Vec&lt;String&gt;,
}

impl Logger {
    fn log(&amp;mut self, msg: &amp;str) {
        self.buffer.push(msg.to_string());
    }
}

struct FileWriter {
    buffer: Vec&lt;String&gt;,  // DUPLICATE: Same buffer
    path: String,
}

impl FileWriter {
    fn write(&amp;mut self, data: &amp;str) {
        self.buffer.push(data.to_string());  // DUPLICATE: Same logic
    }
}

// Now you need to fix a bug in the buffer logic...
// You have to fix it in TWO places! ğŸ˜
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-composition"><a class="header" href="#the-solution-composition">The Solution: Composition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Create a shared component
pub struct StringBuffer {
    data: Vec&lt;String&gt;,
}

impl StringBuffer {
    fn append(&amp;mut self, s: &amp;str) {
        self.data.push(s.to_string());
    }
}

// Compose it into both
struct Logger {
    buffer: StringBuffer,
}

struct FileWriter {
    buffer: StringBuffer,  // Same component
    path: String,
}

// Now: Fix bug in StringBuffer once, both are fixed! âœ…
<span class="boring">}</span></code></pre></pre>
<h3 id="composition-vs-inheritance"><a class="header" href="#composition-vs-inheritance">Composition vs. Inheritance</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Composition</th><th>Inheritance</th></tr></thead><tbody>
<tr><td><strong>Reusability</strong></td><td>âœ… Mix and match</td><td>âŒ Rigid hierarchy</td></tr>
<tr><td><strong>Maintainability</strong></td><td>âœ… Changes in one place</td><td>âŒ Changes everywhere</td></tr>
<tr><td><strong>Flexibility</strong></td><td>âœ… Swap parts easily</td><td>âŒ Can't swap</td></tr>
<tr><td><strong>Testability</strong></td><td>âœ… Test component alone</td><td>âŒ Test whole tree</td></tr>
</tbody></table>
</div>
<p><strong>Rule of thumb</strong>: If you're copy-pasting code, use composition instead.</p>
<h3 id="checkpoint-question-7"><a class="header" href="#checkpoint-question-7">Checkpoint Question</a></h3>
<p>You have <code>JsonParser</code> and <code>XmlParser</code> with 50 lines of duplicate validation code.</p>
<p><strong>What should you do?</strong></p>
<p>Answer: Extract a <code>Validator</code> component and use it in both.</p>
<hr />
<h2 id="part-4-single-source-of-truth-12-minutes"><a class="header" href="#part-4-single-source-of-truth-12-minutes">Part 4: Single Source of Truth (12 minutes)</a></h2>
<p><strong>Goal</strong>: Keep data consistent by having one canonical source</p>
<h3 id="the-problem-data-inconsistency"><a class="header" href="#the-problem-data-inconsistency">The Problem: Data Inconsistency</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Multiple copies of the same data
struct UserCache {
    users: HashMap&lt;u32, User&gt;,  // Copy of database
}

struct UserService {
    cache: UserCache,
    database: Database,  // Original
}

// Update database
service.database.update_user(123, new_data)?;

// Oops! Cache is now stale
// service.cache.users[&amp;123] is out of date!

// Different code paths get different data ğŸ˜
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-one-source-of-truth"><a class="header" href="#the-solution-one-source-of-truth">The Solution: One Source of Truth</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Truth in one place
struct UserService {
    database: Database,  // Only source of truth
}

// Cache is derived from database
fn get_user(&amp;self, id: u32) -&gt; Result&lt;User&gt; {
    // Get from database (single source)
    self.database.fetch(id)
}

// Update
fn update_user(&amp;mut self, id: u32, data: UserUpdate) -&gt; Result&lt;()&gt; {
    // Update only the source
    self.database.update(id, data)
}

// Always consistent! âœ…
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-apply"><a class="header" href="#when-to-apply">When to Apply</a></h3>
<p>âœ… <strong>Apply when</strong>: Data appears in multiple places
âœ… <strong>Apply when</strong>: Synchronization is complex
âœ… <strong>Apply when</strong>: Consistency matters (payment systems, authorization, etc.)</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Domain</th><th>Truth</th><th>Derived</th></tr></thead><tbody>
<tr><td><strong>E-commerce</strong></td><td>Database (orders)</td><td>Cache, indices, reports</td></tr>
<tr><td><strong>Auth</strong></td><td>Database (permissions)</td><td>Session tokens, caches</td></tr>
<tr><td><strong>Analytics</strong></td><td>Raw events</td><td>Aggregations, reports</td></tr>
</tbody></table>
</div>
<h3 id="checkpoint-question-8"><a class="header" href="#checkpoint-question-8">Checkpoint Question</a></h3>
<p>You have user data in both database and cache.</p>
<p><strong>Which is the single source of truth?</strong></p>
<p>Answer: Database. Cache is derived/cached from it. Update database first, invalidate cache.</p>
<hr />
<h2 id="part-5-capability-grouping-9-minutes"><a class="header" href="#part-5-capability-grouping-9-minutes">Part 5: Capability Grouping (9 minutes)</a></h2>
<p><strong>Goal</strong>: Organize large modules by capability, not by type</p>
<h3 id="the-problem-type-based-organization"><a class="header" href="#the-problem-type-based-organization">The Problem: Type-Based Organization</a></h3>
<pre><code>project/
â”œâ”€â”€ models/          # All data types
â”‚   â”œâ”€â”€ user.rs
â”‚   â”œâ”€â”€ order.rs
â”‚   â””â”€â”€ payment.rs
â”œâ”€â”€ handlers/        # All HTTP handlers
â”‚   â”œâ”€â”€ user_handler.rs
â”‚   â”œâ”€â”€ order_handler.rs
â”‚   â””â”€â”€ payment_handler.rs
â”œâ”€â”€ persistence/     # All database code
â”‚   â”œâ”€â”€ user_repo.rs
â”‚   â”œâ”€â”€ order_repo.rs
â”‚   â””â”€â”€ payment_repo.rs

// âŒ To understand "user" feature, you jump between 4 files!
// âŒ Each file is small but scattered
// âŒ Hard to find related code
</code></pre>
<h3 id="the-solution-capability-based-organization"><a class="header" href="#the-solution-capability-based-organization">The Solution: Capability-Based Organization</a></h3>
<pre><code>project/
â”œâ”€â”€ users/               # Everything for users
â”‚   â”œâ”€â”€ model.rs
â”‚   â”œâ”€â”€ handler.rs
â”‚   â”œâ”€â”€ repository.rs
â”‚   â””â”€â”€ tests.rs
â”œâ”€â”€ orders/              # Everything for orders
â”‚   â”œâ”€â”€ model.rs
â”‚   â”œâ”€â”€ handler.rs
â”‚   â”œâ”€â”€ repository.rs
â”‚   â””â”€â”€ tests.rs
â”œâ”€â”€ payments/            # Everything for payments
â”‚   â”œâ”€â”€ model.rs
â”‚   â”œâ”€â”€ handler.rs
â”‚   â”œâ”€â”€ repository.rs
â”‚   â””â”€â”€ tests.rs

// âœ… To understand "users", all code is in `users/`!
// âœ… Related code is together
// âœ… Easy to find dependencies
</code></pre>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<ul>
<li><strong>Cohesion</strong>: Related code together</li>
<li><strong>Discoverability</strong>: Find code easily</li>
<li><strong>Modularity</strong>: Move features together</li>
<li><strong>Testability</strong>: Test capability in one place</li>
</ul>
<h3 id="checkpoint-question-9"><a class="header" href="#checkpoint-question-9">Checkpoint Question</a></h3>
<p>Your project has <code>models/</code>, <code>handlers/</code>, and <code>db/</code> directories.</p>
<p><strong>How would you reorganize for better capability grouping?</strong></p>
<p>Answer: Create <code>users/</code>, <code>orders/</code>, <code>products/</code> directories, each containing models, handlers, and db code.</p>
<hr />
<h2 id="putting-it-together-complete-exercise-15-minutes"><a class="header" href="#putting-it-together-complete-exercise-15-minutes">Putting It Together: Complete Exercise (15 minutes)</a></h2>
<h3 id="exercise-building-an-order-processing-system"><a class="header" href="#exercise-building-an-order-processing-system">Exercise: Building an Order Processing System</a></h3>
<p>You're building an order system with these requirements:</p>
<ol>
<li>Accept orders</li>
<li>Store them in database</li>
<li>Can switch between PostgreSQL and SQLite</li>
<li>Add logging without modifying core code</li>
<li>Keep inventory count accurate</li>
<li>Organize code clearly</li>
</ol>
<h3 id="design-using-all-5-patterns"><a class="header" href="#design-using-all-5-patterns">Design Using All 5 Patterns</a></h3>
<p><strong>Pattern 6 (Generic Base)</strong>: Create <code>Storage</code> trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait OrderStorage {
    fn save(&amp;mut self, order: &amp;Order) -&gt; Result&lt;()&gt;;
    fn get(&amp;self, id: u32) -&gt; Result&lt;Order&gt;;
}

// Both implementations
struct PostgresStorage { ... }
struct SqliteStorage { ... }
<span class="boring">}</span></code></pre></pre>
<p><strong>Pattern 7 (Extension Layer)</strong>: Add logging</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LoggingStorage {
    inner: Box&lt;dyn OrderStorage&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Pattern 8 (Composition)</strong>: Shared validation</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OrderValidator { ... }
struct Order Service {
    storage: Box&lt;dyn OrderStorage&gt;,
    validator: OrderValidator,  // Composed
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Pattern 9 (Single Source)</strong>: Inventory truth</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InventoryService {
    database: Database,  // Single source
    // NOT: inventory_cache
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Pattern 10 (Capability)</strong>: Organize by feature</p>
<pre><code>order_service/
â”œâ”€â”€ model.rs
â”œâ”€â”€ handler.rs
â”œâ”€â”€ storage.rs
â”œâ”€â”€ validator.rs
â””â”€â”€ tests.rs
</code></pre>
<hr />
<h2 id="summary-the-5-architecture-patterns"><a class="header" href="#summary-the-5-architecture-patterns">Summary: The 5 Architecture Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Problem</th><th>Solution</th></tr></thead><tbody>
<tr><td><strong>6: Generic Base</strong></td><td>Duplication</td><td>Traits and abstraction</td></tr>
<tr><td><strong>7: Extension Layer</strong></td><td>Modification</td><td>Wrapping instead of changing</td></tr>
<tr><td><strong>8: Composition</strong></td><td>Copy-paste</td><td>Share components</td></tr>
<tr><td><strong>9: Single Source</strong></td><td>Inconsistency</td><td>One source of truth</td></tr>
<tr><td><strong>10: Capability</strong></td><td>Disorganization</td><td>Group by feature</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<h3 id="apply-these-patterns"><a class="header" href="#apply-these-patterns">Apply These Patterns</a></h3>
<p>Choose one pattern and apply it to your current project this week.</p>
<h3 id="learn-design-patterns"><a class="header" href="#learn-design-patterns">Learn Design Patterns</a></h3>
<p>Once you master architecture, learn <a href="tutorials/learning-design-patterns.html">Design Patterns</a> for type safety and optimization.</p>
<hr />
<h2 id="checkpoint-do-you-know-1"><a class="header" href="#checkpoint-do-you-know-1">Checkpoint: Do You Know...?</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
How to use traits to eliminate duplication?</li>
<li><input disabled="" type="checkbox"/>
How to extend code without modifying it?</li>
<li><input disabled="" type="checkbox"/>
When to use composition over inheritance?</li>
<li><input disabled="" type="checkbox"/>
How to keep data consistent?</li>
<li><input disabled="" type="checkbox"/>
How to organize code by capability?</li>
</ul>
<p>If yes to all, you've mastered Architecture Patterns! ğŸ‰</p>
<hr />
<p><strong>Congratulations!</strong> You now understand how to organize production code. Next, master type safety and design with Design Patterns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-design-patterns-120-minute-mastery"><a class="header" href="#learning-design-patterns-120-minute-mastery">Learning Design Patterns: 120-Minute Mastery</a></h1>
<blockquote>
<p>ğŸ“ <strong>TUTORIAL</strong> | Master the 10 advanced design patterns</p>
</blockquote>
<p>This tutorial guides you through the 10 design patterns that create safe, fast, maintainable systems.</p>
<p><strong>Time</strong>: ~120 minutes | <strong>Difficulty</strong>: Advanced | <strong>Prerequisites</strong>: <a href="tutorials/learning-testing-patterns.html">Testing</a> + <a href="tutorials/learning-architecture-patterns.html">Architecture</a></p>
<hr />
<h2 id="module-overview-2"><a class="header" href="#module-overview-2">Module Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Time</th><th>Focus</th></tr></thead><tbody>
<tr><td>Pattern 11: Zero-Cost Abstractions</td><td>12 min</td><td>Performance without sacrifice</td></tr>
<tr><td>Pattern 12: Type Safety with GATs</td><td>12 min</td><td>Lifetimes and type safety</td></tr>
<tr><td>Pattern 13: Sealed Traits</td><td>10 min</td><td>Prevent API misuse</td></tr>
<tr><td>Pattern 14: Compile-Time Validation</td><td>12 min</td><td>Move errors left</td></tr>
<tr><td>Pattern 15: Type State Enforcement</td><td>12 min</td><td>Encode state in types</td></tr>
<tr><td>Pattern 16: Fixture Lifecycle</td><td>12 min</td><td>Safe resource management</td></tr>
<tr><td>Pattern 17: Builder-Driven Test Data</td><td>12 min</td><td>Fluent test builders</td></tr>
<tr><td>Pattern 18: Timeout Defense</td><td>12 min</td><td>Prevent hangs</td></tr>
<tr><td>Pattern 19: Feature Gate Slices</td><td>12 min</td><td>Reliable feature flags</td></tr>
<tr><td>Pattern 20: Macro Pattern Enforcement</td><td>12 min</td><td>Enforce patterns with code</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="part-1-zero-cost-abstractions-12-minutes"><a class="header" href="#part-1-zero-cost-abstractions-12-minutes">Part 1: Zero-Cost Abstractions (12 minutes)</a></h2>
<p><strong>Goal</strong>: Performance through generics and compile-time specialization</p>
<h3 id="the-problem-abstraction-vs-performance"><a class="header" href="#the-problem-abstraction-vs-performance">The Problem: Abstraction vs. Performance</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Abstraction adds runtime cost
fn process_data(data: &amp;dyn Iterator&lt;Item = i32&gt;) {
    // Dynamic dispatch = function pointers = overhead
    for item in data {
        // ...
    }
}

// Result: Slower than necessary
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-generics--zero-cost"><a class="header" href="#the-solution-generics--zero-cost">The Solution: Generics = Zero Cost</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Generic = compile specialization
fn process_data&lt;I: Iterator&lt;Item = i32&gt;&gt;(data: I) {
    // Compiler generates specialized code for EACH type
    // No function pointers, no indirection
    for item in data {
        // ...
    }
}

// Rust compiles:
// - process_data::&lt;Vec&lt;i32&gt;::IntoIter&gt;
// - process_data::&lt;ArrayIter&gt;
// - process_data::&lt;CustomIterator&gt;
// Each one optimized for its type!
<span class="boring">}</span></code></pre></pre>
<h3 id="key-principle"><a class="header" href="#key-principle">Key Principle</a></h3>
<p>Rust compiler can <strong>monomorphize</strong> generics - it creates specialized versions for each type. This costs compilation time but <strong>zero runtime cost</strong>.</p>
<h3 id="when-to-use-generics-vs-trait-objects"><a class="header" href="#when-to-use-generics-vs-trait-objects">When to Use Generics vs. Trait Objects</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Choice</th><th>Cost</th><th>Use When</th></tr></thead><tbody>
<tr><td><strong>Generics</strong></td><td>Compile-time</td><td>Size known, type fixed</td></tr>
<tr><td><strong>Trait objects</strong></td><td>Runtime</td><td>Size unknown, type varies</td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Generics - no runtime cost
fn sort&lt;T: Ord&gt;(list: &amp;mut [T]) { ... }

// âœ… Trait objects - when you need dynamic dispatch
fn apply_filter(items: &amp;[i32], filter: &amp;dyn Fn(i32) -&gt; bool) { ... }
<span class="boring">}</span></code></pre></pre>
<h3 id="checkpoint-question-10"><a class="header" href="#checkpoint-question-10">Checkpoint Question</a></h3>
<p>You have a function that processes different collection types.</p>
<p><strong>Should you use generics or trait objects?</strong></p>
<p>Answer: <strong>Generics</strong>. Let compiler specialize for each type.</p>
<hr />
<h2 id="part-2-type-safety-with-gats-12-minutes"><a class="header" href="#part-2-type-safety-with-gats-12-minutes">Part 2: Type Safety with GATs (12 minutes)</a></h2>
<p><strong>Goal</strong>: Use Generic Associated Types to prevent lifetime bugs</p>
<h3 id="the-problem-complex-lifetimes"><a class="header" href="#the-problem-complex-lifetimes">The Problem: Complex Lifetimes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Lifetime issues with references
trait DataProvider {
    fn get(&amp;self) -&gt; &amp;str;
}

// Can this reference outlive the provider?
// The compiler can't tell!
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-gats"><a class="header" href="#the-solution-gats">The Solution: GATs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… GATs bind lifetime to self
trait DataProvider {
    type Data&lt;'a&gt; where Self: 'a;

    fn get(&amp;'a self) -&gt; Self::Data&lt;'a&gt;;
}

// Now compiler KNOWS: returned data is tied to self's lifetime
<span class="boring">}</span></code></pre></pre>
<h3 id="why-this-matters-1"><a class="header" href="#why-this-matters-1">Why This Matters</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// With GATs, this is impossible:
fn use_provider(provider: &amp;Provider) {
    let data = provider.get();
    drop(provider);  // âŒ Compiler error!
    println!("{:?}", data);  // data would be dangling
}

// Without GATs, it might compile (dangerous!)
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-gats"><a class="header" href="#when-to-use-gats">When to Use GATs</a></h3>
<p>âœ… <strong>Use when</strong>: Returning references from traits
âœ… <strong>Use when</strong>: Fixture providers with borrowed data
âœ… <strong>Use when</strong>: APIs that care about lifetimes</p>
<h3 id="checkpoint-question-11"><a class="header" href="#checkpoint-question-11">Checkpoint Question</a></h3>
<p>You have a trait that returns a reference to internal data.</p>
<p><strong>How do you ensure it can't outlive the source?</strong></p>
<p>Answer: Use GATs to bind the returned reference lifetime to <code>self</code>.</p>
<hr />
<h2 id="part-3-sealed-traits-10-minutes"><a class="header" href="#part-3-sealed-traits-10-minutes">Part 3: Sealed Traits (10 minutes)</a></h2>
<p><strong>Goal</strong>: Prevent external implementations of your traits</p>
<h3 id="the-problem-api-misuse"><a class="header" href="#the-problem-api-misuse">The Problem: API Misuse</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Public trait - anyone can implement!
pub trait Serializable {
    fn serialize(&amp;self) -&gt; String;
}

// External code implements it wrongly:
impl Serializable for String {
    fn serialize(&amp;self) -&gt; String {
        "nope".to_string()  // Wrong!
    }
}

// Your code breaks!
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-sealed-traits"><a class="header" href="#the-solution-sealed-traits">The Solution: Sealed Traits</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Private sealing module
mod sealed {
    pub trait Sealed {}
}

pub trait Serializable: sealed::Sealed {
    fn serialize(&amp;self) -&gt; String;
}

// Only WE can implement Sealed
impl sealed::Sealed for MyType {}
impl Serializable for MyType { ... }

// External code CANNOT implement Serializable
// because they can't implement sealed::Sealed!
<span class="boring">}</span></code></pre></pre>
<h3 id="why-this-matters-2"><a class="header" href="#why-this-matters-2">Why This Matters</a></h3>
<ul>
<li><strong>Prevents misuse</strong> â†’ Forced to use correct implementations</li>
<li><strong>API evolution</strong> â†’ Can change internals safely</li>
<li><strong>Documentation</strong> â†’ Readers know this is sealed</li>
</ul>
<h3 id="pattern"><a class="header" href="#pattern">Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod sealed {
    pub trait Sealed {}
}

pub trait PublicTrait: sealed::Sealed {
    fn public_method(&amp;self);
}

// Only internal types can implement
pub struct InternalType;
impl sealed::Sealed for InternalType {}
impl PublicTrait for InternalType { ... }
<span class="boring">}</span></code></pre></pre>
<h3 id="checkpoint-question-12"><a class="header" href="#checkpoint-question-12">Checkpoint Question</a></h3>
<p>You have an important trait that must have specific implementations.</p>
<p><strong>How do you prevent user code from breaking it?</strong></p>
<p>Answer: Seal the trait so only your code can implement it.</p>
<hr />
<h2 id="part-4-compile-time-validation-12-minutes"><a class="header" href="#part-4-compile-time-validation-12-minutes">Part 4: Compile-Time Validation (12 minutes)</a></h2>
<p><strong>Goal</strong>: Catch errors during compilation, not at runtime</p>
<h3 id="the-problem-runtime-errors"><a class="header" href="#the-problem-runtime-errors">The Problem: Runtime Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Errors at runtime
fn process(config: &amp;str) -&gt; Result&lt;Data, Error&gt; {
    let parsed = parse_config(config)?;  // Might fail at runtime
    validate_config(parsed)?;  // Another runtime check
    Ok(build_data(parsed))
}

// Errors are found after deployment ğŸ˜
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-phantom-types"><a class="header" href="#the-solution-phantom-types">The Solution: Phantom Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Errors at compile time
struct Config&lt;S&gt; {
    data: String,
    _state: PhantomData&lt;S&gt;,
}

// Parsing: Raw â†’ Parsed
impl Config&lt;Raw&gt; {
    fn parse(s: &amp;str) -&gt; Result&lt;Config&lt;Parsed&gt;, Error&gt; {
        let data = validate(s)?;
        Ok(Config { data, _state: PhantomData })
    }
}

// Building: Only works with Parsed
impl Config&lt;Parsed&gt; {
    fn build(self) -&gt; Data {
        // Can only call this on Parsed, never Raw
        Data::new(&amp;self.data)
    }
}

// âœ… This is impossible:
let raw = Config::&lt;Raw&gt;::from("config");
raw.build();  // âŒ Compiler error! Use .parse() first
<span class="boring">}</span></code></pre></pre>
<h3 id="key-idea"><a class="header" href="#key-idea">Key Idea</a></h3>
<p><strong>Encode requirements in types</strong>. Make it impossible to violate at compile-time.</p>
<h3 id="common-examples"><a class="header" href="#common-examples">Common Examples</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Types</th><th>Purpose</th></tr></thead><tbody>
<tr><td><strong>Builder pattern</strong></td><td>Raw â†’ Built</td><td>Ensure all fields set</td></tr>
<tr><td><strong>State machines</strong></td><td>Idle â†’ Running</td><td>Prevent invalid operations</td></tr>
<tr><td><strong>Type tokens</strong></td><td>Foo&lt;_&gt; with phantom</td><td>Track type information</td></tr>
</tbody></table>
</div>
<h3 id="checkpoint-question-13"><a class="header" href="#checkpoint-question-13">Checkpoint Question</a></h3>
<p>You have an API that requires:</p>
<ol>
<li>Initialize</li>
<li>Configure</li>
<li>Start</li>
</ol>
<p><strong>How do you prevent wrong order?</strong></p>
<p>Answer: Use phantom types to track state:</p>
<ul>
<li><code>Service&lt;Uninitialized&gt;</code> â†’ <code>.init()</code> â†’ <code>Service&lt;Initialized&gt;</code></li>
<li><code>Service&lt;Initialized&gt;</code> â†’ <code>.configure()</code> â†’ <code>Service&lt;Configured&gt;</code></li>
<li><code>Service&lt;Configured&gt;</code> â†’ <code>.start()</code> â†’ <code>Service&lt;Running&gt;</code></li>
</ul>
<hr />
<h2 id="part-5-type-state-enforcement-12-minutes"><a class="header" href="#part-5-type-state-enforcement-12-minutes">Part 5: Type State Enforcement (12 minutes)</a></h2>
<p><strong>Goal</strong>: Use the type system to enforce valid state transitions</p>
<h3 id="the-problem-invalid-states"><a class="header" href="#the-problem-invalid-states">The Problem: Invalid States</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ Can access before initialization
struct Connection {
    socket: Option&lt;Socket&gt;,  // None until connected
}

impl Connection {
    fn send(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;()&gt; {
        match self.socket {
            Some(ref mut s) =&gt; s.write(data),
            None =&gt; Err("Not connected"),  // Runtime error!
        }
    }
}

// Code can call send() before connect() - runtime error!
<span class="boring">}</span></code></pre></pre>
<h3 id="the-solution-type-state"><a class="header" href="#the-solution-type-state">The Solution: Type State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âœ… Types enforce state
struct Connection&lt;State&gt; { ... }

// States
pub struct Disconnected;
pub struct Connected;

// Only Disconnected can connect
impl Connection&lt;Disconnected&gt; {
    fn connect(mut self, addr: &amp;str) -&gt; Result&lt;Connection&lt;Connected&gt;&gt; {
        self.socket = Some(Socket::new(addr)?);
        Ok(Connection { ... })
    }
}

// Only Connected can send
impl Connection&lt;Connected&gt; {
    fn send(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;()&gt; {
        self.socket.write(data)?;  // socket is guaranteed Some
        Ok(())
    }
}

// âœ… Impossible to call send() before connect():
let conn = Connection::new();  // Disconnected
conn.send(b"data")?;  // âŒ Compiler error!

let conn = conn.connect("127.0.0.1")?;  // Now Connected
conn.send(b"data")?;  // âœ… Allowed!
<span class="boring">}</span></code></pre></pre>
<h3 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h3>
<ul>
<li><strong>Compile-time safety</strong> â†’ No panics from invalid states</li>
<li><strong>No runtime checks</strong> â†’ No Option/Result overhead</li>
<li><strong>Clear API</strong> â†’ Code documents valid transitions</li>
<li><strong>Impossible states</strong> â†’ Some states just can't happen</li>
</ul>
<h3 id="checkpoint-question-14"><a class="header" href="#checkpoint-question-14">Checkpoint Question</a></h3>
<p>You have a database transaction that must:</p>
<ol>
<li>Begin</li>
<li>Execute</li>
<li>Commit/Rollback</li>
</ol>
<p><strong>How do you prevent calling Commit before Begin?</strong></p>
<p>Answer: Use type states:</p>
<ul>
<li><code>Tx&lt;NotStarted&gt;</code> â†’ <code>.begin()</code> â†’ <code>Tx&lt;Started&gt;</code></li>
<li><code>Tx&lt;Started&gt;</code> â†’ <code>.commit()</code> â†’ <code>Tx&lt;Finished&gt;</code></li>
</ul>
<hr />
<h2 id="part-6-10-summary-of-advanced-patterns"><a class="header" href="#part-6-10-summary-of-advanced-patterns">Part 6-10: Summary of Advanced Patterns</a></h2>
<p>The remaining 5 patterns build on what you've learned:</p>
<div class="table-wrapper"><table><thead><tr><th>#</th><th>Pattern</th><th>What It Does</th></tr></thead><tbody>
<tr><td>16</td><td><strong>Fixture Lifecycle</strong></td><td>Manage resources with sealed traits (combines patterns 13+2)</td></tr>
<tr><td>17</td><td><strong>Builder Test Data</strong></td><td>Fluent builders for test setup (applies compilation validation)</td></tr>
<tr><td>18</td><td><strong>Timeout Defense</strong></td><td>Multiple timeout strategies (zero-cost + compile-time)</td></tr>
<tr><td>19</td><td><strong>Feature Gates</strong></td><td>Type-safe feature flags (type state + sealed traits)</td></tr>
<tr><td>20</td><td><strong>Macro Enforcement</strong></td><td>Compile-time pattern checks via macros (ultimate compile-time validation)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="putting-it-together-complete-design"><a class="header" href="#putting-it-together-complete-design">Putting It Together: Complete Design</a></h2>
<h3 id="exercise-build-a-safe-transaction-system"><a class="header" href="#exercise-build-a-safe-transaction-system">Exercise: Build a Safe Transaction System</a></h3>
<p>Requirements:</p>
<ol>
<li>Transactions must go: Begin â†’ Execute â†’ Commit</li>
<li>Can't add statements after commit</li>
<li>Type-safe with zero runtime overhead</li>
<li>Can't be misused by users</li>
<li>Test data builder for testing</li>
</ol>
<h3 id="solution-using-all-patterns"><a class="header" href="#solution-using-all-patterns">Solution Using All Patterns</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pattern 15 + 14: Type state
pub struct Transaction&lt;State&gt; {
    id: u32,
    statements: Vec&lt;String&gt;,
    _state: PhantomData&lt;State&gt;,
}

pub struct NotStarted;
pub struct Started;
pub struct Committed;

// Pattern 14 + 15: Compile-time validation
impl Transaction&lt;NotStarted&gt; {
    pub fn begin() -&gt; Transaction&lt;Started&gt; {
        Transaction { ... }
    }
}

impl Transaction&lt;Started&gt; {
    pub fn add_statement(&amp;mut self, sql: &amp;str) -&gt; Result&lt;()&gt; {
        self.statements.push(sql.to_string());
        Ok(())
    }

    pub fn commit(self) -&gt; Transaction&lt;Committed&gt; {
        // Execute all statements
        Transaction { ... }
    }
}

// Pattern 13: Sealed to prevent misuse
mod sealed {
    pub trait Sealed {}
}

pub trait TransactionOps: sealed::Sealed {
    fn execute(&amp;self) -&gt; Result&lt;()&gt;;
}

impl sealed::Sealed for Transaction&lt;Started&gt; {}
impl TransactionOps for Transaction&lt;Started&gt; {
    fn execute(&amp;self) -&gt; Result&lt;()&gt; { ... }
}

// Pattern 17: Builder for tests
pub struct TransactionBuilder {
    statements: Vec&lt;String&gt;,
}

impl TransactionBuilder {
    pub fn new() -&gt; Self { ... }
    pub fn add(mut self, sql: &amp;str) -&gt; Self {
        self.statements.push(sql.to_string());
        self
    }
    pub fn build(self) -&gt; Transaction&lt;Started&gt; { ... }
}

// âœ… Usage is type-safe:
let mut tx = Transaction::begin();
tx.add_statement("INSERT ...")?;
let tx = tx.commit();  // Type changes to Committed

// âŒ Impossible:
let tx = Transaction::begin();
let tx = tx.commit();
tx.add_statement("SELECT");  // âŒ Compiler error! tx is Committed
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-the-10-design-patterns"><a class="header" href="#summary-the-10-design-patterns">Summary: The 10 Design Patterns</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Pattern</th><th>Goal</th><th>Mechanism</th></tr></thead><tbody>
<tr><td>11</td><td>Zero-cost</td><td>Generics + monomorphization</td></tr>
<tr><td>12</td><td>Lifetimes</td><td>GATs (Generic Associated Types)</td></tr>
<tr><td>13</td><td>API safety</td><td>Sealed traits</td></tr>
<tr><td>14</td><td>Validation</td><td>Phantom types + state</td></tr>
<tr><td>15</td><td>State machines</td><td>Type states</td></tr>
<tr><td>16</td><td>Resources</td><td>Lifecycle traits</td></tr>
<tr><td>17</td><td>Test data</td><td>Fluent builders</td></tr>
<tr><td>18</td><td>Robustness</td><td>Timeout strategies</td></tr>
<tr><td>19</td><td>Features</td><td>Type-safe gates</td></tr>
<tr><td>20</td><td>Enforcement</td><td>Procedural macros</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<h3 id="master-one-pattern-per-week"><a class="header" href="#master-one-pattern-per-week">Master One Pattern Per Week</a></h3>
<ol>
<li><strong>Week 1</strong>: Zero-Cost &amp; GATs</li>
<li><strong>Week 2</strong>: Sealed &amp; Compile-Time</li>
<li><strong>Week 3</strong>: Type State &amp; Lifecycle</li>
<li><strong>Week 4</strong>: Builder, Timeout, Features, Macros</li>
</ol>
<h3 id="apply-to-your-project"><a class="header" href="#apply-to-your-project">Apply to Your Project</a></h3>
<p>Choose the top 3 patterns that would improve your code safety and refactor this month.</p>
<hr />
<h2 id="checkpoint-do-you-know-2"><a class="header" href="#checkpoint-do-you-know-2">Checkpoint: Do You Know...?</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
How generics create zero-cost abstractions?</li>
<li><input disabled="" type="checkbox"/>
When to use GATs for lifetime safety?</li>
<li><input disabled="" type="checkbox"/>
How sealed traits prevent API misuse?</li>
<li><input disabled="" type="checkbox"/>
How to encode validation in types?</li>
<li><input disabled="" type="checkbox"/>
How type states prevent invalid operations?</li>
<li><input disabled="" type="checkbox"/>
How to manage resource lifecycles?</li>
<li><input disabled="" type="checkbox"/>
How builders simplify test setup?</li>
<li><input disabled="" type="checkbox"/>
Why timeouts matter?</li>
<li><input disabled="" type="checkbox"/>
How to implement type-safe features?</li>
<li><input disabled="" type="checkbox"/>
When to use macros for enforcement?</li>
</ul>
<p>If yes to most, you've mastered Design Patterns! ğŸ‰</p>
<hr />
<p><strong>Congratulations!</strong> You now understand the complete pattern language of Chicago TDD Tools.</p>
<h2 id="final-advice"><a class="header" href="#final-advice">Final Advice</a></h2>
<p>These patterns work together:</p>
<ul>
<li><strong>Testing patterns</strong> help you verify code works</li>
<li><strong>Architecture patterns</strong> help you organize code</li>
<li><strong>Design patterns</strong> help you prevent bugs at compile-time</li>
</ul>
<p>Master them all, and you'll write code that's:
âœ… Tested thoroughly
âœ… Well-organized
âœ… Type-safe
âœ… High-performance
âœ… Hard to misuse</p>
<p>That's the Chicago TDD difference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-patterns"><a class="header" href="#testing-patterns">Testing Patterns</a></h1>
<p>Tests are executable specifications. The Chicago TDD Tools testing patterns capture how to write fast, trustworthy, and expressive tests that verify observable behavior. Each pattern layers on the previous ones; together they reflect the AAA mindset, the insistence on real collaborators, and the bias toward fast failure.</p>
<p>Use these patterns when a test feels brittle, slow, or unclear. The language highlights which macro to reach for, how to structure the test body, and how to keep failures meaningful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-1-aaa-pattern"><a class="header" href="#pattern-1-aaa-pattern">Pattern 1: AAA Pattern</a></h1>
<blockquote>
<p>ğŸ”§ <strong>HOW-TO</strong> | Structure every test with Arrange-Act-Assert clarity</p>
</blockquote>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>Details</th></tr></thead><tbody>
<tr><td><strong>Problem Solved</strong></td><td>Tests that intermingle setup, behavior, and assertions become hard to read and debug</td></tr>
<tr><td><strong>Core Solution</strong></td><td>Divide test into three explicit phases: Arrange, Act, Assert</td></tr>
<tr><td><strong>When to Use</strong></td><td>âœ… All unit tests, âœ… Integration tests, âœ… Even simple assertions</td></tr>
<tr><td><strong>When NOT to Use</strong></td><td>âŒ Property-based tests (different structure), âŒ Complex multi-stage workflows (use fixtures)</td></tr>
<tr><td><strong>Difficulty</strong></td><td>Low - Easy to learn and apply immediately</td></tr>
<tr><td><strong>Trade-offs</strong></td><td>Slight verbosity for clarity</td></tr>
<tr><td><strong>Related Patterns</strong></td><td>Error Path Testing, Real Collaborators, Fixture Lifecycle</td></tr>
</tbody></table>
</div>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>You are writing or reviewing a test in Chicago TDD Tools. You want the test to communicate intent instantly and fail with a precise message when behavior regresses.</p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>Tests that intermingle setup, behavior, and assertions become hard to scan. When the failure occurs, teammates must untangle implicit state, which slows feedback and hides missing assertions.</p>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>Structure every test body into three explicit phases â€“ <strong>Arrange</strong>, <strong>Act</strong>, <strong>Assert</strong> â€“ and let the framework enforce it. Use the <code>test!</code>, <code>async_test!</code>, or <code>fixture_test!</code> macros so that comments and code read in a top-to-bottom narrative.</p>
<h2 id="forces"><a class="header" href="#forces">Forces</a></h2>
<ul>
<li>Readability vs. flexibility: expressive labels without duplicating boilerplate</li>
<li>Fast diagnosis vs. runtime overhead: compile-time enforcement should cost nothing</li>
<li>Behavior proof vs. implementation detail: assertions must verify observable outcomes</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="basic-example-simple-calculation"><a class="header" href="#basic-example-simple-calculation">Basic Example: Simple Calculation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

test!(test_scaling_multiplier, {
    // Arrange: Set up test data
    let multiplier = 3;
    let input = 7;

    // Act: Execute the behavior
    let result = multiplier * input;

    // Assert: Verify the result
    assert_eq!(result, 21, "multiplier should scale the input");
});
<span class="boring">}</span></code></pre></pre>
<h3 id="async-example-fetching-data"><a class="header" href="#async-example-fetching-data">Async Example: Fetching Data</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;

async_test!(test_fetch_customer, {
    // Arrange: Set up dependencies
    let client = FakeCrmClient::connected();

    // Act: Perform async operation
    let customer = client.fetch("cust-123").await?;

    // Assert: Verify outcome
    assert_eq!(customer.id, "cust-123");
    Ok(())
});
<span class="boring">}</span></code></pre></pre>
<h3 id="with-fixtures-complex-setup"><a class="header" href="#with-fixtures-complex-setup">With Fixtures: Complex Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::fixture::*;

fixture_test!(test_user_creation, fixture, {
    // Arrange: Create fixture and prepare state
    fixture.set_metadata("user_type", "admin");
    let db = fixture.database();

    // Act: Execute business logic
    let user = db.create_user("alice", "admin")?;

    // Assert: Verify the result
    assert_eq!(user.name, "alice");
    assert_eq!(user.role, "admin");
});
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-checklist"><a class="header" href="#implementation-checklist">Implementation Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>Arrange phase</strong> clearly sets up all necessary test data</li>
<li><input disabled="" type="checkbox"/>
<strong>Act phase</strong> calls the function or method exactly once</li>
<li><input disabled="" type="checkbox"/>
<strong>Assert phase</strong> verifies the result with specific assertions</li>
<li><input disabled="" type="checkbox"/>
Comments label each phase (even if obvious)</li>
<li><input disabled="" type="checkbox"/>
Test name describes what is being tested</li>
<li><input disabled="" type="checkbox"/>
Each test tests one behavior</li>
<li><input disabled="" type="checkbox"/>
No logic in assertions (e.g., no <code>if</code> statements)</li>
</ul>
<h2 id="common-mistakes--how-to-avoid-them"><a class="header" href="#common-mistakes--how-to-avoid-them">Common Mistakes &amp; How to Avoid Them</a></h2>
<h3 id="-mistake-1-mixing-arrange-and-act"><a class="header" href="#-mistake-1-mixing-arrange-and-act">âŒ Mistake 1: Mixing Arrange and Act</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DON'T: Hidden state between phases
test!(test_bad_mixing, {
    let result = setup_and_call();  // Mixes arrange + act
    assert_eq!(result, 42);
});
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DO: Clear separation
test!(test_good_mixing, {
    // Arrange
    let input = 42;

    // Act
    let result = calculate(input);

    // Assert
    assert_eq!(result, 42);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="-mistake-2-multiple-assertions-without-context"><a class="header" href="#-mistake-2-multiple-assertions-without-context">âŒ Mistake 2: Multiple Assertions Without Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DON'T: No comment explaining what each asserts
test!(test_bad_assertions, {
    // ... arrange and act ...
    assert_eq!(user.id, 1);
    assert_eq!(user.name, "Alice");
    assert!(user.is_active);
});
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DO: Clear what each assertion verifies
test!(test_good_assertions, {
    // ... arrange and act ...

    // Assert: User created with correct ID
    assert_eq!(user.id, 1);

    // Assert: User name matches input
    assert_eq!(user.name, "Alice");

    // Assert: User is active by default
    assert!(user.is_active);
});
<span class="boring">}</span></code></pre></pre>
<h3 id="-mistake-3-act-phase-doing-multiple-things"><a class="header" href="#-mistake-3-act-phase-doing-multiple-things">âŒ Mistake 3: Act Phase Doing Multiple Things</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DON'T: Multiple behaviors in Act
test!(test_bad_act, {
    let user = db.create_user("alice");
    user.send_welcome_email();  // Second behavior!
    assert!(user.email_sent);
});
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// DO: One behavior per test
test!(test_user_creation, {
    let user = db.create_user("alice");
    assert_eq!(user.name, "alice");
});

test!(test_welcome_email, {
    let user = db.create_user("alice");
    user.send_welcome_email();
    assert!(user.email_sent);
});
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-example"><a class="header" href="#real-world-example">Real-World Example</a></h2>
<p>The AAA pattern is foundational to Chicago TDD Tools. Every example test follows this structure, found throughout:</p>
<ul>
<li><code>examples/basic_test.rs</code> - Simple unit tests</li>
<li><code>tests/common.rs</code> - Shared test utilities</li>
<li>Test suites in the source code</li>
</ul>
<h2 id="advanced-multiple-assertions-in-assert-phase"><a class="header" href="#advanced-multiple-assertions-in-assert-phase">Advanced: Multiple Assertions in Assert Phase</a></h2>
<p>âœ… <strong>Allowed</strong>: Multiple assertions that verify the same behavior:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test!(test_user_properties, {
    // Arrange
    let user_data = vec!["alice", "25", "alice@example.com"];

    // Act
    let user = parse_user_csv(&amp;user_data)?;

    // Assert: All properties of the user
    assert_eq!(user.name, "alice");
    assert_eq!(user.age, 25);
    assert_eq!(user.email, "alice@example.com");
    assert!(user.is_valid());
});
<span class="boring">}</span></code></pre></pre>
<p>This is acceptable because all assertions verify related properties of the same object.</p>
<h2 id="related-patterns"><a class="header" href="#related-patterns">Related Patterns</a></h2>
<ul>
<li><strong>Pattern 2: Error Path Testing</strong> - Same AAA structure for error cases</li>
<li><strong>Pattern 3: Boundary Conditions</strong> - AAA structure for edge cases</li>
<li><strong>Pattern 5: Real Collaborators</strong> - AAA with actual dependencies</li>
<li><strong>Pattern 16: Fixture Lifecycle Management</strong> - AAA with fixtures for complex setup</li>
<li><strong>Pattern 17: Builder-Driven Test Data</strong> - AAA with fluent builders for Arrange phase</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Learn these related patterns to master test structure:</p>
<ol>
<li><strong>Next</strong>: <a href="testing-patterns/error-path-testing.html">Pattern 2: Error Path Testing</a> - How to test failure cases</li>
<li><strong>Then</strong>: <a href="testing-patterns/real-collaborators.html">Pattern 5: Real Collaborators</a> - Testing with actual dependencies</li>
<li><strong>Advanced</strong>: <a href="testing-patterns/../design-patterns/fixture-lifecycle.html">Pattern 16: Fixture Lifecycle</a> - Complex multi-phase tests</li>
</ol>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The AAA pattern is the foundation of readable, maintainable tests. By consistently separating <strong>Arrange</strong>, <strong>Act</strong>, and <strong>Assert</strong>, you create tests that:</p>
<p>âœ… Are easy to read and understand
âœ… Fail with clear messages about what went wrong
âœ… Scale from simple to complex tests
âœ… Can be easily maintained by teammates</p>
<p><strong>Pro tip</strong>: Use comments to label each phase, even in simple tests. It takes one line and makes the intent crystal clear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-2-error-path-testing"><a class="header" href="#pattern-2-error-path-testing">Pattern 2: Error Path Testing</a></h1>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>A function returns <code>Result</code> or <code>Option</code>, and the happy path already behaves as expected. You must guarantee that every failure mode is observable and carries actionable context.</p>
<h2 id="problem-1"><a class="header" href="#problem-1">Problem</a></h2>
<p>When tests only exercise the success path, regressions sneak in through unhandled errors, missing context, or broken guardrails. Production discovers the failure first, and the team spends time reconstructing the scenario.</p>
<h2 id="solution-1"><a class="header" href="#solution-1">Solution</a></h2>
<p>Enumerate every documented error variant and write a focused test for each. Use <code>test!</code> or <code>param_test!</code> to drive the error case, assert the specific variant, and check that error messages include the necessary context. Prefer direct construction or builders over mocks so that you validate the real failure.</p>
<h2 id="forces-1"><a class="header" href="#forces-1">Forces</a></h2>
<ul>
<li>Coverage vs. duplication: each error merits a separate assertion without creating noise</li>
<li>Realistic behavior vs. test speed: use in-memory collaborators where possible, but ensure pathways stay intact</li>
<li>Diagnostic clarity vs. maintenance: error text should be specific yet stable</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::core::fixture::FixtureError;

param_test! {
    #[case("", FixtureError::CreationFailed("name required".into()))]
    #[case("db://unreachable", FixtureError::OperationFailed("reconnect failed".into()))]
    fn test_fixture_error_paths(input: &amp;str, expected: FixtureError) {
        let result = TestFixture::with_data(input.to_string()).cleanup();
        assert_err!(&amp;result);
        let error = result.unwrap_err();
        assert_eq!(format!("{}", error), format!("{}", expected));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-1"><a class="header" href="#related-patterns-1">Related Patterns</a></h2>
<ul>
<li>Pattern 3: Boundary Conditions</li>
<li>Pattern 18: Timeout Defense in Depth</li>
<li>Pattern 19: Feature Gate Slices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-3-boundary-conditions"><a class="header" href="#pattern-3-boundary-conditions">Pattern 3: Boundary Conditions</a></h1>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>Logic depends on limits: minimum quantities, maximum run lengths, exclusive ranges. You must guarantee behavior at and around those boundaries.</p>
<h2 id="problem-2"><a class="header" href="#problem-2">Problem</a></h2>
<p>Happy-path tests routinely miss off-by-one errors, buffer limits, or guardrail regressions. Without explicit boundary coverage, downstream invariants fail silently.</p>
<h2 id="solution-2"><a class="header" href="#solution-2">Solution</a></h2>
<p>Adopt a deliberate boundary grid: <strong>below</strong>, <strong>at</strong>, and <strong>above</strong> each documented limit. Use <code>param_test!</code> to table-drive the grid and Chicago TDD Tools assertions such as <code>assert_in_range!</code> and <code>assert_guard_constraint!</code>. Include boundary-focused names so a failing case communicates which edge is breached.</p>
<h2 id="forces-2"><a class="header" href="#forces-2">Forces</a></h2>
<ul>
<li>Thoroughness vs. duplication: table-driven tests keep boundaries concise</li>
<li>Performance vs. realism: small data sets reproduce the failure quickly</li>
<li>Maintainability vs. specificity: boundary constants should live in one place</li>
</ul>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::validation::guards::{GuardValidator, MAX_RUN_LEN};

param_test! {
    #[case("below", MAX_RUN_LEN - 1, true)]
    #[case("at", MAX_RUN_LEN, true)]
    #[case("above", MAX_RUN_LEN + 1, false)]
    fn test_run_length_boundaries(label: &amp;str, length: usize, expected_ok: bool) {
        let validator = GuardValidator::new();
        let result = validator.validate_run_length(length);
        match expected_ok {
            true =&gt; assert_ok!(&amp;result, "{label} should be accepted"),
            false =&gt; assert_err!(&amp;result, "{label} should be rejected"),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-2"><a class="header" href="#related-patterns-2">Related Patterns</a></h2>
<ul>
<li>Pattern 2: Error Path Testing</li>
<li>Pattern 4: Resource Cleanup</li>
<li>Pattern 20: Macro Pattern Enforcement</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-4-resource-cleanup"><a class="header" href="#pattern-4-resource-cleanup">Pattern 4: Resource Cleanup</a></h1>
<h2 id="context-3"><a class="header" href="#context-3">Context</a></h2>
<p>Your tests allocate resources â€“ files, network ports, containers, telemetry backends â€“ that must be released even when assertions fail.</p>
<h2 id="problem-3"><a class="header" href="#problem-3">Problem</a></h2>
<p>Forgetting to release resources causes nondeterministic failures, leaking containers, or state pollution between tests. Manual cleanup logic scatters across tests and is easy to miss.</p>
<h2 id="solution-3"><a class="header" href="#solution-3">Solution</a></h2>
<p>Use Chicago TDD Tools fixtures and the RAII guarantees they provide. Wrap resource management inside <code>fixture_test!</code> or <code>fixture_test_with_timeout!</code>, storing handles in the fixture. Allow Drop implementations and the framework cleanup to run automatically so every test returns to a known good state.</p>
<h2 id="forces-3"><a class="header" href="#forces-3">Forces</a></h2>
<ul>
<li>Determinism vs. speed: automated teardown must be reliable without slowing the hot path</li>
<li>Simplicity vs. observability: cleanup should be invisible unless a failure occurs</li>
<li>Isolation vs. reuse: fixtures create fresh state while sharing setup logic</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use testcontainers::clients::Cli as DockerCli;

struct DockerFixture {
    docker: DockerCli,
}

fixture_test!(test_exec_container_command, fixture, {
    // Arrange
    let docker = DockerCli::default();
    let container = docker.run("alpine:3.19");

    // Act
    let result = container.exec("echo", &amp;["ok"])?;

    // Assert
    assert_eq!(result.stdout, "ok\n");

    Ok::&lt;(), testcontainers::Error&gt;(())
});
<span class="boring">}</span></code></pre></pre>
<p>The fixture ensures containers stop even if the assertion fails.</p>
<h2 id="related-patterns-3"><a class="header" href="#related-patterns-3">Related Patterns</a></h2>
<ul>
<li>Pattern 5: Real Collaborators</li>
<li>Pattern 16: Fixture Lifecycle Management</li>
<li>Pattern 18: Timeout Defense in Depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-5-real-collaborators"><a class="header" href="#pattern-5-real-collaborators">Pattern 5: Real Collaborators</a></h1>
<h2 id="context-4"><a class="header" href="#context-4">Context</a></h2>
<p>You are validating behavior that depends on external systems â€“ telemetry, containers, queues â€“ and want confidence that integrations behave the same way in production.</p>
<h2 id="problem-4"><a class="header" href="#problem-4">Problem</a></h2>
<p>Mock-heavy tests can mask integration gaps, drift from reality, and erode trust in the test suite. When production fails, tests offer little guidance.</p>
<h2 id="solution-4"><a class="header" href="#solution-4">Solution</a></h2>
<p>Use the framework's integration helpers to exercise real collaborators. For containers, enable the <code>testcontainers</code> feature and run against Docker. For telemetry, use <code>otel_test!</code> and <code>weaver_test!</code> to validate spans and semantic conventions. Keep tests categorized so slower integration suites run intentionally.</p>
<h2 id="forces-4"><a class="header" href="#forces-4">Forces</a></h2>
<ul>
<li>Fidelity vs. speed: real dependencies cost more time, so isolate them behind feature flags and profiles</li>
<li>Determinism vs. variability: control randomness via fixtures and builders</li>
<li>Observability vs. complexity: prefer higher-level validators over low-level asserts</li>
</ul>
<h2 id="examples-5"><a class="header" href="#examples-5">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::observability::otel::{OtelTestHelper, SpanValidator};

otel_test!(test_span_follows_conventions, {
    // Arrange
    let helper = OtelTestHelper::new();
    let span = helper.capture(|tracer| tracer.span("checkout"));

    // Act
    let result = helper.assert_spans_valid(&amp;[span.clone()]);

    // Assert
    assert_ok!(&amp;result);
});
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use chicago_tdd_tools::prelude::*;
use chicago_tdd_tools::integration::testcontainers::ContainerClient;

fixture_test_with_timeout!(test_postgres_roundtrip, fixture, 30, {
    // Arrange
    let client = ContainerClient::for_image("postgres:16").await?;

    // Act
    let rows = client.query("SELECT 1").await?;

    // Assert
    assert_eq!(rows[0].get::&lt;i32, _&gt;(0), 1);

    Ok::&lt;(), testcontainers::Error&gt;(())
});
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-4"><a class="header" href="#related-patterns-4">Related Patterns</a></h2>
<ul>
<li>Pattern 4: Resource Cleanup</li>
<li>Pattern 16: Fixture Lifecycle Management</li>
<li>Pattern 18: Timeout Defense in Depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-patterns"><a class="header" href="#architecture-patterns">Architecture Patterns</a></h1>
<p>Chicago TDD Tools is deliberately layered so teams can extend the framework without rewriting core functionality. The architecture patterns describe how modules compose, how extensions fit, and how the framework keeps behavior predictable across crates.</p>
<p>Use these patterns when building custom tooling on top of the framework or when evaluating how to contribute new modules upstream.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-6-generic-base-layer"><a class="header" href="#pattern-6-generic-base-layer">Pattern 6: Generic Base Layer</a></h1>
<h2 id="context-5"><a class="header" href="#context-5">Context</a></h2>
<p>You want a reusable testing foundation that can support multiple domains without pulling in their dependencies.</p>
<h2 id="problem-5"><a class="header" href="#problem-5">Problem</a></h2>
<p>If the base includes domain code, every consumer drags in unused dependencies, slowing builds and introducing coupling. Conversely, a minimal base risks missing essential primitives.</p>
<h2 id="solution-5"><a class="header" href="#solution-5">Solution</a></h2>
<p>Keep the core crate focused on generic capabilities â€“ fixtures, builders, assertions, macros, state tracking. Expose them through capability modules (<code>core</code>, <code>testing</code>, <code>validation</code>, <code>observability</code>, <code>integration</code>). Ensure modules depend only on the standard library and optional features. Domain-specific abstractions live in downstream crates that compose the base.</p>
<h2 id="forces-5"><a class="header" href="#forces-5">Forces</a></h2>
<ul>
<li>Reuse vs. specialization: core must be broadly useful without dictating domain models</li>
<li>Build time vs. flexibility: optional features load only when needed</li>
<li>Stability vs. growth: base APIs should be stable; extensions add behavior</li>
</ul>
<h2 id="examples-6"><a class="header" href="#examples-6">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
pub mod core;
pub mod testing;
pub mod validation;
pub mod observability;
pub mod integration;

pub use core::{fixture, builders, assertions};
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-5"><a class="header" href="#related-patterns-5">Related Patterns</a></h2>
<ul>
<li>Pattern 7: Extension Layer</li>
<li>Pattern 8: Composition Over Duplication</li>
<li>Pattern 10: Capability Grouping</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-7-extension-layer"><a class="header" href="#pattern-7-extension-layer">Pattern 7: Extension Layer</a></h1>
<h2 id="context-6"><a class="header" href="#context-6">Context</a></h2>
<p>A product team needs domain-specific fixtures, builders, or assertions on top of Chicago TDD Tools.</p>
<h2 id="problem-6"><a class="header" href="#problem-6">Problem</a></h2>
<p>Embedding domain logic inside the core crate makes it hard to evolve independently and risks breaking other users. Repeated copy-paste of generic primitives leads to drift.</p>
<h2 id="solution-6"><a class="header" href="#solution-6">Solution</a></h2>
<p>Create an extension crate that depends on the core. Compose base fixtures inside your domain fixture, forwarding behavior while adding fields and helpers. Re-export the pieces your team should import. Treat the base crate as an 80% solution and layer the remaining 20% locally.</p>
<h2 id="forces-6"><a class="header" href="#forces-6">Forces</a></h2>
<ul>
<li>Encapsulation vs. reuse: domain modules wrap core primitives rather than modify them</li>
<li>Stability vs. iteration speed: upstream stays stable while the extension can iterate quickly</li>
<li>Discoverability vs. sprawl: re-export only what the domain needs</li>
</ul>
<h2 id="examples-7"><a class="header" href="#examples-7">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// workflow-fixture crate
use chicago_tdd_tools::core::fixture::TestFixture;

pub struct WorkflowFixture {
    base: TestFixture&lt;()&gt;,
    engine: WorkflowEngine,
}

impl WorkflowFixture {
    pub fn new(engine: WorkflowEngine) -&gt; Self {
        let base = TestFixture::new().expect("fixture");
        Self { base, engine }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-6"><a class="header" href="#related-patterns-6">Related Patterns</a></h2>
<ul>
<li>Pattern 6: Generic Base Layer</li>
<li>Pattern 8: Composition Over Duplication</li>
<li>Pattern 9: Single Source of Truth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-8-composition-over-duplication"><a class="header" href="#pattern-8-composition-over-duplication">Pattern 8: Composition Over Duplication</a></h1>
<h2 id="context-7"><a class="header" href="#context-7">Context</a></h2>
<p>You are adding a feature to an extension crate and need functionality already available in the base layer.</p>
<h2 id="problem-7"><a class="header" href="#problem-7">Problem</a></h2>
<p>Copying helpers or macros breaks the single source of truth. Over time the copies diverge, and bug fixes must be applied in multiple places.</p>
<h2 id="solution-7"><a class="header" href="#solution-7">Solution</a></h2>
<p>Compose existing primitives. Wrap fixtures inside domain fixtures, embed builders into higher-level builders, and use assertion macros rather than writing bespoke checks. When missing functionality is truly generic, add it to the base crate instead of forking it downstream.</p>
<h2 id="forces-7"><a class="header" href="#forces-7">Forces</a></h2>
<ul>
<li>Launch speed vs. long-term maintenance: composition keeps future upgrades cheap</li>
<li>Ergonomics vs. explicitness: wrappers can augment APIs without obscuring the base</li>
<li>Ownership vs. contribution: contribute upstream when the behavior benefits all users</li>
</ul>
<h2 id="examples-8"><a class="header" href="#examples-8">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OrderBuilder {
    base: TestDataBuilder,
}

impl OrderBuilder {
    pub fn new() -&gt; Self {
        Self { base: TestDataBuilder::new() }
    }

    pub fn with_amount(mut self, amount: u64) -&gt; Self {
        self.base = self.base.with_var("amount", amount.to_string());
        self
    }

    pub fn build_json(self) -&gt; serde_json::Value {
        self.base.build_json().expect("json")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-7"><a class="header" href="#related-patterns-7">Related Patterns</a></h2>
<ul>
<li>Pattern 6: Generic Base Layer</li>
<li>Pattern 7: Extension Layer</li>
<li>Pattern 9: Single Source of Truth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-9-single-source-of-truth"><a class="header" href="#pattern-9-single-source-of-truth">Pattern 9: Single Source of Truth</a></h1>
<h2 id="context-8"><a class="header" href="#context-8">Context</a></h2>
<p>Constants, toggle lists, and feature matrices are needed across modules and extensions.</p>
<h2 id="problem-8"><a class="header" href="#problem-8">Problem</a></h2>
<p>Duplicating configuration (timeouts, guard limits, feature lists) invites drift. Teams change one copy and forget the rest, producing inconsistent behavior.</p>
<h2 id="solution-8"><a class="header" href="#solution-8">Solution</a></h2>
<p>Centralize invariants inside the module that owns them and re-export when necessary. Examples include timeout constants in <code>core::macros::test</code>, guard limits in <code>validation::guards</code>, and feature combinations in <code>Cargo.toml</code>. Extensions read these definitions instead of defining their own copies.</p>
<h2 id="forces-8"><a class="header" href="#forces-8">Forces</a></h2>
<ul>
<li>Accessibility vs. encapsulation: invariants must be easy to import without exposing internals</li>
<li>Flexibility vs. safety: allow customization through builders or configuration rather than duplicating constants</li>
<li>Documentation vs. code: comments and docs should reference the single source, not restated values</li>
</ul>
<h2 id="examples-9"><a class="header" href="#examples-9">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/core/macros/test.rs
pub const DEFAULT_UNIT_TEST_TIMEOUT_SECONDS: u64 = 1;
pub const DEFAULT_INTEGRATION_TEST_TIMEOUT_SECONDS: u64 = 30;

// src/validation/guards.rs
pub const MAX_RUN_LEN: usize = 8;
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-8"><a class="header" href="#related-patterns-8">Related Patterns</a></h2>
<ul>
<li>Pattern 8: Composition Over Duplication</li>
<li>Pattern 10: Capability Grouping</li>
<li>Pattern 18: Timeout Defense in Depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-10-capability-grouping"><a class="header" href="#pattern-10-capability-grouping">Pattern 10: Capability Grouping</a></h1>
<h2 id="context-9"><a class="header" href="#context-9">Context</a></h2>
<p>You are browsing the Chicago TDD Tools codebase or designing a new module. You need to know where functionality belongs and how to expose it.</p>
<h2 id="problem-9"><a class="header" href="#problem-9">Problem</a></h2>
<p>Without a consistent module taxonomy, features surface haphazardly. Consumers struggle to find capabilities, and maintainers duplicate structure.</p>
<h2 id="solution-9"><a class="header" href="#solution-9">Solution</a></h2>
<p>Group modules by capability: <code>core</code> for foundational primitives, <code>testing</code> for advanced techniques, <code>validation</code> for guardrails, <code>observability</code> for telemetry, and <code>integration</code> for external systems. Re-export each group at the crate root to support both granular and high-level imports. New modules join one of these groups or motivate a new, clearly named capability.</p>
<h2 id="forces-9"><a class="header" href="#forces-9">Forces</a></h2>
<ul>
<li>Discoverability vs. granularity: capability groups provide short import paths while preserving modularity</li>
<li>Stability vs. evolution: groups rarely change, making documentation and IDE tooling reliable</li>
<li>Compilation vs. optionality: feature flags enable or disable entire capability slices</li>
</ul>
<h2 id="examples-10"><a class="header" href="#examples-10">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
pub mod core;          // fixtures, builders, assertions, macros
pub mod testing;       // property testing, mutation testing, snapshots
pub mod validation;    // guards, coverage, performance
pub mod observability; // otel, weaver
pub mod integration;   // testcontainers
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-9"><a class="header" href="#related-patterns-9">Related Patterns</a></h2>
<ul>
<li>Pattern 6: Generic Base Layer</li>
<li>Pattern 9: Single Source of Truth</li>
<li>Pattern 19: Feature Gate Slices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-patterns"><a class="header" href="#design-patterns">Design Patterns</a></h1>
<p>These patterns codify the type-level and zero-cost techniques that make Chicago TDD Tools safe and fast. They explain how the framework encodes invariants, leverages Rust's compiler, and prevents misuse through types.</p>
<p>Use them when extending the framework or designing downstream APIs that should feel at home in the ecosystem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-11-zero-cost-abstractions"><a class="header" href="#pattern-11-zero-cost-abstractions">Pattern 11: Zero-Cost Abstractions</a></h1>
<h2 id="context-10"><a class="header" href="#context-10">Context</a></h2>
<p>You are designing APIs or extensions and need expressive abstractions without runtime overhead.</p>
<h2 id="problem-10"><a class="header" href="#problem-10">Problem</a></h2>
<p>Runtime polymorphism or heap allocations can slow hot paths. Manual inlining or duplicated code sacrifices readability.</p>
<h2 id="solution-10"><a class="header" href="#solution-10">Solution</a></h2>
<p>Lean on generics, const generics, and macros to express behavior that compiles down to the same machine code as bespoke implementations. Favor references over owned values and prefer stack allocation. When dynamic dispatch is required, isolate it behind narrow traits.</p>
<h2 id="forces-10"><a class="header" href="#forces-10">Forces</a></h2>
<ul>
<li>Expressiveness vs. performance: abstractions must be ergonomic without cost</li>
<li>Safety vs. control: compile-time guarantees should not block optimization</li>
<li>Maintainability vs. specialization: macros and generics prevent copy-paste</li>
</ul>
<h2 id="examples-11"><a class="header" href="#examples-11">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn measure_ticks&lt;F, T&gt;(operation: F) -&gt; (T, u64)
where
    F: FnOnce() -&gt; T,
{
    // Generic function specialized per call site; no dynamic dispatch
    chicago_tdd_tools::validation::performance::measure_ticks(operation)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-10"><a class="header" href="#related-patterns-10">Related Patterns</a></h2>
<ul>
<li>Pattern 12: Type Safety with GATs</li>
<li>Pattern 14: Compile-Time Validation</li>
<li>Pattern 20: Macro Pattern Enforcement</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-12-type-safety-with-gats"><a class="header" href="#pattern-12-type-safety-with-gats">Pattern 12: Type Safety with GATs</a></h1>
<h2 id="context-11"><a class="header" href="#context-11">Context</a></h2>
<p>You provide fixtures or builders that return references tied to the fixture lifetime.</p>
<h2 id="problem-11"><a class="header" href="#problem-11">Problem</a></h2>
<p>Without explicit lifetimes, consumers can hold onto references after cleanup, causing dangling pointers or logic bugs.</p>
<h2 id="solution-11"><a class="header" href="#solution-11">Solution</a></h2>
<p>Use Generic Associated Types (GATs) to bind returned data to the fixture lifetime. In <code>AsyncFixtureProvider</code>, <code>Fixture&lt;'a&gt;</code> ensures the borrow cannot outlive the provider. Pair GATs with sealed traits to prevent downstream crates from violating invariants.</p>
<h2 id="forces-11"><a class="header" href="#forces-11">Forces</a></h2>
<ul>
<li>Safety vs. ergonomics: GATs constrain lifetimes but keep APIs pleasant</li>
<li>Extensibility vs. soundness: sealing the trait permits internal evolution while preserving invariants</li>
<li>Async vs. sync: async fixtures require lifetimes that sync code cannot express without GATs</li>
</ul>
<h2 id="examples-12"><a class="header" href="#examples-12">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait AsyncFixtureProvider: private::Sealed {
    type Fixture&lt;'a&gt;: Send where Self: 'a;
    type Error: std::error::Error + Send + Sync + 'static;

    fn create_fixture&lt;'a&gt;(&amp;'a self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Fixture&lt;'a&gt;, Self::Error&gt;&gt; + Send + 'a&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-11"><a class="header" href="#related-patterns-11">Related Patterns</a></h2>
<ul>
<li>Pattern 13: Sealed Traits for API Safety</li>
<li>Pattern 16: Fixture Lifecycle Management</li>
<li>Pattern 17: Builder-Driven Test Data</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-13-sealed-traits-for-api-safety"><a class="header" href="#pattern-13-sealed-traits-for-api-safety">Pattern 13: Sealed Traits for API Safety</a></h1>
<h2 id="context-12"><a class="header" href="#context-12">Context</a></h2>
<p>A trait defines extension points (fixtures, validators) but external implementations could break invariants.</p>
<h2 id="problem-12"><a class="header" href="#problem-12">Problem</a></h2>
<p>If downstream crates implement the trait arbitrarily, the framework cannot guarantee lifecycle management or error semantics. Breaking changes become impossible.</p>
<h2 id="solution-12"><a class="header" href="#solution-12">Solution</a></h2>
<p>Use the sealed trait pattern: define a <code>private</code> module with a <code>Sealed</code> trait implemented only within the crate, and require <code>Sealed</code> as a supertrait. Consumers can use the trait, but only framework-defined implementations exist.</p>
<h2 id="forces-12"><a class="header" href="#forces-12">Forces</a></h2>
<ul>
<li>Safety vs. openness: sealing protects invariants while letting users compose functionality</li>
<li>Flexibility vs. versioning: internal changes become possible without breaking downstream code</li>
<li>Testability vs. encapsulation: tests can still construct fixtures via provided builders</li>
</ul>
<h2 id="examples-13"><a class="header" href="#examples-13">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod private {
    pub trait Sealed {}
}

pub trait AsyncFixtureProvider: private::Sealed {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-12"><a class="header" href="#related-patterns-12">Related Patterns</a></h2>
<ul>
<li>Pattern 12: Type Safety with GATs</li>
<li>Pattern 17: Builder-Driven Test Data</li>
<li>Pattern 20: Macro Pattern Enforcement</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-14-compile-time-validation"><a class="header" href="#pattern-14-compile-time-validation">Pattern 14: Compile-Time Validation</a></h1>
<h2 id="context-13"><a class="header" href="#context-13">Context</a></h2>
<p>Invariants (tick budgets, guard limits, feature combinations) should fail fast during compilation.</p>
<h2 id="problem-13"><a class="header" href="#problem-13">Problem</a></h2>
<p>Runtime checks add overhead and can be bypassed in rarely executed code paths. Missing an invariant leads to subtle production bugs.</p>
<h2 id="solution-13"><a class="header" href="#solution-13">Solution</a></h2>
<p>Push validation to compile time with const generics, type-level markers, and <code>const_assert!</code>. When runtime validation is unavoidable, encapsulate it in constructors that return <code>Result</code>, making misuse impossible through types.</p>
<h2 id="forces-13"><a class="header" href="#forces-13">Forces</a></h2>
<ul>
<li>Safety vs. flexibility: some values remain runtime, but defaults should be encoded in types</li>
<li>Compile time vs. ergonomics: const generics expose parameters without macros</li>
<li>Diagnostics vs. noise: compile errors must explain the invariant succinctly</li>
</ul>
<h2 id="examples-14"><a class="header" href="#examples-14">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const fn assert_tick_budget(ticks: u64) {
    const_assert!(ticks &lt;= 8);
}

pub struct SizeValidatedArray&lt;const SIZE: usize, const MAX: usize&gt; {
    data: [u8; SIZE],
    _marker: PhantomData&lt;[u8; MAX]&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-13"><a class="header" href="#related-patterns-13">Related Patterns</a></h2>
<ul>
<li>Pattern 11: Zero-Cost Abstractions</li>
<li>Pattern 15: Type State Enforcement</li>
<li>Pattern 18: Timeout Defense in Depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-15-type-state-enforcement"><a class="header" href="#pattern-15-type-state-enforcement">Pattern 15: Type State Enforcement</a></h1>
<h2 id="context-14"><a class="header" href="#context-14">Context</a></h2>
<p>An API has a prescribed call order (Arrange â†’ Act â†’ Assert) or requires configuration before use.</p>
<h2 id="problem-14"><a class="header" href="#problem-14">Problem</a></h2>
<p>Runtime enforcement of order relies on documentation and can be bypassed, leading to inconsistent state and test flakiness.</p>
<h2 id="solution-14"><a class="header" href="#solution-14">Solution</a></h2>
<p>Model the phases as distinct types and use <code>PhantomData</code> to encode the current phase. Methods consume <code>self</code> and return the next state, making it impossible to call methods out of order. Chicago TDD Tools uses this to enforce AAA semantics internally.</p>
<h2 id="forces-14"><a class="header" href="#forces-14">Forces</a></h2>
<ul>
<li>Safety vs. ergonomic: type transitions should read naturally without verbose syntax</li>
<li>Flexibility vs. constraints: provide escape hatches only when absolutely necessary</li>
<li>Zero-cost vs. clarity: type state should erase at compile time</li>
</ul>
<h2 id="examples-15"><a class="header" href="#examples-15">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TestState&lt;Phase&gt; {
    context: Context,
    _phase: PhantomData&lt;Phase&gt;,
}

impl TestState&lt;Arrange&gt; {
    pub fn act(self) -&gt; TestState&lt;Act&gt; { /* ... */ }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-14"><a class="header" href="#related-patterns-14">Related Patterns</a></h2>
<ul>
<li>Pattern 1: AAA Pattern</li>
<li>Pattern 11: Zero-Cost Abstractions</li>
<li>Pattern 14: Compile-Time Validation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-patterns-from-practice"><a class="header" href="#new-patterns-from-practice">New Patterns from Practice</a></h1>
<p>The framework continues to evolve through real-world usage. This section captures patterns that emerged after building large Chicago TDD deployments. They complement the classical design patterns with pragmatic guidance on fixtures, timeouts, feature flags, and macro enforcement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-16-fixture-lifecycle-management"><a class="header" href="#pattern-16-fixture-lifecycle-management">Pattern 16: Fixture Lifecycle Management</a></h1>
<h2 id="context-15"><a class="header" href="#context-15">Context</a></h2>
<p>Complex tests require deterministic setup and teardown of shared state: databases, telemetry, temporary directories.</p>
<h2 id="problem-15"><a class="header" href="#problem-15">Problem</a></h2>
<p>Manual lifecycle logic is error-prone. Forgetting teardown causes cascading failures across tests. Async setup complicates matters further.</p>
<h2 id="solution-15"><a class="header" href="#solution-15">Solution</a></h2>
<p>Wrap lifecycle responsibilities in <code>TestFixture</code> or <code>AsyncFixtureManager</code>. Use the fixture to hold handles and expose helper methods. Let Drop and the manager <code>.teardown()</code> guarantee cleanup. For async resources, implement <code>AsyncFixtureProvider</code> and return strongly typed handles.</p>
<h2 id="forces-15"><a class="header" href="#forces-15">Forces</a></h2>
<ul>
<li>Determinism vs. flexibility: fixtures must isolate state yet allow custom behavior per test</li>
<li>Async vs. sync complexity: asynchronous resources require explicit lifecycle boundaries</li>
<li>Performance vs. safety: reuse is tempting, but fresh fixtures avoid hidden coupling</li>
</ul>
<h2 id="examples-16"><a class="header" href="#examples-16">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DbProvider;

impl chicago_tdd_tools::core::async_fixture::private::Sealed for DbProvider {}

impl AsyncFixtureProvider for DbProvider {
    type Fixture&lt;'a&gt; = DatabaseHandle;
    type Error = DbError;

    fn create_fixture&lt;'a&gt;(&amp;'a self) -&gt; DbFuture&lt;'a, DatabaseHandle&gt; {
        Box::pin(async move { DatabaseHandle::connect().await })
    }
}

async_test!(test_query_latency, {
    let manager = AsyncFixtureManager::new(DbProvider);
    let handle = manager.setup().await?;
    // ...
    manager.teardown().await?;
    Ok(())
});
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-15"><a class="header" href="#related-patterns-15">Related Patterns</a></h2>
<ul>
<li>Pattern 4: Resource Cleanup</li>
<li>Pattern 12: Type Safety with GATs</li>
<li>Pattern 18: Timeout Defense in Depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-17-builder-driven-test-data"><a class="header" href="#pattern-17-builder-driven-test-data">Pattern 17: Builder-Driven Test Data</a></h1>
<h2 id="context-16"><a class="header" href="#context-16">Context</a></h2>
<p>Domain objects require multiple fields or nested structures. Hand-building them in tests scatters intent and duplicates defaults.</p>
<h2 id="problem-16"><a class="header" href="#problem-16">Problem</a></h2>
<p>Verbose setup obscures the behavior under test. When requirements change, hundreds of tests need updates.</p>
<h2 id="solution-16"><a class="header" href="#solution-16">Solution</a></h2>
<p>Wrap <code>TestDataBuilder</code> (or create your own builder) to provide fluent helpers and sensible defaults. Expose domain-specific methods (<code>with_customer_id</code>, <code>with_balance</code>) and return JSON or HashMap structures ready for assertions. Builders live close to the domain, yet reuse the underlying generic builder to avoid duplication.</p>
<h2 id="forces-16"><a class="header" href="#forces-16">Forces</a></h2>
<ul>
<li>Expressiveness vs. coupling: builders should reflect domain language without leaking implementation details</li>
<li>Defaults vs. explicitness: provide safe defaults but allow overrides</li>
<li>Reuse vs. specialization: share base builder logic; extensions add convenience</li>
</ul>
<h2 id="examples-17"><a class="header" href="#examples-17">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomerBuilder {
    base: TestDataBuilder,
}

impl CustomerBuilder {
    pub fn new() -&gt; Self {
        Self {
            base: TestDataBuilder::new()
                .with_var("status", "active"),
        }
    }

    pub fn with_id(mut self, id: &amp;str) -&gt; Self {
        self.base = self.base.with_var("customer_id", id.to_string());
        self
    }

    pub fn build(self) -&gt; serde_json::Value {
        self.base.build_json().expect("valid json")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-16"><a class="header" href="#related-patterns-16">Related Patterns</a></h2>
<ul>
<li>Pattern 8: Composition Over Duplication</li>
<li>Pattern 11: Zero-Cost Abstractions</li>
<li>Pattern 19: Feature Gate Slices</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-18-timeout-defense-in-depth"><a class="header" href="#pattern-18-timeout-defense-in-depth">Pattern 18: Timeout Defense in Depth</a></h1>
<h2 id="context-17"><a class="header" href="#context-17">Context</a></h2>
<p>Async tests interact with containers, networks, or external services. A hung future or stalled process could freeze the suite.</p>
<h2 id="problem-17"><a class="header" href="#problem-17">Problem</a></h2>
<p>Single-layer timeouts fail silently when they reside in the wrong place. For example, process-level timeouts kill the entire run without explaining which test stalled.</p>
<h2 id="solution-17"><a class="header" href="#solution-17">Solution</a></h2>
<p>Layer timeouts at three levels:</p>
<ol>
<li><strong>Test-level</strong> (<code>tokio::time::timeout</code> inside macros) â€“ fails the specific test with a clear message.</li>
<li><strong>Runner-level</strong> (<code>cargo-nextest</code> profiles) â€“ applies SLA-based timeouts per profile.</li>
<li><strong>Process-level</strong> (<code>timeout</code> wrapper in <code>Makefile.toml</code>) â€“ stops catastrophic hangs.</li>
</ol>
<p>Expose constants for standard timeouts (<code>DEFAULT_UNIT_TEST_TIMEOUT_SECONDS = 1</code>, <code>DEFAULT_INTEGRATION_TEST_TIMEOUT_SECONDS = 30</code>) and use <code>*_with_timeout!</code> macros for slow scenarios.</p>
<h2 id="forces-17"><a class="header" href="#forces-17">Forces</a></h2>
<ul>
<li>Resilience vs. noise: timeouts must be strict enough to catch hangs but lenient for expected latency</li>
<li>Diagnostics vs. overhead: detailed error messages help triage without cluttering success paths</li>
<li>Configurability vs. consistency: shared constants keep expectations aligned</li>
</ul>
<h2 id="examples-18"><a class="header" href="#examples-18">Examples</a></h2>
<pre><code class="language-toml"># .config/nextest.toml
[profile.default]
slow-timeout = { period = "1s", terminate-after = 1 }

[profile.integration]
slow-timeout = { period = "30s", terminate-after = 1 }
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fixture_test_with_timeout!(test_container_warmup, fixture, DEFAULT_INTEGRATION_TEST_TIMEOUT_SECONDS, {
    // slow operation
    Ok(())
});
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-17"><a class="header" href="#related-patterns-17">Related Patterns</a></h2>
<ul>
<li>Pattern 4: Resource Cleanup</li>
<li>Pattern 9: Single Source of Truth</li>
<li>Pattern 20: Macro Pattern Enforcement</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-19-feature-gate-slices"><a class="header" href="#pattern-19-feature-gate-slices">Pattern 19: Feature Gate Slices</a></h1>
<h2 id="context-18"><a class="header" href="#context-18">Context</a></h2>
<p>The framework offers advanced capabilities (property testing, mutation testing, testcontainers, OTEL) that not every project needs.</p>
<h2 id="problem-18"><a class="header" href="#problem-18">Problem</a></h2>
<p>Enabling every feature increases compile times and pulls in heavy dependencies. Disabling a feature accidentally can break tests silently.</p>
<h2 id="solution-18"><a class="header" href="#solution-18">Solution</a></h2>
<p>Group related features into named slices in <code>Cargo.toml</code> (e.g., <code>testing-extras</code>, <code>observability-full</code>). Document the slice and expose <code>cfg</code>-gated APIs accordingly. Tests and examples import the feature-specific modules only when the feature is active, keeping the base lean.</p>
<h2 id="forces-18"><a class="header" href="#forces-18">Forces</a></h2>
<ul>
<li>Modularity vs. convenience: slices reduce duplication but still allow fine-grained toggles</li>
<li>Discoverability vs. complexity: a small number of curated slices keeps onboarding simple</li>
<li>Compatibility vs. optionality: code must compile cleanly with features disabled</li>
</ul>
<h2 id="examples-19"><a class="header" href="#examples-19">Examples</a></h2>
<pre><code class="language-toml">[features]
default = ["logging"]
testing-extras = ["property-testing", "snapshot-testing", "fake-data"]
observability-full = ["otel", "weaver"]
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "weaver")]
pub mod weaver;
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-18"><a class="header" href="#related-patterns-18">Related Patterns</a></h2>
<ul>
<li>Pattern 6: Generic Base Layer</li>
<li>Pattern 10: Capability Grouping</li>
<li>Pattern 20: Macro Pattern Enforcement</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-20-macro-pattern-enforcement"><a class="header" href="#pattern-20-macro-pattern-enforcement">Pattern 20: Macro Pattern Enforcement</a></h1>
<h2 id="context-19"><a class="header" href="#context-19">Context</a></h2>
<p>You need consistent test structure and timeouts without repeating boilerplate or relying on discipline alone.</p>
<h2 id="problem-19"><a class="header" href="#problem-19">Problem</a></h2>
<p>Developers forget to add timeouts, skip AAA comments, or mix direct <code>#[test]</code> usage with framework macros, leading to drift and inconsistent behavior.</p>
<h2 id="solution-19"><a class="header" href="#solution-19">Solution</a></h2>
<p>Embed enforcement inside macros. <code>test!</code> injects the AAA skeleton, <code>async_test!</code> and <code>fixture_test!</code> wrap bodies with <code>tokio::time::timeout</code>, and <code>weaver_test!</code> requires the <code>weaver</code> feature. Each macro centralizes best practices so using it guarantees compliance.</p>
<h2 id="forces-19"><a class="header" href="#forces-19">Forces</a></h2>
<ul>
<li>Consistency vs. flexibility: macros enforce conventions while allowing custom logic inside</li>
<li>Zero cost vs. tooling: expansions must stay small and compile quickly</li>
<li>Guidance vs. noise: failures should point to the missing convention explicitly</li>
</ul>
<h2 id="examples-20"><a class="header" href="#examples-20">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! async_test {
    ($name:ident, $body:block) =&gt; {
        $crate::async_test_with_timeout!($name, 1, $body);
    };
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(not(feature = "otel"))]
#[macro_export]
macro_rules! otel_test {
    ($($tt:tt)*) =&gt; {
        compile_error!("OTEL testing requires the 'otel' feature. Enable with: --features otel");
    };
}
<span class="boring">}</span></code></pre></pre>
<h2 id="related-patterns-19"><a class="header" href="#related-patterns-19">Related Patterns</a></h2>
<ul>
<li>Pattern 1: AAA Pattern</li>
<li>Pattern 18: Timeout Defense in Depth</li>
<li>Pattern 19: Feature Gate Slices</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
