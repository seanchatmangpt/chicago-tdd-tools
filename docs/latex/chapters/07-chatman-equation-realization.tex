\chapter{Realizing the Chatman Equation in Testing}

\section{The Chatman Equation in Testing Context}

The Chatman Equation states:

\begin{equation}
A = \mu(\text{observations})
\end{equation}

where actions $A$ are deterministic functions of observations. In the testing framework, this
becomes:

\begin{equation}
\text{TestResult} = \text{test}(\text{Fixture}, \text{TestData})
\end{equation}

Chicago-tdd-tools ensures this equation holds in four ways:

\begin{enumerate}
  \item \textbf{Determinism}: Identical test inputs always produce identical results
  \item \textbf{Idempotence}: Running the same test twice produces the same outcome
  \item \textbf{Type Preservation}: Test data types are maintained throughout execution
  \item \textbf{Boundedness}: Test execution time is bounded and measurable
\end{enumerate}

\section{Property 1: Determinism}

\begin{theorem}[Test Determinism]
For all test fixtures $F_1, F_2$ and test data $D_1, D_2$, if $F_1 = F_2$ and $D_1 = D_2$,
then $\text{test}(F_1, D_1) = \text{test}(F_2, D_2)$.
\end{theorem}

\subsection{Implementation in chicago-tdd-tools}

The framework ensures determinism through:

\begin{enumerate}
  \item \textbf{No Global State}: Tests use fixtures (local scope), not global variables
  \item \textbf{No Side Effects in Assertions}: Assertions are pure functions
  \item \textbf{No Random Data}: Test data is explicit, not randomly generated (unless using property tests with fixed seeds)
  \item \textbf{No Timing Dependencies}: Tests do not depend on wall-clock time or system state
  \item \textbf{No External Calls}: Hot path does not make I/O calls
\end{enumerate}

\subsection{Validation}

Determinism is validated through property-based testing with fixed seeds:

\begin{lstlisting}[language=Rust]
#[test]
fn test_determinism() {
    use proptest::prelude::*;

    proptest!(|(data in arb_test_data())| {
        // Execute test multiple times with same input
        let result1 = run_test(&data);
        let result2 = run_test(&data);
        let result3 = run_test(&data);

        // Assert results are identical
        prop_assert_eq!(result1, result2);
        prop_assert_eq!(result2, result3);
    });
}
\end{lstlisting}

\section{Property 2: Idempotence}

\begin{theorem}[Test Idempotence]
Running the same test twice produces the same result:

\begin{equation}
\text{test}(\text{test}(F)) = \text{test}(F)
\end{equation}
\end{theorem}

\subsection{Implementation}

Idempotence is achieved through immutable fixtures:

\begin{lstlisting}[language=Rust]
// Fixture initialization (immutable)
let fixture = TestFixture::new()?;

// First test run
let result1 = run_test(&fixture);

// Second test run (fixture is unchanged)
let result2 = run_test(&fixture);

// Results are identical (fixture not mutated)
assert_eq!(result1, result2);
\end{lstlisting}

Key property: fixtures are created fresh for each test. They cannot be reused or mutated
by previous tests.

\subsection{Validation via Snapshot Testing}

Idempotence is validated by comparing snapshots:

\begin{lstlisting}[language=Rust]
#[test]
fn test_idempotence_snapshot() {
    let fixture = TestFixture::new()?;

    // Run test and snapshot result
    let result1 = run_test(&fixture)?;
    insta::assert_snapshot!("test_result_1", result1);

    // Run same test again
    let result2 = run_test(&fixture)?;
    insta::assert_snapshot!("test_result_1", result2);

    // Snapshots must be identical
}
\end{lstlisting}

\section{Property 3: Type Preservation}

\begin{theorem}[Type Safety Through Test Lifecycle]
For all test data $D$ of type $T$, operations on $D$ preserve type information:

\begin{equation}
D : T \implies \text{transform}(D) : T'
\end{equation}

where $T'$ is the expected output type.
\end{theorem}

\subsection{Implementation: Generic Fixtures}

Type preservation is enforced through generic fixtures:

\begin{lstlisting}[language=Rust]
// Generic fixture over data type T
pub struct DataFixture<T> {
    data: T,
}

impl<T> TestFixture for DataFixture<T>
where
    T: Default + Clone,
{
    fn new() -> Result<Self, Error> {
        Ok(DataFixture {
            data: T::default(),
        })
    }
}

// Usage: type is preserved throughout
let fixture: DataFixture<Order> = DataFixture::new()?;
let order: Order = fixture.data.clone();  // Type is Order, not generic

// If we try to assign to wrong type, compiler error:
// let customer: Customer = fixture.data;  // ERROR: cannot assign Order to Customer
\end{lstlisting}

\section{Property 4: Boundedness}

\begin{theorem}[Bounded Test Execution]
All test operations complete within measurable time bounds:

\begin{equation}
t(\text{test}) \leq \text{SLO}
\end{equation}

where SLO is specified per test (e.g., 500ms for unit tests).
\end{theorem}

\subsection{Implementation: Performance Tests}

Chicago-tdd-tools provides performance measurement via RDTSC on x86_64:

\begin{lstlisting}[language=Rust]
use chicago_tdd_tools::performance::TickCounter;

#[test]
fn test_within_tick_budget() {
    let counter = TickCounter::now();

    // Execute operation
    let result = expensive_operation();
    assert_ok!(result);

    // Check tick budget
    let ticks = counter.elapsed();
    assert!(ticks <= 1000, "Exceeded tick budget: {} > 1000", ticks);
}
\end{lstlisting}

Performance is measured in CPU ticks (hardware cycles), providing sub-microsecond precision.

\section{Integration: How the Framework Realizes A = µ(O)}

The Chatman Equation is realized through the entire test lifecycle:

\subsection{Step 1: Observations (Test Data)}

Test data represents observations $O$:

\begin{lstlisting}[language=Rust]
// Observations: structured test data
let order = OrderBuilder::new()
    .id(123)
    .amount(99.99)
    .status(OrderStatus::Pending)
    .build()?;  // Type-safe construction
\end{lstlisting}

\subsection{Step 2: Measurement Function (Test Execution)}

The test function $\mu$ operates deterministically on observations:

\begin{lstlisting}[language=Rust]
// Measurement function: pure test logic
fn test_order_processing(order: Order) -> Result<TestResult, Error> {
    // Arrange: setup
    let processor = OrderProcessor::new();

    // Act: execute
    let result = processor.process(&order)?;

    // Assert: verify
    assert_eq!(result.status, OrderStatus::Processed);

    Ok(TestResult::Pass)
}
\end{lstlisting}

\subsection{Step 3: Actions (Test Results)**

Test results are deterministic outputs:

\begin{lstlisting}[language=Rust]
// Actions: test result (Pass/Fail)
let result: TestResult = test_order_processing(order)?;
// Result is deterministic function of input

// Snapshot for reproducibility
insta::assert_snapshot!("order_result", result);
\end{lstlisting}

\section{Validation: Proving the Equation Holds}

\subsection{Empirical Validation}

The framework includes tests that prove $A = \mu(O)$:

\begin{lstlisting}[language=Rust]
#[test]
fn validate_chatman_equation() {
    // Given: observation O
    let obs = create_test_observation();

    // Compute: A1 = µ(O)
    let action1 = measure(&obs)?;

    // Recompute: A2 = µ(O)
    let action2 = measure(&obs)?;

    // Verify: A1 == A2 (determinism)
    assert_eq!(action1, action2);

    // Verify: applying µ twice = applying once (idempotence)
    let action3 = measure(&action1)?;
    assert_eq!(action1, action3);

    // Verify: snapshot consistency
    insta::assert_snapshot!("measurement_result", action1);
}
\end{lstlisting}

\subsection{Property-Based Validation}

Properties are tested across all possible inputs (within the search space):

\begin{lstlisting}[language=Rust]
#[test]
fn property_determinism() {
    proptest!(|(obs in arb_observation())| {
        let result1 = measure(&obs)?;
        let result2 = measure(&obs)?;
        prop_assert_eq!(result1, result2);
    });
}

#[test]
fn property_idempotence() {
    proptest!(|(obs in arb_observation())| {
        let action1 = measure(&obs)?;
        let action2 = measure(&action1)?;
        prop_assert_eq!(action1, action2);
    });
}

#[test]
fn property_type_preservation() {
    proptest!(|(obs in arb_observation())| {
        let action = measure(&obs)?;
        // Type system already proves this, but we validate
        assert!(action_has_correct_type(&action));
    });
}
\end{lstlisting}

\section{The Complete Picture}

Chicago-tdd-tools proves the Chatman Equation through:

\begin{table}[H]
\centering
\caption{Chatman Equation Realization in Testing}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Equation Component} & \textbf{Implementation} & \textbf{Validation} \\
\hline
Observations $O$ & Test fixtures + data builders & Type system \\
\hline
Measurement function $\mu$ & Test logic (AAA pattern) & Determinism tests \\
\hline
Actions $A$ & Test results + snapshots & Snapshot testing \\
\hline
Determinism & Pure functions + no side effects & Property tests \\
\hline
Idempotence & Immutable fixtures + fresh state & Multiple runs \\
\hline
Type preservation & Generic fixtures + type system & Compiler proof \\
\hline
Boundedness & RDTSC tick measurement & Performance tests \\
\hline
\end{tabular}
\end{table}

\section{Conclusion: Tests Are Deterministic by Design}

The framework makes deterministic, reproducible, verifiable tests the default. Tests written
with chicago-tdd-tools:

\begin{enumerate}
  \item Cannot violate the AAA pattern (type system enforces it)
  \item Cannot have invalid states (impossible states are unrepresentable)
  \item Cannot panic unpredictably (error handling is required)
  \item Cannot have global state pollution (fixtures are isolated)
  \item Cannot have flaky behavior (deterministic by construction)
\end{enumerate}

This embodies the core principle of the Chatman Equation: actions are deterministic functions
of observations, measured and verified at every step.
