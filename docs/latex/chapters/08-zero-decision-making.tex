\chapter{Zero Human Decision-Making: Governance Model}

\section{Policy Statement}

After deployment, humans provide only untyped \(\Delta \obs\) inputs. All decisions execute via
hooks and workflows. There are no discretionary routing paths, no manual approval gates, no
advisory layers, and no shadow channels.

Any path lacking a workflow pattern mapping is refused at ingress guards \(\hooks\).

\begin{theorem}[Zero Human Decision-Making]
Post-deployment, the decision-making loop is closed to human input:

\begin{equation}
\text{Action} = \measure(\text{untyped input}) \text{ via hooks and patterns only}
\end{equation}

No human decides. Humans provide only data (\(\Delta \obs\)). The measurement function
\(\measure\) decides and executes.
\end{theorem}

\section{No Discretionary Routing}

\subsection{Principle}

All routing decisions are one of the 43 workflow patterns or a bounded composition thereof.
Discretionary steps are illegal at ingress \(\hooks\). Every routing decision is deterministic,
bounded, and receipt-verified.

\subsection{Example: Loan Application Routing}

\textbf{Forbidden Approach}:
\begin{lstlisting}[language=bash,numbers=none]
# Manual triage
if case.amount > $100K then
    route to senior_analyst  # Discretionary!
else
    route to junior_analyst
\end{lstlisting}

The routing to ``senior analyst'' is a human decision, not a workflow pattern. It fails
at ingress guard validation.

\textbf{Required Approach}:

\begin{lstlisting}[language=bash,numbers=none]
# Deterministic pattern-based routing
if case.amount > $100K then
    execute Pattern 4 (Exclusive Choice)
    with guard: legality, budgets
    branch: route to senior_review_workflow
else
    execute Pattern 4 (Exclusive Choice)
    with guard: legality, budgets
    branch: route to standard_review_workflow
\end{lstlisting}

The routing decision is executed via Pattern 4 (Exclusive Choice) with explicit guard
verification. The receipt proves what rule was applied.

\section{No Manual Approval Gates}

\subsection{Principle}

Approvals, triage, escalation, and case progression are knowledge hooks. There are no manual
approval gates, no human-in-the-loop checkpoints, and no discretionary escalations.

\subsection{Example: Compliance Review}

\textbf{Forbidden Approach}:
\begin{lstlisting}[language=bash,numbers=none]
# Manual gate
case.status = pending_approval
# Waiting for compliance manager to review and approve
\end{lstlisting}

This requires a human to make a discretionary decision. It fails ingress validation.

\textbf{Required Approach}:

\begin{lstlisting}[language=bash,numbers=none]
# Automated hook-based approval
hook compliance_check {
    trigger: case.status == pending_review
    check: {
        SHACL constraints for regulatory requirements
        IF all constraints pass THEN approve
        ELSE escalate
    }
    act: Pattern 4 (Exclusive Choice)
        branch_true: route to completion
        branch_false: route to escalation_workflow
    receipt: (trigger, constraints, decision, action)
}
\end{lstlisting}

Compliance checking is automated via SHACL constraints. The hook makes the decision
deterministically. The receipt documents the decision rule and its application.

\section{No Advisory Layers}

\subsection{Principle}

Large language models annotate and normalize \(\Delta \obs\) inputs; they do not emit
\(A\) actions. LLMs serve as typed ingress instruments, not as deciders.

\subsection{Architecture}

\begin{equation}
\text{Unstructured Input} \xrightarrow{\text{LLM}} \text{Typed RDF} \xrightarrow{\text{Hooks}} \text{Action}
\end{equation}

\textbf{LLM Role}: Convert unstructured text into structured RDF triples with types and
confidence scores.

\begin{lstlisting}[language=bash,numbers=none]
# Input: Customer email about a complaint
Input: "My order arrived damaged. I'm unhappy."

# LLM normalizes to typed RDF
Output RDF:
  @prefix ex: <http://example.org/> .
  _:complaint a ex:Complaint ;
    ex:type "product_damage" ;
    ex:severity "high" ;
    ex:confidence 0.92 .

# Hooks decide (not LLM)
hook complaint_routing {
    trigger: ?complaint a ex:Complaint
    check: ?complaint ex:severity "high" AND
           ?complaint ex:confidence > 0.8
    act: Pattern 4 (Exclusive Choice) with
         route to high_priority_queue
    receipt: (lm_input, typed_rdf, decision, action)
}
\end{lstlisting}

The LLM produces typed input (\(\Delta \obs\)). Hooks make decisions and execute patterns.
No LLM output is treated as a decision; it is merely data.

\section{No Shadow Channels}

\subsection{Principle}

Email, chat, meetings, and informal communication are untyped noise until ingressed. Nothing
executes without a hook and receipt. All communication must be ingressed as \(\Delta \obs\)
and processed through hooks and workflows.

\subsection{Example: Out-of-Band Decision}

\textbf{Forbidden Approach}:
\begin{lstlisting}[language=bash,numbers=none]
# Decision made in a meeting
In meeting: Manager approves exception for case #12345
# No record in system; case routed manually
\end{lstlisting}

This decision has no audit trail and is not reproducible. It fails governance.

\textbf{Required Approach}:

\begin{lstlisting}[language=bash,numbers=none]
# Decision ingressed as typed data
Input: Manager inputs decision via approved form
  case_id: 12345
  decision: approve_exception
  reason: business_justification

# Ingress validation
hook exception_approval {
    trigger: ?exception a ex:ExceptionRequest
    check: ?exception ex:case_id ?id AND
           ?exception ex:decision "approve_exception" AND
           SPARQL query validates authority
    act: execute Pattern 4 (Exclusive Choice) to
         route to exception_workflow
    receipt: (timestamp, requester, authority, decision, action)
}

# Result: Fully auditable, reproducible, verifiable
\end{lstlisting}

The decision is formalized as typed data, validated, executed via a pattern, and receipted.
No shadow channels.

\section{Governance Model}

\subsection{Core Rules}

\begin{enumerate}
  \item \textbf{No Discretion}: Every action follows a workflow pattern or is rejected
  \item \textbf{No Exceptions}: Exceptions require an explicit exception workflow pattern
  \item \textbf{No Overrides}: No human can override a guard constraint without ingressing
    a change to the ontology (which triggers regeneration)
  \item \textbf{Receipts Govern}: Every action is receipted; receipts are the source of truth
\end{enumerate}

\subsection{Change Control Process}

Hook changes require dual sign-off and staged rollout:

\begin{enumerate}
  \item \textbf{Proposal}: Domain expert proposes hook change
  \item \textbf{Review}: Guard steward reviews guard implications
  \item \textbf{Approval}: Dual sign-off required
  \item \textbf{Deployment}: Staged rollout with receipt verification
  \item \textbf{Verification}: Independent recomputation validates receipt
\end{enumerate}

\textbf{Implementation}:

\begin{lstlisting}[language=Rust]
pub struct ChangeControlRequest {
    hook_id: String,
    proposed_change: HookDefinition,
    domain_expert: User,
    guard_steward: User,
    approval_timestamp: u64,
    receipt: Receipt,
}

impl ChangeControlRequest {
    pub fn approve(&mut self, approver: User) -> Result<(), Error> {
        // Require both domain expert and guard steward sign-off
        self.approval_count += 1;
        if self.approval_count < 2 {
            return Err("Requires dual sign-off");
        }

        // Stage rollout: start with shadow mode
        // Measure impact before full deployment
        // Once impact is acceptable, roll out to 100%

        // Generate receipt for change
        self.receipt = Receipt::change_control(
            self.hook_id.clone(),
            self.proposed_change.clone(),
            approver.id,
        );

        Ok(())
    }
}
\end{lstlisting}

\section{Kill Switch and Rollback}

Per-domain suspension is supported with receipt-based rollback:

\begin{enumerate}
  \item \textbf{Detection}: Receipt delta \(> 10^{-3}\) tolerance
  \item \textbf{Suspension}: Domain suspended automatically
  \item \textbf{Rollback}: Receipt-based rollback to last verified state
  \item \textbf{Correction}: Domain corrected and re-verified
  \item \textbf{Resumption}: Domain resumed after verification
\end{enumerate}

\begin{lstlisting}[language=Rust]
pub struct DomainSuspensionManager {
    receipts: ReceiptLog,
    drift_threshold: f64,
}

impl DomainSuspensionManager {
    pub fn monitor(&self) -> Result<(), DomainError> {
        let latest_receipt = self.receipts.last()?;
        let drift = latest_receipt.compute_drift()?;

        if drift > 0.001 {  // 10^-3 threshold
            // Suspend domain
            self.suspend_domain()?;

            // Rollback to last verified state
            let verified_receipt = self.receipts
                .find_last_verified()?;
            self.rollback_to(&verified_receipt)?;

            // Alert operators
            alert_critical!("Domain suspended due to drift: {}", drift);
        }

        Ok(())
    }

    pub fn resume_domain(&mut self) -> Result<(), DomainError> {
        // Verify all receipts are now consistent
        for receipt in &self.receipts {
            receipt.verify_against_previous()?;
        }

        // Resume domain
        alert_info!("Domain resumed after verification");
        Ok(())
    }
}
\end{lstlisting}

\section{Regulatory Alignment}

Controls map to regulatory catalogs (SOX, HIPAA, PCI) by table, not narrative:

\subsection{Example: SOX Control â€” Segregation of Duties}

\textbf{Control Objective}: ``Segregation of duties shall be maintained.''

\textbf{Traditional Approach}: Narrative policy document stating the principle.

\textbf{Zero-Decision Approach}:

\begin{lstlisting}[language=Rust]
// Encode segregation of duties as a guard
pub struct SegregationOfDutiesGuard;

impl SegregationOfDutiesGuard {
    pub fn check(&self, action: &Action) -> Result<(), GuardViolation> {
        // Extract roles from action
        let roles = action.get_roles();

        // Check: initiator != approver
        if roles.initiator == roles.approver {
            return Err(GuardViolation::SegrExpression(
                "Segregation violated: initiator == approver"
            ));
        }

        // Check: approver != executor
        if roles.approver == roles.executor {
            return Err(GuardViolation::SegrExpression(
                "Segregation violated: approver == executor"
            ));
        }

        Ok(())
    }
}

// Hook with segregation guard
let hook = KnowledgeHook {
    trigger: transaction_initiated,
    check: SegregationOfDutiesGuard::check,
    act: execute_transaction_workflow,
    receipt: automatic,
};
\end{lstlisting}

\textbf{Result}: The SOX control is implemented in code. Every transaction is checked.
The receipt proves the control was applied. No narrative policy needed.

\begin{table}[H]
\centering
\caption{Control Catalog Mapping}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Regulation} & \textbf{Control} & \textbf{Implementation} & \textbf{Audit Evidence} \\
\hline
SOX & Segregation of Duties & Guard constraint & Receipt (guard applied) \\
\hline
HIPAA & Patient Data Access & SPARQL ACL query & Receipt (access decision) \\
\hline
PCI & Payment Authorization & Workflow pattern & Receipt (pattern executed) \\
\hline
\end{tabular}
\end{table}

\section{Auditability Guarantees}

\subsection{Reproducibility Proof}

Every decision is reproducible. Given:
\begin{enumerate}
  \item Original observation \(\obs\)
  \item Receipt \(\receipt\)
\end{enumerate}

An independent verifier can recompute:

\begin{equation}
\measure(\obs) \xstackrel{?}{=} \text{action in receipt}
\end{equation}

If the hashes match within \(10^{-3}\) tolerance, the decision is verified.

\begin{lstlisting}[language=Rust]
pub fn verify_decision(
    original_obs: &RdfGraph,
    receipt: &Receipt,
) -> Result<bool, Error> {
    // Recompute the measurement function
    let recomputed_action = measure(original_obs)?;

    // Compare hashes
    let original_hash = receipt.h_action;
    let recomputed_hash = sha3_256(&recomputed_action);

    // Compute drift
    let drift = abs_diff(original_hash, recomputed_hash)
        / recomputed_hash as f64;

    Ok(drift < 0.001)
}
\end{lstlisting}

\subsection{Compliance Evidence}

Receipts are the source of compliance evidence:

\begin{enumerate}
  \item \textbf{Decision Audit}: When was a decision made? Receipt timestamp.
  \item \textbf{Decision Rule}: What rule applied? Receipt guard hash and pattern ID.
  \item \textbf{Decision Justification}: Why was this decision made? Receipt constraint validation.
  \item \textbf{Decision Authority}: Who approved the rule? Dual sign-off in change control receipt.
  \item \textbf{Decision Reproducibility}: Can the decision be reproduced? Yes, via receipt verification.
\end{enumerate}

No narrative policy needed. The code is the policy. The receipts are the evidence.
