\documentclass[12pt,a4paper]{book}

% ============================================================================
% PREAMBLE - Packages and Configuration
% ============================================================================

% Language and encoding
\usepackage[utf-8]{inputenc}
\usepackage[english]{babel}

% Mathematical packages
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{proof}
\usepackage{stmaryrd}

% Graphics and diagrams
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usepackage{graphicx}
\usepackage[export]{adjustbox}

% Code listings (Rust syntax)
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyvrb}

% Tables and formatting
\usepackage{array}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{colortbl}
\usepackage{longtable}

% Hyperlinks and references
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{bookmark}

% Layout and margins
\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
\usepackage{fancyhdr}
\usepackage{setspace}

% Footnotes
\usepackage{footmisc}

% Theorems and proofs
\usepackage{amsthm}
\usepackage{thmtools}

% Additional utilities
\usepackage{enumitem}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}

% ============================================================================
% LISTINGS CONFIGURATION (Rust Code)
% ============================================================================

\lstdefinelanguage{Rust}{
  keywords={fn, let, mut, pub, struct, enum, impl, trait, type, mod, use, async, await,
            if, else, match, for, while, return, true, false, None, Some, Ok, Err},
  keywordstyle=\color{purple}\bfseries,
  ndkeywords={Self, i32, u32, i64, u64, f32, f64, bool, String, Vec, Option, Result, Box},
  ndkeywordstyle=\color{blue},
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  morestring=[b]",
  morestring=[b]',
  basicstyle=\ttfamily\small,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  frame=single,
  rulecolor=\color{black},
  numbers=left,
  numberstyle=\tiny\color{gray},
  numbersep=5pt
}

% ============================================================================
% THEOREM STYLES
% ============================================================================

\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{assumption}[definition]{Assumption}
\newtheorem{example}[definition]{Example}
\newtheorem{property}[definition]{Property}

% ============================================================================
% DOCUMENT METADATA
% ============================================================================

\title{\textbf{The Chatman Equation and the Industrial Revolution of Knowledge}\\
       \large{Formal Verification Through chicago-tdd-tools}}
\author{Sean Chatman \\
        with Formal Verification Framework Analysis}
\date{November 16, 2025 \\
      Version 1.0}

% ============================================================================
% CUSTOM COMMANDS
% ============================================================================

% Mathematical notation
\newcommand{\obs}[0]{\mathcal{O}}
\newcommand{\actions}[0]{\mathcal{A}}
\newcommand{\measure}[0]{\mu}
\newcommand{\hooks}[0]{\mathcal{H}}
\newcommand{\guards}[0]{\mathcal{G}}
\newcommand{\drift}[0]{\delta}
\newcommand{\receipt}[0]{\mathcal{R}}
\newcommand{\ontology}[0]{\Sigma}
\newcommand{\invariants}[0]{\mathcal{Q}}

% Code and type notation
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\type}[1]{\text{\texttt{#1}}}
\newcommand{\rustfn}[1]{\text{\textbf{#1}}}
\newcommand{\ns}[0]{\text{ ns}}
\newcommand{\ms}[0]{\text{ ms}}
\newcommand{\ticks}[0]{\text{ ticks}}

% Logic notation
\newcommand{\proves}[0]{\vdash}
\newcommand{\satisfies}[0]{\models}
\newcommand{\transition}[2]{\xrightarrow{#1} #2}

% ============================================================================
% DOCUMENT BODY
% ============================================================================

\frontmatter

\maketitle

\chapter*{Abstract}

This document provides formal verification and implementation validation of the Chatman Equation
(\(A = \measure(\obs)\)) through the chicago-tdd-tools testing framework. We establish that:

\begin{enumerate}
  \item The measurement function \(\measure : \obs \to \actions\) is deterministic, idempotent,
    and satisfies bounded execution guarantees
  \item Knowledge hooks implement the unit model of knowledge work with cryptographic receipts
  \item All 43 Van der Aalst workflow patterns are implemented as deterministic operators
  \item Type-level enforcement via Rust's type system realizes Poka-Yoke principles at compile time
  \item Production measurements validate sub-nanosecond rule evaluation and reproducible execution
\end{enumerate}

The framework demonstrates that enterprise knowledge work can transition from discretionary human
judgment to bounded, machine-speed execution with full auditability. Complete pattern coverage
enables zero human decision-making after deployment while maintaining reproducible audit trails.

\tableofcontents
\listoffigures
\listoftables

\chapter*{Notation and Conventions}

\section*{Mathematical Notation}

\begin{itemize}
  \item \(\obs \in \mathcal{O}\) — Observations (typed RDF workflow graphs)
  \item \(\measure : \obs \to \actions\) — Measurement function (deterministic projection)
  \item \(\actions \in \mathcal{A}\) — Actions (workflow executions)
  \item \(\hooks \in \mathcal{H}\) — Knowledge hooks (trigger, check, act, receipt)
  \item \(\guards \in \mathcal{G}\) — Guard constraints (legality, budgets, chronology, causality)
  \item \(\invariants \in \mathcal{Q}\) — Invariants (properties preserved by \(\measure\))
  \item \(\receipt \in \mathcal{R}\) — Cryptographic receipts (Merkle-linked proofs)
  \item \(\ontology \in \Sigma\) — Ontology (RDF/SHACL schema)
  \item \(\drift(\Sigma) \leq \epsilon\) — Schema drift bound (typically 0.5\%)
  \item \(h(x)\) — SHA3-256 cryptographic hash
\end{itemize}

\section*{Type Notation}

\begin{itemize}
  \item \(\type{TestState<Arrange>}\) — Type-level test state (Arrange phase)
  \item \(\type{TestFixture<T>}\) — Generic test fixture over type parameter T
  \item \(\type{Result<T, E>}\) — Sum type for error handling
  \item \(\type{Option<T>}\) — Optional value type
  \item \(\type{#[derive(TestBuilder)]}\) — Procedural macro for builder generation
\end{itemize}

\section*{Performance Notation}

\begin{itemize}
  \item \(\leq 2\) ns — Hot path latency (≤8 CPU ticks)
  \item \(\leq 500\) ms — Warm path latency (orchestration, ETL)
  \item \(\leq 500\) ms — Cold path latency (complex queries, reasoning)
  \item P99 — 99th percentile (worst-case reported)
  \item RPN — Risk Priority Number (FMEA metric)
\end{itemize}

\mainmatter

% ============================================================================
% CHAPTERS
% ============================================================================

\include{chapters/01-introduction}
\include{chapters/02-chatman-equation}
\include{chapters/03-knowledge-hooks}
\include{chapters/04-type-level-enforcement}
\include{chapters/05-yawl-patterns}
\include{chapters/06-reflex-stack}
\include{chapters/07-empirical-validation}
\include{chapters/08-zero-decision-making}
\include{chapters/09-industrial-revolution}

\backmatter

% ============================================================================
% BIBLIOGRAPHY AND APPENDICES
% ============================================================================

\bibliographystyle{plainnat}
\bibliography{references}

\appendix

\include{appendix/A-code-examples}
\include{appendix/B-mathematical-proofs}
\include{appendix/C-operator-registry}
\include{appendix/D-receipt-schemas}
\include{appendix/E-guard-constraints}

\end{document}
