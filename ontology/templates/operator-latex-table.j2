% Autogenerated Operator Specification Tables
%
% This file is automatically generated from the Chatman Equation ontology.
% DO NOT EDIT MANUALLY - regenerate using:
%   ggen project --ontology ontology/chatman-equation.ttl --template ontology/templates/operator-latex-table.j2
%
% Last Generated: {{ generation_timestamp }}
% Ontology Version: {{ ontology_version }}

\chapter{Appendix C: Operator Specification Tables}

\section{Introduction}

This appendix contains comprehensive specifications of all 43 YAWL workflow control patterns
as formalized in the Chatman Equation ontology. Each operator is characterized by four key properties:

\begin{itemize}
  \item \textbf{Determinism}: Identical inputs always produce identical outputs
  \item \textbf{Idempotence}: $f(f(x)) = f(x)$ (running twice = running once)
  \item \textbf{Type Preservation}: Input types maintained through execution
  \item \textbf{Boundedness}: Execution time is measurable and finite
\end{itemize}

\section{YAWL Patterns by Category}

Generated {{ generation_timestamp | safe }}

{% set patterns_by_category = {} %}
{% for operator in operators %}
  {% if operator.pattern_category not in patterns_by_category %}
    {% set _ = patterns_by_category.update({operator.pattern_category: []}) %}
  {% endif %}
  {% set _ = patterns_by_category[operator.pattern_category].append(operator) %}
{% endfor %}

{% for category, ops in patterns_by_category.items() | sort %}

\subsection{{{ category }} ({{ ops | length }} patterns)}

\begin{longtable}{|l|c|c|c|c|r|}
  \hline
  \textbf{Pattern} & \textbf{Det.} & \textbf{Idemp.} & \textbf{Type-P.} & \textbf{Bounded} & \textbf{Max Latency} \\
  \hline
  \endhead
  \hline
  \endfoot

  {% for operator in ops %}
  {{ operator.pattern_number | safe }} - {{ operator.pattern_name }} &
  {% if operator.deterministic %}\checkmark{% else %}{\color{red}\ding{55}}{% endif %} &
  {% if operator.idempotent %}\checkmark{% else %}{\color{red}\ding{55}}{% endif %} &
  {% if operator.type_preserving %}\checkmark{% else %}{\color{red}\ding{55}}{% endif %} &
  {% if operator.bounded %}\checkmark{% else %}{\color{red}\ding{55}}{% endif %} &
  {% if operator.bounded %}{{ (operator.max_latency_ns / 1000000) | int }}ms{% else %}âˆž{% endif %} \\
  \hline
  {% endfor %}

\end{longtable}

{% endfor %}

\section{Operator Property Analysis}

\subsection{Properties Summary}

\begin{table}[H]
  \centering
  \caption{Chatman Equation Property Coverage}
  \begin{tabular}{|l|r|r|}
    \hline
    \textbf{Property} & \textbf{Count} & \textbf{Percentage} \\
    \hline
    Deterministic & {{ operators | selectattr("deterministic", "equalto", true) | list | length }} & {{ ((operators | selectattr("deterministic", "equalto", true) | list | length) * 100.0 / (operators | length)) | round(1) }}\% \\
    Idempotent & {{ operators | selectattr("idempotent", "equalto", true) | list | length }} & {{ ((operators | selectattr("idempotent", "equalto", true) | list | length) * 100.0 / (operators | length)) | round(1) }}\% \\
    Type-Preserving & {{ operators | selectattr("type_preserving", "equalto", true) | list | length }} & {{ ((operators | selectattr("type_preserving", "equalto", true) | list | length) * 100.0 / (operators | length)) | round(1) }}\% \\
    Bounded & {{ operators | selectattr("bounded", "equalto", true) | list | length }} & {{ ((operators | selectattr("bounded", "equalto", true) | list | length) * 100.0 / (operators | length)) | round(1) }}\% \\
    \hline
  \end{tabular}
\end{table}

\subsection{Guard Requirements by Operator}

\begin{table}[H]
  \centering
  \caption{Operators Requiring Each Guard Type}
  \begin{tabular}{|l|r|}
    \hline
    \textbf{Guard Type} & \textbf{Operator Count} \\
    \hline
    {% for guard_type in guard_types %}
    {{ guard_type | safe }} & {{ operators | selectattr("required_guards", "contains", guard_type) | list | length }} \\
    {% endfor %}
    \hline
  \end{tabular}
\end{table}

\section{Individual Operator Specifications}

\subsection{Basic Control Flow Patterns (1-6)}

{% for operator in operators | selectattr("pattern_category", "equalto", "Basic Control Flow") | list | sort(attribute="pattern_number") %}

\subsubsection{Pattern {{ operator.pattern_number }}: {{ operator.pattern_name }}}

\begin{description}
  \item[ID] \texttt{{{ operator.hook_id }}}
  \item[Category] {{ operator.pattern_category }}
  \item[Deterministic] {{ "Yes (\checkmark)" if operator.deterministic else "No" }}
  \item[Idempotent] {{ "Yes (\checkmark)" if operator.idempotent else "No" }}
  \item[Type-Preserving] {{ "Yes (\checkmark)" if operator.type_preserving else "No" }}
  \item[Bounded] {{ "Yes (\checkmark)" if operator.bounded else "No (unbounded)" }}
  \item[Max Latency] {{ (operator.max_latency_ns / 1000000000) | round(1) }}s ({{ operator.max_latency_ns }}ns)
  \item[Required Guards] {{ operator.required_guards | join(", ") }}
  {% if operator.slo %}\item[SLO] {{ operator.slo }}{% endif %}
\end{description}

\noindent\textbf{Theorem Mapping:}
\begin{itemize}
  \item Thm-7.{{ operator.pattern_number }}: Properties of {{ operator.pattern_name }}
\end{itemize}

{% endfor %}

\section{Advanced Branching and Synchronization (7-15)}

{% for operator in operators | selectattr("pattern_category", "equalto", "Advanced Branching") | list | sort(attribute="pattern_number") %}

\subsubsection{Pattern {{ operator.pattern_number }}: {{ operator.pattern_name }}}

\begin{description}
  \item[ID] \texttt{{{ operator.hook_id }}}
  \item[Deterministic] {{ "Yes (\checkmark)" if operator.deterministic else "No" }}
  \item[Idempotent] {{ "Yes (\checkmark)" if operator.idempotent else "No" }}
  \item[Type-Preserving] {{ "Yes (\checkmark)" if operator.type_preserving else "No" }}
  \item[Bounded] {{ "Yes (\checkmark)" if operator.bounded else "No" }}
  \item[Max Latency] {{ (operator.max_latency_ns / 1000000000) | round(1) }}s
  \item[Required Guards] {{ operator.required_guards | join(", ") }}
\end{description}

{% endfor %}

\section{Coverage Metrics}

\subsection{Theorem Coverage}

Total YAWL patterns implemented: {{ operators | length }}

Theorems validated per pattern:
\begin{itemize}
  \item Determinism Property
  \item Idempotence Property
  \item Type Preservation Property
  \item Boundedness Property
\end{itemize}

\subsection{Guard Enforcement}

Each operator specifies required guards:
\begin{itemize}
  {% for guard_type in guard_types %}
  \item \textbf{{{ guard_type }}} - Applied to {{ operators | selectattr("required_guards", "contains", guard_type) | list | length }} operators
  {% endfor %}
\end{itemize}

\section{Generation Metadata}

\begin{verbatim}
Generated: {{ generation_timestamp }}
Ontology Version: {{ ontology_version }}
Harness Version: {{ harness_version }}
Total Patterns: {{ operators | length }}
Total Categories: {{ patterns_by_category | length }}
Total Guards: {{ guard_types | length }}
\end{verbatim}

\section*{Notes}

\begin{itemize}
  \item All specifications derived from \texttt{ontology/chatman-equation.ttl}
  \item Determinism guaranteed for operators marked with \checkmark
  \item Bounded execution enforced by max latency specifications
  \item Guard requirements ensure safe operator composition
  \item Type preservation verified by Rust type system at compile time
\end{itemize}

% End of autogenerated appendix
