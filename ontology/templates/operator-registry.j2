//! Autogenerated Operator Registry
//!
//! This file is automatically generated from the Chatman Equation ontology.
//! DO NOT EDIT MANUALLY - regenerate using:
//!   ggen project --ontology ontology/chatman-equation.ttl --template ontology/templates/operator-registry.j2
//!
//! Last Generated: {{ generation_timestamp }}
//! Ontology Version: {{ ontology_version }}
//! Harness Version: {{ harness_version }}

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Operator Descriptor - metadata about a workflow operator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperatorDescriptor {
    /// Unique operator identifier (e.g., "sequence_op")
    pub hook_id: String,

    /// YAWL pattern number (1-43)
    pub pattern_number: u32,

    /// Pattern name (e.g., "Sequence")
    pub pattern_name: String,

    /// Pattern category (e.g., "Basic Control Flow")
    pub pattern_category: String,

    /// If true, identical inputs always produce identical outputs
    pub deterministic: bool,

    /// If true, f(f(x)) = f(x)
    pub idempotent: bool,

    /// If true, types are preserved through execution
    pub type_preserving: bool,

    /// If true, execution time is bounded
    pub bounded: bool,

    /// Maximum allowed execution time in nanoseconds
    pub max_latency_ns: i64,

    /// Required guards for safe execution
    pub required_guards: Vec<String>,

    /// Service level objective
    pub slo: Option<String>,
}

impl OperatorDescriptor {
    /// Check if operator satisfies all properties
    pub fn satisfies_all_properties(&self) -> bool {
        self.deterministic && self.idempotent && self.type_preserving && self.bounded
    }

    /// Check if operator is bounded
    pub fn is_bounded(&self) -> bool {
        self.bounded && self.max_latency_ns > 0
    }
}

/// Global operator registry
pub struct OperatorRegistry {
    operators: HashMap<String, OperatorDescriptor>,
}

impl OperatorRegistry {
    /// Create a new operator registry with all YAWL patterns
    pub fn new() -> Self {
        let mut operators = HashMap::new();

        // Register all operators from the ontology
        {% for operator in operators %}
        operators.insert(
            "{{ operator.hook_id }}".to_string(),
            OperatorDescriptor {
                hook_id: "{{ operator.hook_id }}".to_string(),
                pattern_number: {{ operator.pattern_number }},
                pattern_name: "{{ operator.pattern_name }}".to_string(),
                pattern_category: "{{ operator.pattern_category }}".to_string(),
                deterministic: {{ operator.deterministic | lower }},
                idempotent: {{ operator.idempotent | lower }},
                type_preserving: {{ operator.type_preserving | lower }},
                bounded: {{ operator.bounded | lower }},
                max_latency_ns: {{ operator.max_latency_ns }},
                required_guards: vec![
                    {% for guard in operator.required_guards %}"{{ guard }}".to_string(){{ "," if not loop.last }}{% endfor %}
                ],
                slo: {% if operator.slo %}Some("{{ operator.slo }}".to_string()){% else %}None{% endif %},
            },
        );
        {% endfor %}

        Self { operators }
    }

    /// Look up an operator by hook ID
    pub fn get_operator(&self, hook_id: &str) -> Option<&OperatorDescriptor> {
        self.operators.get(hook_id)
    }

    /// Get all operators
    pub fn all_operators(&self) -> Vec<&OperatorDescriptor> {
        self.operators.values().collect()
    }

    /// Count operators by category
    pub fn count_by_category(&self) -> HashMap<String, usize> {
        let mut counts = HashMap::new();
        for op in self.operators.values() {
            *counts.entry(op.pattern_category.clone()).or_insert(0) += 1;
        }
        counts
    }

    /// Count deterministic operators
    pub fn count_deterministic(&self) -> usize {
        self.operators.values().filter(|op| op.deterministic).count()
    }

    /// Count bounded operators
    pub fn count_bounded(&self) -> usize {
        self.operators.values().filter(|op| op.bounded).count()
    }

    /// Get operators requiring a specific guard
    pub fn operators_with_guard(&self, guard: &str) -> Vec<&OperatorDescriptor> {
        self.operators
            .values()
            .filter(|op| op.required_guards.contains(&guard.to_string()))
            .collect()
    }
}

impl Default for OperatorRegistry {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_registry_initialization() {
        let registry = OperatorRegistry::new();
        assert_eq!(registry.all_operators().len(), {{ operator_count }});
    }

    #[test]
    fn test_operator_lookup() {
        let registry = OperatorRegistry::new();

        // Test lookup of a known operator
        let op = registry.get_operator("sequence_op");
        assert!(op.is_some());
        assert_eq!(op.unwrap().pattern_number, 1);
    }

    #[test]
    fn test_count_by_category() {
        let registry = OperatorRegistry::new();
        let counts = registry.count_by_category();

        // Should have multiple categories
        assert!(counts.len() > 0);
        assert!(counts.contains_key("Basic Control Flow"));
    }

    #[test]
    fn test_deterministic_operators() {
        let registry = OperatorRegistry::new();
        let count = registry.count_deterministic();

        // Most operators are deterministic
        assert!(count > 0);
        assert!(count <= registry.all_operators().len());
    }

    #[test]
    fn test_guard_filtering() {
        let registry = OperatorRegistry::new();
        let with_legality = registry.operators_with_guard("Legality");

        // Many operators should have Legality guard
        assert!(with_legality.len() > 0);
    }
}

/// Global registry instance (lazy initialized)
use std::sync::OnceLock;

static REGISTRY: OnceLock<OperatorRegistry> = OnceLock::new();

/// Get the global operator registry
pub fn global_registry() -> &'static OperatorRegistry {
    REGISTRY.get_or_init(OperatorRegistry::new)
}

/// Metadata about the generated code
pub const OPERATOR_COUNT: usize = {{ operator_count }};
pub const GENERATION_TIMESTAMP: &str = "{{ generation_timestamp }}";
pub const ONTOLOGY_VERSION: &str = "{{ ontology_version }}";
